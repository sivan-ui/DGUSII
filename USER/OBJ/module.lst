C51 COMPILER V9.60.0.0   MODULE                                                            11/04/2023 11:13:36 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MODULE
OBJECT MODULE PLACED IN .\OBJ\module.obj
COMPILER INVOKED BY: C:\Keil_C51\C51\BIN\C51.EXE module.c LARGE OMF2 OPTIMIZE(9,SIZE) BROWSE INCDIR(..\USER;..\FUNC_HAND
                    -LER;..\GUI_APP) DEBUG PRINT(.\OBJ\module.lst) TABS(2) OBJECT(.\OBJ\module.obj)

line level    source

   1          /*
   2           * @Author: xw.qu
   3           * @Date: 2023-08-31 09:22:42
   4           * @LastEditors: xw.qu
   5           * @LastEditTime: 2023-11-04 11:08:31
   6           * @FilePath: \Binaryd:\七寸屏\NEW_UI\PROJ_V1.0-20231102 - 13\C51\template\USER\module.c
   7           * @Description: relay module configuration
   8           *
   9           * Copyright (c) 2023 by xw.qu, All Rights Reserved.
  10           */
  11          #include "module.h"
  12          #include "Uart.h"
  13          #include "T5LLIB.h"
  14          #include "T5lOS8051.h"
  15          v_module_t g_var_module;
  16          #define DEVICE_NB 10
  17          #define DEVICE_INFOR_INDEX 14
  18          u16 xdata num4 = 4;
  19          unsigned char modfity_index = 0;
  20          unsigned char var_previous_page = 0;
  21          static unsigned char para_set_fun = 0;
  22          unsigned char channel_number = 0;
  23          unsigned short module_key_nb_bak = 0;
  24          unsigned char module_select_sta_bak = 0;
  25          unsigned short temp_adr = 0;
  26          unsigned short init_pwd = 8888; // default password
  27          module_t module = {
  28              {1},
  29              {2},
  30              {0},
  31              {0},
  32              {1},
  33              {4},
  34              {"房间1"}, // 普通模块
  35              {"通道1           通道2           通道3           通道4           通道5           通道6           通道7 
             -          通道8           通道9           通道10          通道11          通道12          通道13          通道14        
             -  通道15          通道16          "},
  36          };
  37          module_t auto_module = {
  38              {1},
  39              {2},
  40              {0},
  41              {0},
  42              {1},
  43              {4},
  44              {0}, // 普通模块
  45              {"通道1           通道2           通道3           通道4           通道5           通道6           通道7 
             -          通道8           通道9           通道10          通道11          通道12          通道13          通道14        
             -  通道15          通道16          "},
  46          };
  47          module_t st_module = {
  48              {1},
  49              {2},
  50              {0},
C51 COMPILER V9.60.0.0   MODULE                                                            11/04/2023 11:13:36 PAGE 2   

  51              {0},
  52              {1},
  53              {4},
  54              {"房间1"}, // 普通模块
  55              {"通道1           通道2           通道3           通道4           通道5           通道6           通道7 
             -          通道8           通道9           通道10          通道11          通道12          通道13          通道14        
             -  通道15          通道16          "},
  56          };
  57          module_t timing_module = {
  58              {0},
  59              {0},
  60              {0},
  61              {0},
  62              {0},
  63              {0},
  64              {"房间1"}, // 普通模块
  65              {"通道1           通道2           通道3           通道4           通道5           通道6           通道7 
             -          通道8           通道9           通道10          通道11          通道12          通道13          通道14        
             -  通道15          通道16          "},
  66          };
  67          module_t temp_module = {
  68              {0},
  69              {0},
  70              {0},
  71              {0},
  72              {0},
  73              {0},
  74              {"房间1"}, // 普通模块
  75              {"通道1           通道2           通道3           通道4           通道5           通道6           通道7 
             -          通道8           通道9           通道10          通道11          通道12          通道13          通道14        
             -  通道15          通道16          "},
  76          };
  77          unsigned char module_tab[10] = {
  78              1, 2, 3, 4, 5, 6, 7, 8, 9, 10
  79              //  {2},
  80              //  {0},
  81              //  {0},
  82              //  {1},
  83              //  {4},
  84              //  {"房间1"},         //普通模块
  85              //  {"通道1","通道2","通道3","通道4","通道5","通道6","通道7","通道8","通道9","通道10","通道11","通道12","
             -通道13","通道14","通道15","通道16"},
  86          
  87          };
  88          // bit key_flag = 0;
  89          unsigned short xdata key, num_return;
  90          unsigned short xdata channel = 0;
  91          unsigned short module_type = 0, module_type_bak = 0;
  92          unsigned short adr = 0;
  93          void timing_module_parameter_week_enable_channel_send(struct this_module *p, unsigned char channel, unsign
             -ed char state);
  94          void timing_module_parameter_solar_channel_send(struct this_module *p, unsigned char channel, unsigned cha
             -r state);
  95          void timing_module_parameter_time_frame_channel_send(struct this_module *p, unsigned char channel, unsigne
             -d char state);
  96          void timing_module_parameter_ongitude_latitude_send(struct this_module *p);
  97          void timing_module_parameter_time_send(struct this_module *p);
  98          unsigned char check_or_not_frame(unsigned short adr);
  99          // void (*timing_module_parameter_set_send)(struct   this_module* xdata p,unsigned char channel,unsigned c
             -har state);
 100          // void (*fun)(module_t* p,unsigned char channel,unsigned char state);
 101          
C51 COMPILER V9.60.0.0   MODULE                                                            11/04/2023 11:13:36 PAGE 3   

 102          // code  void (*p_fun_tab[5])( struct   this_module xdata * p,unsigned char xdata channel,unsigned char xd
             -ata state) =
 103          //{
 104          //  timing_module_parameter_ongitude_latitude_send,
 105          //  timing_module_parameter_time_send,
 106          //  timing_module_parameter_week_enable_channel_send,
 107          //  timing_module_parameter_solar_channel_send,
 108          //  timing_module_parameter_time_frame_channel_send,
 109          
 110          //};
 111          // unsigned char *p_module_name;
 112          unsigned char xdata module_default_name[17] = {
 113              "房间1"};
 114          unsigned char xdata module_no_name[17] = {
 115              ""};
 116          unsigned char xdata module_name_tab[6][13] = {
 117              "普通模块    ", // 普通模块
 118              "时控模块    ", // 时控模块
 119              "调光模块    ", // 调光模块
 120              "可控硅模块  ", // 可控硅模块
 121              "双层普通模块", // 双层普通模块
 122              "双层时控模块", // 双层时控模块
 123          
 124          };
 125          
 126          unsigned char default_module_channel_name[16][16] = {
 127              {"通道1"},
 128              {"通道2"},
 129              {"通道3"},
 130              {"通道4"},
 131              {"通道5"},
 132              {"通道6"},
 133              {"通道7"},
 134              {"通道8"},
 135              {"通道9"},
 136              {"通道10"},
 137              {"通道11"},
 138              {"通道12"},
 139              {"通道13"},
 140              {"通道14"},
 141              {"通道15"},
 142              {"通道16"},
 143          };
 144          
 145          // 获取键值
 146          void get_key_value(unsigned short adr, unsigned short *key_value)
 147          {
 148   1        read_dgusii_vp(adr, (unsigned char *)key_value, 1);
 149   1      }
 150          // 键值清0
 151          void clear_key_value(unsigned short adr, unsigned short *key_value)
 152          {
 153   1        unsigned short key_zero = 0;
 154   1        USER_PRINTF("<--0x%x  key_value is---%d\n", adr, *key_value);
 155   1        write_dgusii_vp(adr, (unsigned char *)&key_zero, 1);
 156   1        //  key_flag = 1;
 157   1      }
 158          // 触摸状态清0
 159          void clear_touch_sta(void)
 160          {
 161   1        unsigned char tab_zero[8] = {0};
 162   1        write_dgusii_vp(0x16, (unsigned char *)&tab_zero, 4);
C51 COMPILER V9.60.0.0   MODULE                                                            11/04/2023 11:13:36 PAGE 4   

 163   1        //  key_flag = 1;
 164   1      }
 165          // 查找数据是否存在
 166          unsigned char check_whether_data_exists(unsigned int adr_start, unsigned char index, unsigned char flash_b
             -lock)
 167          {
 168   1        unsigned char ch_data = 0;
 169   1        unsigned char tab_data[4] = {0};
 170   1        norflash_read(index * flash_block + adr_start, tab_data, 2);
 171   1        //  printf_tab(4,tab_data);
 172   1        if (0 == tab_data[0])
 173   1        {
 174   2          ch_data = BLANK;
 175   2          // USER_PRINTF("<--index %bd is blank \n", index);
 176   2        }
 177   1        else
 178   1          ch_data = FULL;
 179   1      
 180   1        return ch_data;
 181   1      }
 182          
 183          // 返回空白数据序号
 184          unsigned short find_index(unsigned int adr_start, unsigned char flash_size, unsigned short quantity)
 185          {
 186   1        unsigned short index = 0;
 187   1        for (index = 0; index < quantity; index++)
 188   1        {
 189   2          if (BLANK == check_whether_data_exists(adr_start, index, flash_size))
 190   2          {
 191   3            return index;
 192   3          }
 193   2        }
 194   1        return 0xff;
 195   1      }
 196          
 197          // 设置模块信息
 198          void set_module_information(module_t *p, unsigned char index, unsigned short module_type)
 199          {
 200   1        unsigned short temp = 0;
 201   1        //  p->data_sta = 1;
 202   1        //  unsigned char data_sta;
 203   1        //  unsigned char index;
 204   1        //  unsigned char reserve;
 205   1        //  unsigned char type;
 206   1        //  unsigned char adr;
 207   1        //  unsigned char channel_nb;
 208   1        //  unsigned char module_name[16];
 209   1        //  unsigned char channel_name[16][16];
 210   1        //  unsigned char index = 0 ;
 211   1        //  for(index = 0;index<MODULE_NUB_LIMIT;index++)
 212   1        //  {
 213   1        //    if( BLANK == check_whether_data_exists(index))
 214   1        //    {
 215   1        //      save_module_information(p,index);
 216   1        // memset(p,0,sizeof(module_t));
 217   1        p->index = index;
 218   1        read_dgusii_vp(0x2000, (unsigned char *)&temp, 1);
 219   1        p->adr = (unsigned char)temp;
 220   1        read_dgusii_vp(0x1002, (unsigned char *)&temp, 1);
 221   1        p->channel_nb = (unsigned char)temp;
 222   1        // USER_PRINTF("-->module_name is %s;\n",p->module_name);
 223   1        read_dgusii_vp(0x3000, (unsigned char *)&p->module_name, 8);
C51 COMPILER V9.60.0.0   MODULE                                                            11/04/2023 11:13:36 PAGE 5   

 224   1        // printf_tab(16,(unsigned char *)&p->module_name);
 225   1        // USER_PRINTF("-->module_name is %s;\n",p->module_name);
 226   1      
 227   1        // removeWhitespace(p->module_name);
 228   1        // USER_PRINTF("-->module_name is %s;\n",p->module_name);
 229   1        read_dgusii_vp(0x3008, (unsigned char *)&p->channel_name, 128);
 230   1        p->data_sta = FULL;
 231   1        p->type = module_type;
 232   1        //  USER_PRINTF("P->TYEP is %d\n",module_type);
 233   1        //      break;
 234   1        //    }
 235   1        //  }
 236   1      }
 237          // 显示模块信息
 238          void display_module_information(module_t *p, unsigned char index)
 239          {
 240   1        unsigned char mod_infom_tab[64] = {0};
 241   1        unsigned char module_name_1[13] = {0};
 242   1        //  USER_PRINTF("-->module type is %bd\n",p->type);
 243   1        if (p->type <= 2)
 244   1        {
 245   2          strncpy(module_name_1, &module_name_tab[p->type], 8);
 246   2        }
 247   1        else if (p->type == 3)
 248   1        {
 249   2          strncpy(module_name_1, &module_name_tab[p->type], 10);
 250   2        }
 251   1        else
 252   1        {
 253   2          strncpy(module_name_1, &module_name_tab[p->type], 12);
 254   2        }
 255   1        //  USER_PRINTF("-->module_name is %s;\n", p->module_name);
 256   1        strrpl(p->module_name, " ", "");
 257   1        // strrpl(p->module_name, "  ", "");
 258   1      
 259   1        // sprintf(mod_infom_tab, "类型:%s,模块:%.16s,地址:%bd,通道:%bd", module_name_1, p->module_name, p->adr, 
             -p->channel_nb);
 260   1        sprintf(mod_infom_tab, "类型:%s,地址:%bd,通道:%bd,模块:%s", module_name_1, p->adr, p->channel_nb, p->modu
             -le_name);
 261   1        //  USER_PRINTF("-->mod_infom_tab is %s\n", mod_infom_tab);
 262   1        //  USER_PRINTF("-->p->index %bd\n", p->index);
 263   1        write_dgusii_vp(0x3520 + index * 32, (unsigned char *)mod_infom_tab, 32);
 264   1      }
 265          // 是否存在重复地址
 266          //  unsigned char if_adr_repeat(unsigned char edit_sta,unsigned char adr,unsigned char *p)
 267          //  {
 268          //    switch (edit_sta)
 269          //    {
 270          //      case ADD:
 271          //      if(find_nub_index(p,adr))
 272          //      {
 273          //        USER_PRINTF("--> adr already exist\n!");
 274          //        USER_PRINTF("--> save module information fail!\n");
 275          //        return 1;
 276          //      }
 277          //      break;
 278          //      case MODIFY:
 279          //      if(find_nub_index(p,adr))
 280          //      {
 281          //        USER_PRINTF("--> adr already exist\n!");
 282          //        USER_PRINTF("--> save module information fail!\n");
 283          //        return 1;
C51 COMPILER V9.60.0.0   MODULE                                                            11/04/2023 11:13:36 PAGE 6   

 284          //      }
 285          //      break;
 286          //      default:
 287          //      break;
 288          //    }
 289          //    return 0;
 290          
 291          // }
 292          // 存储模块信息
 293          void save_module_information(module_t *p)
 294          {
 295   1        // unsigned short key_nb1 = 0;
 296   1        unsigned short key_nb2 = 0;
 297   1        //  static unsigned char temp_index = 0;
 298   1        // read_dgusii_vp(0x1009, (unsigned char *)&key_nb1, 1);
 299   1        // if (1 == key_nb1)//添加模块
 300   1        // {
 301   1        //  key_nb1 = 0;
 302   1        //  write_dgusii_vp(0x1009, (unsigned char *)&key_nb1, 1);
 303   1        //  USER_PRINTF("-->ctrl_mgmt_sta\n");
 304   1        //  modfity_index = find_index(0, MODULE_FLASH_SIZE, MODULE_NUB_LIMIT);
 305   1        //  if(OVERFLOW_SIZE == modfity_index)
 306   1        //  {
 307   1        //    USER_PRINTF("-->waring! too many module \n");
 308   1        //    pop_menu_key_ctrl(OVERFLOW_WARING_CODE);
 309   1        //    return;
 310   1        //  }
 311   1        //  pic_set(MODULE_ADD_PAGE);
 312   1        //  //    USER_PRINTF("<--get_blank_index -->%bd\n", modfity_index);
 313   1        //  write_dgusii_vp(0x3110, (unsigned char *)&module_name_tab[0], 6);
 314   1        //  write_dgusii_vp(0x3008, (unsigned char *)&default_module_channel_name, 256);
 315   1        //  write_dgusii_vp(0x3000, (unsigned char *)module_default_name, 8);
 316   1        //  write_dgus(0X1000, 4);
 317   1        // }
 318   1        sys_delay_about_ms(5);
 319   1        read_dgusii_vp(0x1006, (unsigned char *)&key_nb2, 1);
 320   1        // if (key_nb2)
 321   1        // {
 322   1        //  USER_PRINTF("-->key_value ---%d\n", key_nb2);
 323   1        // }
 324   1        if ((4 == key_nb2) || (6 == key_nb2) || (8 == key_nb2) || (10 == key_nb2) || (12 == key_nb2) || (14 == ke
             -y_nb2) || (16 == key_nb2) || (0x14 == key_nb2) || (0x24 == key_nb2))
 325   1        {
 326   2          key_nb2 = 0;
 327   2          sys_delay_about_ms(1);
 328   2          write_dgusii_vp(0x1006, (unsigned char *)&key_nb2, 1);
 329   2          printf_tab(20, &g_var_module.module_adr[0]);
 330   2          read_dgusii_vp(0x2000, (unsigned char *)&temp_adr, 1);
 331   2          sys_delay_about_ms(2);
 332   2          if (find_nub_index(&g_var_module.module_adr[0], temp_adr))
 333   2          {
 334   3            pop_menu_key_ctrl(0x1f);
 335   3            USER_PRINTF("--> adr already exist!\n");
 336   3            USER_PRINTF("--> save module information fail!\n");
 337   3            return;
 338   3          }
 339   2          set_module_information(p, modfity_index, (unsigned char)module_type_bak);
 340   2          //    USER_PRINTF("-->module_type_bak is %d\n",module_type_bak);
 341   2      
 342   2          add_arr_data(&g_var_module.module_adr[0], p->adr, modfity_index);
 343   2      
 344   2          norflash_write(modfity_index * MODULE_FLASH_SIZE, (unsigned char *)p, MODULE_FLASH_SIZE);
C51 COMPILER V9.60.0.0   MODULE                                                            11/04/2023 11:13:36 PAGE 7   

 345   2          write_dgusii_vp(0x3120 + 8 * modfity_index, (unsigned char *)p->module_name, 8);
 346   2          display_module_information(p, modfity_index);
 347   2          USER_PRINTF("-->save_module_information_ok\n");
 348   2          if (modfity_index >= 5)
 349   2          {
 350   3            pic_page = 88 + modfity_index / 5 - 1;
 351   3            pic_set(pic_page);
 352   3          }
 353   2          else
 354   2          {
 355   3            pic_page = 2;
 356   3            pic_set(pic_page);
 357   3          }
 358   2          module_type_bak = 0;
 359   2        }
 360   1        else if (0xff == key_nb2)
 361   1        {
 362   2          key_nb2 = 0;
 363   2          sys_delay_about_ms(1);
 364   2          write_dgusii_vp(0x1006, (unsigned char *)&key_nb2, 1);
 365   2          pic_set(pic_page);
 366   2          // if (modfity_index >= 5)
 367   2          // {
 368   2          //  pic_set(88 + modfity_index / 5 - 1);
 369   2          // }
 370   2          // else
 371   2          // {
 372   2          //  pic_set(2);
 373   2          // }
 374   2        }
 375   1      
 376   1        //  sys_delay_about_ms(10);//这个延时必须加,可以防止莫名其妙的错误
 377   1      }
 378          // 设置模块选中序号 touch_key_adr-0x110c; select_key_adr-0x1104
 379          void set_selected_sequence_number(unsigned short touch_key_adr, unsigned short select_key_adr, unsigned ch
             -ar page_nb)
 380          {
 381   1        unsigned short key_nb = 0;
 382   1        static unsigned char select_sta = 0;
 383   1        static unsigned char page = 0;
 384   1        unsigned char i = 0;
 385   1        get_key_value(touch_key_adr, &key_nb);
 386   1        if ((key_nb))
 387   1        {
 388   2          for (i = 0; i < page_nb; i++)
 389   2          {
 390   3            write_dgus(select_key_adr + i, 0);
 391   3          }
 392   2          if (page != ((key_nb - 1) / 8))
 393   2          {
 394   3            page = (key_nb - 1) / 8;
 395   3            select_sta = 0;
 396   3          }
 397   2          select_sta = select_sta == (key_nb - (page * 8)) ? ((select_sta > 0) ? 0 : (key_nb - (page * 8))) : (key
             -_nb - (page * 8));
 398   2          // USER_PRINTF("-->set_select_sta is--%bd\n", select_sta);
 399   2          write_dgus(select_key_adr + (key_nb - 1) / 8, select_sta);
 400   2          clear_key_value(touch_key_adr, &key_nb);
 401   2        }
 402   1      }
 403          /**
 404           * @brief 设置选择框
C51 COMPILER V9.60.0.0   MODULE                                                            11/04/2023 11:13:36 PAGE 8   

 405           * @param {unsigned short} touch_key_adr 按键地址
 406           * @param {unsigned short} select_key_adr 框地址
 407           * @param {unsigned char} nb 数量
 408           * @param {unsigned short} *p_key_nb_bak 按键值备份
 409           * @param {unsigned char} *p_select_sta  框选备份
 410           * @return {*}
 411           */
 412          void set_box_select(unsigned short touch_key_adr, unsigned short select_key_adr, unsigned char nb, unsigne
             -d short *p_key_nb_bak, unsigned char *p_select_sta)
 413          {
 414   1        unsigned short key_nb = 0;
 415   1        // static unsigned short key_nb_bak = 0;
 416   1        // static unsigned char select_sta = 0;
 417   1        unsigned char i = 0;
 418   1        get_key_value(touch_key_adr, &key_nb);
 419   1      
 420   1        if ((key_nb)) // 按键触发
 421   1        {
 422   2          for (i = 0; i < nb; i++)
 423   2          {
 424   3            if (i == key_nb - 1)
 425   3            {
 426   4              continue;
 427   4            }
 428   3            write_dgus(select_key_adr + i, 0); // 除了触发的框其他都写0
 429   3          }
 430   2          if (*p_key_nb_bak != key_nb)
 431   2          {
 432   3            *p_key_nb_bak = key_nb;
 433   3            *p_select_sta = 0;
 434   3          }
 435   2          // USER_PRINTF("-->set_select_sta before is--%bd\n", select_sta);
 436   2          *p_select_sta ^= 1;
 437   2          // USER_PRINTF("-->set_select_sta after is--%bd\n", select_sta);
 438   2          write_dgus(select_key_adr + (key_nb - 1), *p_select_sta);
 439   2          clear_key_value(touch_key_adr, &key_nb);
 440   2        }
 441   1      }
 442          
 443          // 获取模块选中序号 0x1104
 444          
 445          unsigned char get_box_select_number(unsigned short select_key_adr, unsigned char nb)
 446          {
 447   1        unsigned char i = 0;
 448   1        unsigned char seq_nb = 0;
 449   1        for (i = 0; i < nb; i++)
 450   1        {
 451   2          seq_nb = read_dgus(select_key_adr + i);
 452   2          if (seq_nb)
 453   2          {
 454   3            seq_nb = seq_nb + i;
 455   3            // USER_PRINTF("-->get_select_sta is--%bd\n", seq_nb);
 456   3            return (seq_nb);
 457   3          }
 458   2        }
 459   1        return 0;
 460   1      }
 461          unsigned char get_selected_sequence_number(unsigned short select_key_adr, unsigned char page)
 462          {
 463   1        unsigned char i = 0;
 464   1        unsigned char seq_nb = 0;
 465   1        for (i = 0; i < page; i++)
C51 COMPILER V9.60.0.0   MODULE                                                            11/04/2023 11:13:36 PAGE 9   

 466   1        {
 467   2          seq_nb = read_dgus(select_key_adr + i);
 468   2          if (seq_nb)
 469   2          {
 470   3            seq_nb = seq_nb + i * 8;
 471   3            // USER_PRINTF("-->get_select_sta is--%bd\n", seq_nb);
 472   3            return (seq_nb);
 473   3          }
 474   2        }
 475   1        return 0;
 476   1      }
 477          void delay_us(unsigned short t)
 478          {
 479   1        char i;
 480   1        while (t)
 481   1        {
 482   2          for (i = 0; i < 50; i++)
 483   2          {
 484   3            i = i;
 485   3          }
 486   2          t--;
 487   2        }
 488   1      }
 489          // 读所在页面值
 490          unsigned short read_pic(void)
 491          {
 492   1        unsigned short pic = 0;
 493   1        pic = read_dgus(0x0014);
 494   1        sys_delay_about_ms(2);
 495   1        return pic;
 496   1      }
 497          
 498          // 页面切换
 499          void pic_set(unsigned int pic) // pic为跳转到的页面
 500          {
 501   1        unsigned short run_num = 0;
 502   1        run_num = 0x5A01;
 503   1        write_dgusii_vp(0x0085, (unsigned char *)&pic, 1);
 504   1        write_dgusii_vp(0x0084, (unsigned char *)&run_num, 1);
 505   1        while (run_num >> 8) // 看高八位5A是否清零
 506   1        {
 507   2          read_dgusii_vp(0x0084, (unsigned char *)&run_num, 1);
 508   2          delay_us(3000); //**********
 509   2        }
 510   1      }
 511          // 设置通道数量
 512          void set_channel_nb(void)
 513          {
 514   1        read_dgusii_vp(0x1000, (unsigned char *)&channel, 1);
 515   1      
 516   1        //  USER_PRINTF("channel value ---- %d\n",channel);
 517   1        {
 518   2          switch (channel)
 519   2          {
 520   3          case 0:
 521   3            //        write_dgusii_vp(0x1002,(unsigned char *)&num4,1);
 522   3            //      display_icon();
 523   3            break;
 524   3          case 4:
 525   3            //        channel_bak = 0;
 526   3            write_dgusii_vp(0x1002, (unsigned char *)&channel, 1);
 527   3            //        write_dgus(17,54);
C51 COMPILER V9.60.0.0   MODULE                                                            11/04/2023 11:13:36 PAGE 10  

 528   3            //        channel_bak = channel;
 529   3            break;
 530   3          case 6:
 531   3            //        channel_bak = 0;
 532   3            write_dgusii_vp(0x1002, (unsigned char *)&channel, 1);
 533   3            //        write_dgus(17,54);
 534   3            //        channel_bak = channel;
 535   3            break;
 536   3          case 8:
 537   3            //        channel_bak = 1;
 538   3            write_dgusii_vp(0x1002, (unsigned char *)&channel, 1);
 539   3            //        write_dgus(17,55);
 540   3            //        channel_bak = channel;
 541   3            break;
 542   3          case 10:
 543   3            //        channel_bak = 1;
 544   3            write_dgusii_vp(0x1002, (unsigned char *)&channel, 1);
 545   3            //        write_dgus(17,55);
 546   3            //        channel_bak = channel;
 547   3            break;
 548   3          case 12:
 549   3            //        channel_bak = 2;
 550   3            write_dgusii_vp(0x1002, (unsigned char *)&channel, 1);
 551   3            //        write_dgusii_vp(0x1003,(unsigned char*)&channel_bak,1);
 552   3            //        channel_bak = channel;
 553   3            break;
 554   3          case 14:
 555   3            //        channel_bak = 2;
 556   3            write_dgusii_vp(0x1002, (unsigned char *)&channel, 1);
 557   3            //        write_dgusii_vp(0x1003,(unsigned char*)&channel_bak,1);
 558   3            //        channel_bak = channel;
 559   3            break;
 560   3          case 16:
 561   3            //        channel_bak = 3;
 562   3            write_dgusii_vp(0x1002, (unsigned char *)&channel, 1);
 563   3            //        write_dgus(17,53);
 564   3            //        channel_bak = channel;
 565   3            break;
 566   3          default:
 567   3            //        write_dgusii_vp(0x1000,(unsigned char*)&channel_bak,1);
 568   3            break;
 569   3          }
 570   2        }
 571   1      }
 572          
 573          // 设置模块类型
 574          void set_module_type(void)
 575          {
 576   1      
 577   1        //  data_t* p;
 578   1        //  static char i = 0;
 579   1        //    //void write_dgusii_vp(unsigned int addr,unsigned char *buf,unsigned int len)
 580   1        //  read_dgusii_vp(0x3010,(unsigned char *)&num_test,8);
 581   1        //  read_dgusii_vp(0x1000,(unsigned char *)&num_return,1);
 582   1      
 583   1        //  num_test = 0X03;
 584   1        //  static unsigned short module_type = 0;
 585   1        unsigned short default_channel = 4;
 586   1        //  USER_PRINTF("touch key value ---- %d\n",key);
 587   1        read_dgusii_vp(0x1001, (unsigned char *)&module_type, 1);
 588   1        // if (module_type < 0xff)
 589   1        //  USER_PRINTF("-->MODULE_TYPE = %d\n", module_type);
C51 COMPILER V9.60.0.0   MODULE                                                            11/04/2023 11:13:36 PAGE 11  

 590   1        switch (module_type)
 591   1        {
 592   2        case 0:
 593   2          module_type_bak = 0;
 594   2          write_dgusii_vp(0x3110, (unsigned char *)&module_name_tab[module_type_bak], 6);
 595   2      
 596   2          //      set_channel_nb();
 597   2          //      write_dgusii_vp(0x1000,(unsigned char *)&default_channel,1);
 598   2          module_type = 0xff;
 599   2          write_dgusii_vp(0x1001, (unsigned char *)&module_type, 1);
 600   2          // USER_PRINTF("-->module_type_bak = %d\n", module_type_bak);
 601   2          break;
 602   2        case 1:
 603   2          module_type_bak = 0;
 604   2          write_dgusii_vp(0x3110, (unsigned char *)&module_name_tab[module_type_bak], 6);
 605   2          //      set_channel_nb();
 606   2          write_dgusii_vp(0x1000, (unsigned char *)&default_channel, 1);
 607   2          module_type = 0xff;
 608   2          write_dgusii_vp(0x1001, (unsigned char *)&module_type, 1);
 609   2          // USER_PRINTF("-->module_type_bak = %d\n", module_type_bak);
 610   2          break;
 611   2        case 2:
 612   2          module_type_bak = 1;
 613   2          write_dgusii_vp(0x3110, (unsigned char *)&module_name_tab[module_type_bak], 6);
 614   2          //      set_channel_nb();
 615   2          write_dgusii_vp(0x1000, (unsigned char *)&default_channel, 1);
 616   2          module_type = 0xff;
 617   2          write_dgusii_vp(0x1001, (unsigned char *)&module_type, 1);
 618   2          // USER_PRINTF("-->module_type_bak = %d\n", module_type_bak);
 619   2          break;
 620   2      
 621   2        case 3:
 622   2          module_type_bak = 2;
 623   2          write_dgusii_vp(0x3110, (unsigned char *)&module_name_tab[module_type_bak], 6);
 624   2          write_dgusii_vp(0x1000, (unsigned char *)&default_channel, 1);
 625   2          module_type = 0xff;
 626   2          write_dgusii_vp(0x1001, (unsigned char *)&module_type, 1);
 627   2          //      write_dgusii_vp(0x1002,(unsigned char *)&num4,1);
 628   2          // USER_PRINTF("-->module_type_bak = %d\n", module_type_bak);
 629   2          break;
 630   2        case 4:
 631   2          module_type_bak = 3;
 632   2          write_dgusii_vp(0x3110, (unsigned char *)&module_name_tab[module_type_bak], 6);
 633   2          write_dgusii_vp(0x1000, (unsigned char *)&default_channel, 1);
 634   2          module_type = 0xff;
 635   2          write_dgusii_vp(0x1001, (unsigned char *)&module_type, 1);
 636   2          //      USER_PRINTF("MODULE_TYPE = %bd\n",module_type);
 637   2          //      write_dgusii_vp(0x1002,(unsigned char *)&num4,1);
 638   2          //      write_dgusii_vp(0x1000,(unsigned char *)&num,1);
 639   2      
 640   2          //      enable_touch_set(72,9,0);
 641   2          // USER_PRINTF("-->module_type_bak = %d\n", module_type_bak);
 642   2          break;
 643   2        case 5:
 644   2          module_type_bak = 4;
 645   2          write_dgusii_vp(0x3110, (unsigned char *)&module_name_tab[module_type_bak], 6);
 646   2          write_dgusii_vp(0x1000, (unsigned char *)&default_channel, 1);
 647   2          module_type = 0xff;
 648   2          write_dgusii_vp(0x1001, (unsigned char *)&module_type, 1);
 649   2          //      write_dgusii_vp(0x1002,(unsigned char *)&num4,1);
 650   2          // USER_PRINTF("-->module_type_bak = %d\n", module_type_bak);
 651   2          //    pic_set(84);
C51 COMPILER V9.60.0.0   MODULE                                                            11/04/2023 11:13:36 PAGE 12  

 652   2          break;
 653   2        case 6:
 654   2          module_type_bak = 5;
 655   2          write_dgusii_vp(0x3110, (unsigned char *)&module_name_tab[module_type_bak], 6);
 656   2          write_dgusii_vp(0x1000, (unsigned char *)&default_channel, 1);
 657   2          module_type = 0xff;
 658   2          write_dgusii_vp(0x1001, (unsigned char *)&module_type, 1);
 659   2          //      write_dgusii_vp(0x1002,(unsigned char *)&num4,1);
 660   2          // USER_PRINTF("-->module_type_bak = %d\n", module_type_bak);
 661   2      
 662   2          //    pic_set(84);
 663   2          break;
 664   2        default:
 665   2      
 666   2          set_channel_nb();
 667   2          module_type = 0xff;
 668   2          write_dgusii_vp(0x1001, (unsigned char *)&module_type, 1);
 669   2          //    module_type_bak = 0;
 670   2          //    USER_PRINTF("-->module_type_bak = %d\n", module_type_bak);
 671   2          //      USER_PRINTF("module_type_default_run\n");
 672   2          //      USER_PRINTF("module_type_bak = %d\n",module_type_bak);
 673   2          //      write_dgusii_vp(0x3010,&module_p[0],8);
 674   2          break;
 675   2        }
 676   1        //  return 1;
 677   1      }
 678          // D7=年(0-0x63) D6=月(0-0x0C) D5=日(0-0x1F) D4=星期（0-0x6） D3=小时(0-0x17) D2=分钟(0-0x3B) D1=秒(0-0x3B
             -) D0 未定义
 679          void read_sys_time(unsigned char *p)
 680          {
 681   1        read_dgusii_vp(0x10, p, 4);
 682   1      }
 683          // 设置时间前读取一下时间
 684          void read_dgus_time(void)
 685          {
 686   1        unsigned short key_nb = 0;
 687   1        unsigned char rtc_parm[8] = {0};
 688   1        //  read_dgusii_vp(0x0010,(u8*)rtcdata,4);  //写入DGUS变量空间
 689   1      
 690   1        //  read_dgusii_vp(0x1008,(unsigned char *)&key_nb,1);
 691   1        get_key_value(0x1008, &key_nb);
 692   1        if (5 == key_nb)
 693   1        {
 694   2          //    USER_PRINTF(" key_value --->%d\n", key_nb);
 695   2          read_sys_time(rtc_parm);
 696   2          //    read_dgusii_vp(0x10,rtc_parm,4);
 697   2          // 重新排序rtc_parm[3] = week
 698   2          rtc_parm[3] = rtc_parm[4];
 699   2          rtc_parm[4] = rtc_parm[5];
 700   2          rtc_parm[5] = rtc_parm[6];
 701   2          rtc_parm[6] = rtc_parm[7];
 702   2          rtc_parm[7] = 0;
 703   2          printf_tab(8, rtc_parm);
 704   2          //    key_nb = 0;
 705   2          USER_PRINTF("-->read_dgus_time\n");
 706   2          read_dgus(0x10);
 707   2          //    write_dgusii_vp(0x1008,(unsigned char *)&key_nb,1);
 708   2          clear_key_value(0x1008, &key_nb);
 709   2          write_dgusii_vp(0x9d, rtc_parm, 4);
 710   2        }
 711   1      }
 712          /**
C51 COMPILER V9.60.0.0   MODULE                                                            11/04/2023 11:13:36 PAGE 13  

 713           * @brief 切换继电器模块显示界面
 714           * @param {module_t} *p模块指针
 715           * @param {unsigned char} relay_page继电器页面
 716           * @param {unsigned char} time_relay_page时控继电器页面
 717           * @param {unsigned char} *p_var_page记录当前页面
 718           * @return {*}
 719           */
 720          void relay_interface_trigger(module_t *p, unsigned char relay_page, unsigned char time_relay_page, unsigne
             -d char *p_var_page)
 721          {
 722   1        if ((DOUBLE_RELAY_MODULE == p->type) || (SINGLE_RELAY_MODULE == p->type))
 723   1        {
 724   2          pic_set(relay_page);
 725   2          *p_var_page = relay_page;
 726   2        }
 727   1        else
 728   1        {
 729   2          pic_set(time_relay_page);
 730   2          *p_var_page = time_relay_page;
 731   2        }
 732   1      }
 733          // 显示继电器模块界面
 734          void display_relay_interface(module_t *p)
 735          {
 736   1        write_dgus(0x4088, p->adr);
 737   1        //      write_dgusii_vp(0x4088,(unsigned char *)&p->adr,1);
 738   1        write_dgusii_vp(0x4000, (unsigned char *)&p->module_name, 8);
 739   1        write_dgusii_vp(0x4008, (unsigned char *)&p->channel_name, 8 * 16);
 740   1        switch (p->channel_nb)
 741   1        {
 742   2        case 4:
 743   2          relay_interface_trigger(p, 38, 31, &var_previous_page);
 744   2          break;
 745   2        case 6:
 746   2          relay_interface_trigger(p, 39, 32, &var_previous_page);
 747   2          break;
 748   2        case 8:
 749   2          relay_interface_trigger(p, 40, 33, &var_previous_page);
 750   2      
 751   2          break;
 752   2        case 10:
 753   2          relay_interface_trigger(p, 41, 34, &var_previous_page);
 754   2          break;
 755   2        case 12:
 756   2          relay_interface_trigger(p, 42, 35, &var_previous_page);
 757   2          break;
 758   2        case 14:
 759   2          relay_interface_trigger(p, 43, 36, &var_previous_page);
 760   2          break;
 761   2        case 16:
 762   2          relay_interface_trigger(p, 44, 37, &var_previous_page);
 763   2          break;
 764   2        default:
 765   2          break;
 766   2        }
 767   1      }
 768          // 显示调光模块界面
 769          void display_dim_interface(module_t *p)
 770          {
 771   1        write_dgus(0x4088, p->adr);
 772   1        //  write_dgusii_vp(0x4088,(unsigned char *)&p->adr,1);
 773   1        write_dgusii_vp(0x4000, (unsigned char *)&p->module_name, 8);
C51 COMPILER V9.60.0.0   MODULE                                                            11/04/2023 11:13:36 PAGE 14  

 774   1        write_dgusii_vp(0x4008, (unsigned char *)&p->channel_name, 8 * 16);
 775   1        switch (p->type)
 776   1        {
 777   2        case VOL_DIM_MODULE: // 普通调光
 778   2          pic_set(DIM_CTRL_PAGE);
 779   2          break;
 780   2        case SCR_DIM_MODULE: // 可控硅调光
 781   2          pic_set(SCR_CTRL_PAGE);
 782   2          break;
 783   2        default:
 784   2          break;
 785   2        }
 786   1      }
 787          /**
 788           * @brief 返回之前页面
 789           * @return {*}
 790           */
 791          void return_to_previous_page(void)
 792          {
 793   1        pic_set(var_previous_page);
 794   1      }
 795          /**
 796           * @brief 发送读取时间指令
 797           * @param {module_t} *p
 798           * @return {*}
 799           */
 800          void read_timing_module_parameter(module_t *p)
 801          {
 802   1        pack_data_send(&user_modbus, p->adr, MD_RD_HR, 35, 146);
 803   1      }
 804          /**
 805           * @brief 读取时间段设定
 806           * @param {module_t} *p
 807           * @return {*}
 808           */
 809          void read_timing_module_set_parameter(module_t *p)
 810          {
 811   1        unsigned short key_nb = 0;
 812   1        get_key_value(0x10dd, &key_nb);
 813   1        if (key_nb)
 814   1        {
 815   2          
 816   2          // USER_PRINTF("-->channel number is %bd\n", channel_number);
 817   2          if (0x12 != key_nb)
 818   2          {
 819   3            channel_number = key_nb;
 820   3            pack_data_send(&user_modbus, p->adr, MD_RD_HR, 35, 200); // 从35开始读200个
 821   3            g_var_module.read_time_set_para_flag = 1;
 822   3          }
 823   2      
 824   2          clear_key_value(0x10dd, &key_nb);
 825   2        }
 826   1      }
 827          // 显示模块假日参数
 828          void display_week_parameter(unsigned short week_enable_adr, unsigned char week_enable)
 829          {
 830   1        unsigned char i = 0;
 831   1        static unsigned char week_enable_bak = 0;
 832   1        if (week_enable_bak != week_enable)
 833   1        {
 834   2          week_enable_bak = week_enable;
 835   2          USER_PRINTF("-->week enable is %bd\n", week_enable);
C51 COMPILER V9.60.0.0   MODULE                                                            11/04/2023 11:13:36 PAGE 15  

 836   2          for (i = 0; i < 7; i++)
 837   2          {
 838   3            write_dgus(week_enable_adr + i, (week_enable >> i) & 0x01);
 839   3          }
 840   2        }
 841   1      }
 842          // 显示模块光照度参数
 843          void display_solar_parameter(unsigned short solar_adr, unsigned short solar_en_adr, unsigned char solar_en
             -able, unsigned char solar_up, unsigned char solar_down)
 844          {
 845   1        static unsigned char solar_down_bak = 15, solar_up_bak = 25, solar_en_bak = 0;
 846   1        if (solar_en_bak != solar_enable)
 847   1        {
 848   2          solar_en_bak = solar_enable;
 849   2          write_dgus(solar_en_adr, solar_enable);
 850   2        }
 851   1        if (solar_up_bak != solar_up)
 852   1        {
 853   2          solar_up_bak = solar_up;
 854   2          write_dgus(solar_adr + 1, solar_up);
 855   2        }
 856   1        if (solar_down_bak != solar_down)
 857   1        {
 858   2          solar_down_bak = solar_down;
 859   2          write_dgus(solar_adr, solar_down);
 860   2        }
 861   1      }
 862          
 863          // 显示模块时段参数
 864          void display_time_frame_parameter(unsigned short time_frame_adr, unsigned char *p_data)
 865          {
 866   1        static unsigned char time_frame_bak[16] = {18, 30, 6, 30, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
 867   1        unsigned char i = 0;
 868   1        for (i = 0; i < 16; i++)
 869   1        {
 870   2          if (time_frame_bak[i] != p_data[i])
 871   2          {
 872   3            time_frame_bak[i] = p_data[i];
 873   3            write_dgus(time_frame_adr + i, p_data[i]);
 874   3          }
 875   2        }
 876   1      }
 877          // 显示模块定时参数
 878          void display_timing_module_parameter(module_t *p, unsigned char channel)
 879          {
 880   1        unsigned short week_enable_adr = 0;
 881   1        unsigned char week_enable = 0;
 882   1        unsigned short solar_adr = 0;
 883   1        unsigned short solar_en_adr = 0;
 884   1        unsigned char solar_enable = 0;
 885   1        unsigned char solar_up = 0;
 886   1        unsigned char solar_down = 0;
 887   1        unsigned short time_frame_adr = 0;
 888   1        unsigned char p_data[17] = {0};
 889   1        if (SINGLE_TIME_PARA_SET_PAGE != read_pic())
 890   1          return;
 891   1        // USER_PRINTF("-->display_timing_module_parameter_page\n");
 892   1        if ((g_var_module.read_time_set_para_flag == 1) && (3 == mbh_getRecHookState()))
 893   1        {
 894   2          printf_tab(80,(unsigned char *)(HR+49));
 895   2          g_var_module.read_time_set_para_flag = 0;
 896   2          mbh_clearRecHookState();
C51 COMPILER V9.60.0.0   MODULE                                                            11/04/2023 11:13:36 PAGE 16  

 897   2          USER_PRINTF("-->read_time_para_successfully!\n");
 898   2          if ((DOUBLE_TIME_RELAY_MODULE == p->type) && (mbHost.errTimes < MBH_ERR_MAX_TIMES))
 899   2          {
 900   3            USER_PRINTF("-->double!\n");
 901   3            solar_enable = HR[200 + channel] >> 15 & 0x01;
 902   3            solar_up = HR[200 + channel] >> 8 & 0x7f;
 903   3            solar_down = HR[200 + channel] & 0xff;
 904   3            memcpy(p_data, (unsigned char *)(HR + 53 + (channel - 1) * 8), 16);
 905   3          }
 906   2          else if ((SINGLE_TIME_RELAY_MODULE == p->type) && (mbHost.errTimes < MBH_ERR_MAX_TIMES))
 907   2          {
 908   3            USER_PRINTF("-->single!\n");
 909   3            // USER_PRINTF("-->current channel is %bd!\n",channel);
 910   3            solar_enable = (HR[160 + channel] >> 15) & 0x01;
 911   3            solar_up = (HR[160 + channel] >> 8) & 0x7f;
 912   3            solar_down = HR[160 + channel] & 0xff;
 913   3            USER_PRINTF("-->current solar_up is %bd!\n",solar_up);
 914   3            USER_PRINTF("-->current solar_down is %bd!\n",solar_down);
 915   3            USER_PRINTF("-->current time_frame is %d!\n",HR[49]);
 916   3            memcpy(p_data, (unsigned char *)(HR + 49 + (channel - 1) * 8), 16);
 917   3          }
 918   2          else
 919   2          {
 920   3          }
 921   2          week_enable = ~HR[34 + channel];
 922   2          week_enable_adr = 0x10de;
 923   2          solar_en_adr = 0x10ed;
 924   2          solar_adr = 0x201d;
 925   2          time_frame_adr = 0x201f;
 926   2          write_dgus(0x201c, channel);
 927   2          //  USER_PRINTF("-->solar_enable is %bd\n",solar_enable);
 928   2          //  USER_PRINTF("-->solar_up is %bd\n",solar_up);
 929   2          //  USER_PRINTF("-->solar_down is %bd\n",solar_down);
 930   2          //  printf_tab(16,p_data);
 931   2          //  USER_PRINTF("-->solar_enable is %bd\n",solar_enable);
 932   2          display_week_parameter(week_enable_adr, week_enable);
 933   2          display_solar_parameter(solar_adr, solar_en_adr, solar_enable, solar_up, solar_down);
 934   2          display_time_frame_parameter(time_frame_adr, p_data);
 935   2        }
 936   1      }
 937          // 通道设置
 938          unsigned short get_channel_set(struct this_module *p, unsigned char channel, unsigned char state)
 939          {
 940   1        unsigned short channel_enable = 0;
 941   1        switch (state)
 942   1        {
 943   2        case SINGLE_CHANNEL_STATE:
 944   2        case BATCH_CHANNEL_STATE:
 945   2          if ((DOUBLE_TIME_RELAY_MODULE == p->type))
 946   2          {
 947   3            channel_enable = (1 << channel) & 0xffff;
 948   3          }
 949   2          else
 950   2          {
 951   3            channel_enable = ((1 << (channel + 3)) | 0X08) & 0xffff;
 952   3          }
 953   2          break;
 954   2        case SINGLE_CHANNELS_STATE:
 955   2        case BATCH_CHANNELS_STATE:
 956   2          channel_enable = 0xffff;
 957   2          break;
 958   2        }
C51 COMPILER V9.60.0.0   MODULE                                                            11/04/2023 11:13:36 PAGE 17  

 959   1        return channel_enable;
 960   1      }
 961          // 假日设置
 962          void timing_module_parameter_week_enable_channel_send(struct this_module *p, unsigned char channel, unsign
             -ed char state)
 963          {
 964   1        unsigned char week_adr_start = 0;
 965   1        unsigned char week_adr_end = 0;
 966   1        unsigned char data_len = 0;
 967   1        unsigned char week_enable = 0, i = 0;
 968   1        switch (state)
 969   1        {
 970   2        case SINGLE_CHANNEL_STATE:
 971   2          week_enable = (~get_timing_week_enable(0x10DE)) & 0xffff;
 972   2          break;
 973   2        case SINGLE_CHANNELS_STATE:
 974   2          week_enable = (~get_timing_week_enable(0x10e6)) & 0xffff;
 975   2          break;
 976   2        case BATCH_CHANNEL_STATE:
 977   2        case BATCH_CHANNELS_STATE:
 978   2          week_enable = (~get_timing_week_enable(0x1b05)) & 0xffff;
 979   2          break;
 980   2        default:
 981   2          break;
 982   2        }
 983   1        if ((DOUBLE_TIME_RELAY_MODULE == p->type))
 984   1        {
 985   2          week_adr_start = 34;
 986   2          data_len = 18;
 987   2          week_adr_end = 51;
 988   2        }
 989   1        else
 990   1        {
 991   2          week_adr_start = 34;
 992   2          data_len = 14;
 993   2          week_adr_end = 47;
 994   2        }
 995   1      
 996   1        // USER_PRINTF("-->channel_enable is %x\n", get_channel_set(p, channel, state));
 997   1        // USER_PRINTF("-->week_enable is %bx\n", week_enable);
 998   1        set_master_send_hr(master_send_hr, week_adr_start, get_channel_set(p, channel, state));
 999   1        for (i = 0; i < p->channel_nb; i++)
1000   1        {
1001   2          set_master_send_hr(master_send_hr, week_adr_start + 1 + i, week_enable);
1002   2        }
1003   1        set_master_send_hr(master_send_hr, week_adr_end, ENTERPRISE);
1004   1        pack_data_send(&user_modbus, p->adr, MD_FR_MHR, week_adr_start, data_len);
1005   1      }
1006          // 光照设置
1007          void timing_module_parameter_solar_channel_send(struct this_module *p, unsigned char channel, unsigned cha
             -r state)
1008          {
1009   1        unsigned char solar_adr_start = 0;
1010   1        unsigned char solar_adr_end = 0;
1011   1        unsigned char data_len = 0;
1012   1        //  unsigned short channel_enable = 0;
1013   1        unsigned char solar_enable = 0, i = 0;
1014   1        unsigned char solar_up = 0, solar_down = 0;
1015   1        unsigned short solar_parameter = 0;
1016   1        switch (state)
1017   1        {
1018   2        case SINGLE_CHANNEL_STATE:
C51 COMPILER V9.60.0.0   MODULE                                                            11/04/2023 11:13:36 PAGE 18  

1019   2          solar_enable = read_dgus(0x10ed);
1020   2          solar_down = read_dgus(0x201d);
1021   2          solar_up = read_dgus(0x201e);
1022   2      
1023   2          break;
1024   2        case SINGLE_CHANNELS_STATE:
1025   2          //    channel_enable = 0xffff;
1026   2          solar_enable = read_dgus(0x10ee);
1027   2          solar_down = read_dgus(0x202f);
1028   2          solar_up = read_dgus(0x2030);
1029   2          break;
1030   2        case BATCH_CHANNEL_STATE:
1031   2        case BATCH_CHANNELS_STATE:
1032   2          solar_enable = read_dgus(0x1B20);
1033   2          solar_down = read_dgus(0x1B0D);
1034   2          solar_up = read_dgus(0x1B0E);
1035   2          break;
1036   2        default:
1037   2          break;
1038   2        }
1039   1        if ((DOUBLE_TIME_RELAY_MODULE == p->type))
1040   1        {
1041   2          solar_adr_start = 200;
1042   2          data_len = 18;
1043   2          solar_adr_end = 217;
1044   2        }
1045   1        else
1046   1        {
1047   2          solar_adr_start = 160;
1048   2          data_len = 14;
1049   2          solar_adr_end = 173;
1050   2        }
1051   1      
1052   1        solar_parameter = solar_enable << 15 | solar_up << 8 | solar_down;
1053   1        set_master_send_hr(master_send_hr, solar_adr_start, get_channel_set(p, channel, state));
1054   1        for (i = 0; i < p->channel_nb; i++)
1055   1        {
1056   2          set_master_send_hr(master_send_hr, solar_adr_start + 1 + i, solar_parameter);
1057   2        }
1058   1        set_master_send_hr(master_send_hr, solar_adr_end, ENTERPRISE);
1059   1        pack_data_send(&user_modbus, p->adr, MD_FR_MHR, solar_adr_start, data_len);
1060   1      }
1061          // 时段设置
1062          void timing_module_parameter_time_frame_channel_send(struct this_module *p, unsigned char channel, unsigne
             -d char state)
1063          {
1064   1        unsigned char time_frame_adr_start = 0;
1065   1        unsigned char time_frame_adr_end = 0;
1066   1        unsigned char data_len = 0;
1067   1        unsigned short time_frame_set_adr = 0;
1068   1        //  unsigned short channel_enable = 0;
1069   1        unsigned char i = 0;
1070   1        unsigned short time_frame_parameter[8] = 0;
1071   1        switch (state)
1072   1        {
1073   2        case SINGLE_CHANNEL_STATE:
1074   2          time_frame_set_adr = 0x201f;
1075   2          //    time_frame_parameter[0] = read_dgus(0x201f) << 8 | read_dgus(0x2020);
1076   2          //    time_frame_parameter[1] = read_dgus(0x2021) << 8 | read_dgus(0x2022);
1077   2          //    time_frame_parameter[2] = read_dgus(0x2023) << 8 | read_dgus(0x2024);
1078   2          //    time_frame_parameter[3] = read_dgus(0x2025) << 8 | read_dgus(0x2026);
1079   2          //    time_frame_parameter[4] = read_dgus(0x2027) << 8 | read_dgus(0x2028);
C51 COMPILER V9.60.0.0   MODULE                                                            11/04/2023 11:13:36 PAGE 19  

1080   2          //    time_frame_parameter[5] = read_dgus(0x2029) << 8 | read_dgus(0x202a);
1081   2          //    time_frame_parameter[6] = read_dgus(0x202b) << 8 | read_dgus(0x202c);
1082   2          //    time_frame_parameter[7] = read_dgus(0x202d) << 8 | read_dgus(0x202e);
1083   2      
1084   2          break;
1085   2        case SINGLE_CHANNELS_STATE:
1086   2          time_frame_set_adr = 0x2031;
1087   2          //    time_frame_parameter[0] = read_dgus(0x2031) << 8 | read_dgus(0x2032);
1088   2          //    time_frame_parameter[1] = read_dgus(0x2033) << 8 | read_dgus(0x2034);
1089   2          //    time_frame_parameter[2] = read_dgus(0x2035) << 8 | read_dgus(0x2036);
1090   2          //    time_frame_parameter[3] = read_dgus(0x2037) << 8 | read_dgus(0x2038);
1091   2          //    time_frame_parameter[4] = read_dgus(0x2039) << 8 | read_dgus(0x203a);
1092   2          //    time_frame_parameter[5] = read_dgus(0x203b) << 8 | read_dgus(0x203c);
1093   2          //    time_frame_parameter[6] = read_dgus(0x203d) << 8 | read_dgus(0x203e);
1094   2          //    time_frame_parameter[7] = read_dgus(0x203f) << 8 | read_dgus(0x2040);
1095   2          break;
1096   2        case BATCH_CHANNEL_STATE:
1097   2        case BATCH_CHANNELS_STATE:
1098   2          time_frame_set_adr = 0X1B10;
1099   2      
1100   2          break;
1101   2        default:
1102   2          break;
1103   2        }
1104   1        time_frame_parameter[0] = read_dgus(time_frame_set_adr++) << 8 | read_dgus(time_frame_set_adr++);
1105   1        time_frame_parameter[1] = read_dgus(time_frame_set_adr++) << 8 | read_dgus(time_frame_set_adr++);
1106   1        time_frame_parameter[2] = read_dgus(time_frame_set_adr++) << 8 | read_dgus(time_frame_set_adr++);
1107   1        time_frame_parameter[3] = read_dgus(time_frame_set_adr++) << 8 | read_dgus(time_frame_set_adr++);
1108   1        time_frame_parameter[4] = read_dgus(time_frame_set_adr++) << 8 | read_dgus(time_frame_set_adr++);
1109   1        time_frame_parameter[5] = read_dgus(time_frame_set_adr++) << 8 | read_dgus(time_frame_set_adr++);
1110   1        time_frame_parameter[6] = read_dgus(time_frame_set_adr++) << 8 | read_dgus(time_frame_set_adr++);
1111   1        time_frame_parameter[7] = read_dgus(time_frame_set_adr++) << 8 | read_dgus(time_frame_set_adr++);
1112   1        if ((DOUBLE_TIME_RELAY_MODULE == p->type))
1113   1        {
1114   2          time_frame_adr_start = 52;
1115   2          data_len = 130;
1116   2          time_frame_adr_end = 181;
1117   2        }
1118   1        else
1119   1        {
1120   2          time_frame_adr_start = 48;
1121   2          data_len = 98;
1122   2          time_frame_adr_end = 145;
1123   2        }
1124   1        set_master_send_hr(master_send_hr, time_frame_adr_start, get_channel_set(p, channel, state));
1125   1        // USER_PRINTF("-->p->channel_nb is %bd\n", p->channel_nb);
1126   1        for (i = 0; i < p->channel_nb; i++)
1127   1        {
1128   2          set_master_send_hr(master_send_hr, time_frame_adr_start + 1 + i * 8, time_frame_parameter[0]);
1129   2          set_master_send_hr(master_send_hr, time_frame_adr_start + 2 + i * 8, time_frame_parameter[1]);
1130   2          set_master_send_hr(master_send_hr, time_frame_adr_start + 3 + i * 8, time_frame_parameter[2]);
1131   2          set_master_send_hr(master_send_hr, time_frame_adr_start + 4 + i * 8, time_frame_parameter[3]);
1132   2          set_master_send_hr(master_send_hr, time_frame_adr_start + 5 + i * 8, time_frame_parameter[4]);
1133   2          set_master_send_hr(master_send_hr, time_frame_adr_start + 6 + i * 8, time_frame_parameter[5]);
1134   2          set_master_send_hr(master_send_hr, time_frame_adr_start + 7 + i * 8, time_frame_parameter[6]);
1135   2          set_master_send_hr(master_send_hr, time_frame_adr_start + 8 + i * 8, time_frame_parameter[7]);
1136   2        }
1137   1        set_master_send_hr(master_send_hr, time_frame_adr_end, ENTERPRISE);
1138   1        pack_data_send(&user_modbus, p->adr, MD_FR_MHR, time_frame_adr_start, data_len);
1139   1      }
1140          // 二选一
1141          unsigned char select_either_or_single(unsigned short key_adr, unsigned short adr1, unsigned short adr2)
C51 COMPILER V9.60.0.0   MODULE                                                            11/04/2023 11:13:36 PAGE 20  

1142          {
1143   1        unsigned short key_nb = 0;
1144   1        get_key_value(key_adr, &key_nb);
1145   1        if (key_nb)
1146   1        {
1147   2          switch (key_nb)
1148   2          {
1149   3          case 1:
1150   3            if ((1 == read_dgus(adr1)))
1151   3            {
1152   4              write_dgus(adr1, 0);
1153   4              write_dgus(adr2, 1);
1154   4            }
1155   3            else if (0 == read_dgus(adr1))
1156   3            {
1157   4              write_dgus(adr1, 1);
1158   4              write_dgus(adr2, 0);
1159   4            }
1160   3            break;
1161   3          case 2:
1162   3            if ((1 == read_dgus(adr2)))
1163   3            {
1164   4              write_dgus(adr1, 1);
1165   4              write_dgus(adr2, 0);
1166   4            }
1167   3            else if (0 == read_dgus(adr2))
1168   3            {
1169   4              write_dgus(adr1, 0);
1170   4              write_dgus(adr2, 1);
1171   4            }
1172   3            break;
1173   3          default:
1174   3            break;
1175   3          }
1176   2          clear_key_value(key_adr, &key_nb);
1177   2          return 1;
1178   2        }
1179   1        return 0;
1180   1      }
1181          // 二选一选择框控制
1182          void select_either_or_all(void)
1183          {
1184   1        select_either_or_single(0x1117, 0x110d, 0x110e);
1185   1        select_either_or_single(0x1118, 0x110f, 0x1110);
1186   1        select_either_or_single(0x1119, 0x1111, 0x1112);
1187   1        select_either_or_single(0x111a, 0x1113, 0x1114);
1188   1        select_either_or_single(0x111b, 0x1115, 0x1116);
1189   1      }
1190          // 经纬度设置
1191          void timing_module_parameter_ongitude_latitude_send(struct this_module *p)
1192          {
1193   1      
1194   1        set_master_send_hr(master_send_hr, 23, 0X88 << 8 | read_dgus(0x1111) << 7 | read_dgus(0x1110) << 6 | read
             -_dgus(0x110E) << 4 | read_dgus(0x2041));
1195   1        set_master_send_hr(master_send_hr, 24, read_dgus(0x2042)); // 经度L
1196   1        set_master_send_hr(master_send_hr, 25, read_dgus(0x2043)); // 经度H
1197   1        set_master_send_hr(master_send_hr, 26, read_dgus(0x2044)); // 纬度L
1198   1        set_master_send_hr(master_send_hr, 27, read_dgus(0x2045)); // 纬度H
1199   1        set_master_send_hr(master_send_hr, 28, ENTERPRISE);
1200   1        // 日落加减1 偏移时间7高八  日出加减1 偏移时间7低八
1201   1        set_master_send_hr(master_send_hr, 29, read_dgus(0x1701) << 15 | read_dgus(0x2047) << 8 | read_dgus(0x170
             -0) << 7 | read_dgus(0x2046));
C51 COMPILER V9.60.0.0   MODULE                                                            11/04/2023 11:13:36 PAGE 21  

1202   1        // 日出日落通道使能位
1203   1        set_master_send_hr(master_send_hr, 30, read_dgus(0x10FF) << 15 | read_dgus(0x10FE) << 14 | read_dgus(0x10
             -FD) << 13 | read_dgus(0x10FC) << 12 | read_dgus(0x10FB) << 11 | read_dgus(0x10FA) << 10 | read_dgus(0x10F9) << 9 | read_
             -dgus(0x10F8) << 8 | read_dgus(0x10F7) << 7 | read_dgus(0x10F6) << 6 | read_dgus(0x10F5) << 5 | read_dgus(0x10F4) << 4 | 
             -read_dgus(0x10F3) << 3 | read_dgus(0x10F2) << 2 | read_dgus(0x10F1) << 1 | read_dgus(0x10F0));
1204   1      
1205   1        pack_data_send(&user_modbus, p->adr, MD_FR_MHR, 23, 8);
1206   1      }
1207          // 时间设置
1208          void timing_module_parameter_time_send(struct this_module *p)
1209          {
1210   1        set_master_send_hr(master_send_hr, 241, 0x88);
1211   1        set_master_send_hr(master_send_hr, 242, read_dgus(0x2048));
1212   1        set_master_send_hr(master_send_hr, 243, read_dgus(0x2049));
1213   1        set_master_send_hr(master_send_hr, 244, read_dgus(0x204a));
1214   1        set_master_send_hr(master_send_hr, 245, read_dgus(0x204b));
1215   1        set_master_send_hr(master_send_hr, 246, read_dgus(0x204c));
1216   1        set_master_send_hr(master_send_hr, 247, read_dgus(0x204d));
1217   1        set_master_send_hr(master_send_hr, 248, read_dgus(0x204e));
1218   1        set_master_send_hr(master_send_hr, 249, ENTERPRISE);
1219   1        // USER_PRINTF("-->p->adr is %bd\n", p->adr);
1220   1        pack_data_send(&user_modbus, p->adr, MD_FR_MHR, 241, 9);
1221   1      }
1222          void timing_module_parameter_ctrl(unsigned char fun, struct this_module *p, unsigned char channel)
1223          {
1224   1        unsigned short key_nb = 0;
1225   1        get_key_value(CONFIRM_POP_VALUE_ADR, &key_nb);
1226   1        if (1 == key_nb)
1227   1        {
1228   2          switch (fun)
1229   2          {
1230   3          case 1:
1231   3            timing_module_parameter_week_enable_channel_send(p, channel, SINGLE_CHANNEL_STATE);
1232   3            break;
1233   3          case 2:
1234   3            timing_module_parameter_solar_channel_send(p, channel, SINGLE_CHANNEL_STATE);
1235   3            break;
1236   3          case 3:
1237   3            timing_module_parameter_time_frame_channel_send(p, channel, SINGLE_CHANNEL_STATE);
1238   3            break;
1239   3          case 0xa:
1240   3            timing_module_parameter_ongitude_latitude_send(p);
1241   3            break;
1242   3          case 0xb:
1243   3            timing_module_parameter_time_send(p);
1244   3            break;
1245   3          case 0x11:
1246   3            timing_module_parameter_week_enable_channel_send(p, channel, SINGLE_CHANNELS_STATE);
1247   3            break;
1248   3          case 0x12:
1249   3            timing_module_parameter_solar_channel_send(p, channel, SINGLE_CHANNELS_STATE);
1250   3            break;
1251   3          case 0x13:
1252   3            timing_module_parameter_time_frame_channel_send(p, channel, SINGLE_CHANNELS_STATE);
1253   3            break;
1254   3          default:
1255   3            break;
1256   3          }
1257   2          clear_key_value(CONFIRM_POP_VALUE_ADR, &key_nb);
1258   2        }
1259   1      }
1260          // 时控 参数发送控制
C51 COMPILER V9.60.0.0   MODULE                                                            11/04/2023 11:13:36 PAGE 22  

1261          void timing_module_parameter_key_ctrl(struct this_module *p, unsigned char channel)
1262          {
1263   1        unsigned short key_nb = 0;
1264   1        get_key_value(0x10E5, &key_nb);
1265   1        if (key_nb)
1266   1        {
1267   2          para_set_fun = key_nb;
1268   2          switch (key_nb)
1269   2          {
1270   3          case 4:
1271   3          case 0x14:
1272   3            return_to_previous_page();
1273   3            break;
1274   3          default:
1275   3            break;
1276   3          }
1277   2          pop_menu_key_ctrl(CONFIRM_POP_KEY_ADR);
1278   2          clear_key_value(0x10E5, &key_nb);
1279   2        }
1280   1        timing_module_parameter_ctrl(para_set_fun, p, channel);
1281   1      }
1282          unsigned short led_sta[16] = {0};
1283          // 清空led状态
1284          void clear_led_sta(unsigned short *p)
1285          {
1286   1        unsigned char i = 0;
1287   1        for (i = 0; i < 16; i++)
1288   1        {
1289   2          *(p + i) = 0;
1290   2        }
1291   1      }
1292          // 读继电器状态
1293          void relay_read(module_t *p)
1294          {
1295   1        pack_data_send(&user_modbus, p->adr, MD_RD_HR, 32, 1);
1296   1      }
1297          // 继电器控制
1298          void relay_single_ctrl(module_t *p)
1299          {
1300   1      
1301   1        unsigned short key_nb = 0;
1302   1        unsigned char i = 0;
1303   1        unsigned char single_key_tab[5][12] =
1304   1            {
1305   1                {2, 4, 11, 9},                           // 4路
1306   1                {2, 3, 4, 11, 10, 9},                    // 6路
1307   1                {2, 3, 4, 6, 7, 11, 10, 9},              // 8路
1308   1                {1, 2, 3, 4, 5, 12, 11, 10, 9, 8},       // 10路
1309   1                {1, 2, 3, 4, 5, 6, 7, 12, 11, 10, 9, 8}, // 12路
1310   1            };
1311   1        unsigned char double_key_tab[16] = {0x01, 0x02, 0x04, 0x05, 12, 11, 9, 8, 0x81, 0x82, 0x84, 0x85, 0x8c, 0
             -x8b, 0x89, 0x88};
1312   1        get_key_value(0x1010, &key_nb);
1313   1        if (HR[32] != g_var_module.led_sta_bak) // 状态变换
1314   1      
1315   1        {
1316   2          USER_PRINTF("-->relay state has been changed!\n");
1317   2          g_var_module.led_sta_bak = HR[32];
1318   2          // USER_PRINTF("-->g_var_module.led_sta_bak is %d!\n", g_var_module.led_sta_bak);
1319   2          for (i = 0; i < 16; i++)
1320   2          {
1321   3            led_sta[i] = (HR[32] >> i) & 0x01;
C51 COMPILER V9.60.0.0   MODULE                                                            11/04/2023 11:13:36 PAGE 23  

1322   3            write_dgusii_vp(0x1030 + i, (unsigned char *)&led_sta[i], 1);
1323   3            //      sys_delay_about_ms(1);
1324   3          }
1325   2        }
1326   1        if ((key_nb) && (mbh_getState() == MBH_STATE_IDLE))
1327   1        {
1328   2      
1329   2          led_sta[key_nb - 1] ^= 1;
1330   2          printf_tab(32, (unsigned char *)&led_sta[0]);
1331   2          write_dgusii_vp(0x1030 + key_nb - 1, (unsigned char *)&led_sta[key_nb - 1], 1);
1332   2          if ((SINGLE_RELAY_MODULE == p->type) || (SINGLE_TIME_RELAY_MODULE == p->type))
1333   2          {
1334   3            if (4 == p->channel_nb)
1335   3              set_master_send_hr(master_send_hr, 0, single_key_tab[0][key_nb - 1]);
1336   3            else if (6 == p->channel_nb)
1337   3              set_master_send_hr(master_send_hr, 0, single_key_tab[1][key_nb - 1]);
1338   3            else if (8 == p->channel_nb)
1339   3              set_master_send_hr(master_send_hr, 0, single_key_tab[2][key_nb - 1]);
1340   3            else if (10 == p->channel_nb)
1341   3              set_master_send_hr(master_send_hr, 0, single_key_tab[3][key_nb - 1]);
1342   3            else if (12 == p->channel_nb)
1343   3              set_master_send_hr(master_send_hr, 0, single_key_tab[4][key_nb - 1]);
1344   3          }
1345   2          else if ((DOUBLE_RELAY_MODULE == p->type) || (DOUBLE_TIME_RELAY_MODULE == p->type))
1346   2          {
1347   3            set_master_send_hr(master_send_hr, 0, double_key_tab[key_nb - 1]);
1348   3          }
1349   2          set_master_send_hr(master_send_hr, 1, ENTERPRISE);
1350   2          pack_data_send(&user_modbus, p->adr, MD_FR_MHR, 0, 2);
1351   2          HR[32] = g_var_module.led_sta_bak = master_send_hr[32];
1352   2          clear_key_value(0x1010, &key_nb);
1353   2        }
1354   1      }
1355          // 继电器全开全关
1356          void relay_all_ctrl(module_t *p)
1357          {
1358   1        unsigned char i = 0;
1359   1        unsigned short key_nb = 0;
1360   1        get_key_value(0x100c, &key_nb);
1361   1        if ((1 == key_nb) || (2 == key_nb))
1362   1        {
1363   2          for (i = 0; i < 16; i++)
1364   2          {
1365   3            led_sta[i] = key_nb > 1 ? 0 : 1;
1366   3            write_dgusii_vp(0x1030 + i, (unsigned char *)&led_sta[i], 1);
1367   3          }
1368   2          set_master_send_hr(master_send_hr, 31, 0xffff);
1369   2          set_master_send_hr(master_send_hr, 32, key_nb > 1 ? 0 : 0xffff);
1370   2          set_master_send_hr(master_send_hr, 33, ENTERPRISE);
1371   2          pack_data_send(&user_modbus, p->adr, MD_FR_MHR, 31, 3);
1372   2          clear_key_value(0x100c, &key_nb);
1373   2          HR[32] = g_var_module.led_sta_bak = master_send_hr[32];
1374   2        }
1375   1      }
1376          // 发送继电器开关广播命令
1377          void all_module_on_off(void)
1378          {
1379   1        unsigned short key_nb = 0;
1380   1        get_key_value(RELAY_MODULE_KEY_ALL_ON_ADR, &key_nb);
1381   1        if ((1 == key_nb))
1382   1        {
1383   2          set_master_send_hr(master_send_hr, 31, 0xffff);
C51 COMPILER V9.60.0.0   MODULE                                                            11/04/2023 11:13:36 PAGE 24  

1384   2          set_master_send_hr(master_send_hr, 32, 0xffff);
1385   2          set_master_send_hr(master_send_hr, 33, ENTERPRISE);
1386   2          pack_data_send(&user_modbus, 0, MD_FR_MHR, 31, 3);
1387   2          clear_key_value(RELAY_MODULE_KEY_ALL_ON_ADR, &key_nb);
1388   2          HR[32] = g_var_module.led_sta_bak = 0xffff;
1389   2        }
1390   1        get_key_value(RELAY_MODULE_KEY_ALL_OFF_ADR, &key_nb);
1391   1        if ((1 == key_nb))
1392   1        {
1393   2          set_master_send_hr(master_send_hr, 31, 0xffff);
1394   2          set_master_send_hr(master_send_hr, 32, 0);
1395   2          set_master_send_hr(master_send_hr, 33, ENTERPRISE);
1396   2          pack_data_send(&user_modbus, 0, MD_FR_MHR, 31, 3);
1397   2          clear_key_value(RELAY_MODULE_KEY_ALL_OFF_ADR, &key_nb);
1398   2          HR[32] = g_var_module.led_sta_bak = 0;
1399   2        }
1400   1      }
1401          // 继电器状态刷新
1402          void relay_refesh(module_t *p)
1403          {
1404   1        unsigned short key_nb = 0;
1405   1        get_key_value(0x100c, &key_nb);
1406   1        if (3 == key_nb)
1407   1        {
1408   2          pack_data_send(&user_modbus, p->adr, MD_RD_HR, 32, 1);
1409   2      
1410   2          clear_key_value(0x100c, &key_nb);
1411   2        }
1412   1      }
1413          // 继电器界面控制
1414          void relay_ctrl(module_t *p)
1415          {
1416   1        relay_single_ctrl(p);
1417   1        relay_all_ctrl(p);
1418   1        relay_refesh(p);
1419   1      }
1420          // 读调光
1421          void dim_read(module_t *p)
1422          {
1423   1        delay_us(1000);
1424   1        pack_data_send(&user_modbus, p->adr, MD_RD_HR, 23, 4);
1425   1      }
1426          // 调光控制
1427          void dim_single_ctrl(module_t *p)
1428          {
1429   1        unsigned char i = 0;
1430   1        static unsigned char dim_send_flag = 0, key_down_flag = 0, key_up_flag = 0;
1431   1        unsigned short key_nb = 0;
1432   1        unsigned short y_coordinate = 0;
1433   1        unsigned short x_coordinate = 0;
1434   1        unsigned char dim_gear[8] = {0};
1435   1        unsigned char touch_sta[8] = {0};
1436   1        for (i = 0; i < 4; i++)
1437   1        {
1438   2          if (g_var_module.dim_light_bak[i] != HR[23 + i])
1439   2          {
1440   3            USER_PRINTF("-->dim state has been changed!\n");
1441   3            g_var_module.dim_light_bak[i] = HR[23 + i];
1442   3            if (VOL_DIM_MODULE == p->type)
1443   3            {
1444   4      
1445   4              write_dgus(0x1100 + i, g_var_module.dim_light_bak[i]);
C51 COMPILER V9.60.0.0   MODULE                                                            11/04/2023 11:13:36 PAGE 25  

1446   4            }
1447   3            else
1448   3            {
1449   4              write_dgus(0x1013 + i, g_var_module.dim_light_bak[i]);
1450   4            }
1451   3          }
1452   2          //    sys_delay_about_ms(1);
1453   2        }
1454   1        if ((DIM_CTRL_PAGE == read_pic()) || (SCR_CTRL_PAGE == read_pic()))
1455   1        {
1456   2      
1457   2          //    USER_PRINTF("display_pic_dim_edit \n");
1458   2          read_dgusii_vp(0x16, touch_sta, 4);
1459   2          if (touch_sta[0])
1460   2          {
1461   3            printf_tab(8, touch_sta);
1462   3      
1463   3            y_coordinate = touch_sta[4] * 256 + touch_sta[5];
1464   3            x_coordinate = touch_sta[2] * 256 + touch_sta[3];
1465   3            if ((3 == touch_sta[1]) && (0 == key_down_flag))
1466   3            {
1467   4              key_down_flag = 1;
1468   4              key_up_flag = 0;
1469   4              USER_PRINTF("-->key_down_flag = 1 \n");
1470   4            }
1471   3            else if ((2 == touch_sta[1]) && (1 == key_down_flag))
1472   3            {
1473   4              key_down_flag = 3;
1474   4              key_up_flag = 0;
1475   4              USER_PRINTF("-->key_down_flag = 3 \n");
1476   4            }
1477   3            else if ((2 == touch_sta[1]) && (0 == key_down_flag) && (0 == key_up_flag))
1478   3            {
1479   4              key_up_flag = 1;
1480   4              USER_PRINTF("-->key_up_flag = 1 \n");
1481   4            }
1482   3            touch_sta[0] = 0;
1483   3            touch_sta[1] = 0;
1484   3            touch_sta[2] = 0;
1485   3            touch_sta[3] = 0;
1486   3            touch_sta[4] = 0;
1487   3            touch_sta[5] = 0;
1488   3            write_dgusii_vp(0x16, touch_sta, 4);
1489   3            USER_PRINTF("-->x_coordinate = %d,y_coordinate = %d \n", x_coordinate, y_coordinate);
1490   3          }
1491   2      
1492   2          set_master_send_hr(master_send_hr, 27, ENTERPRISE);
1493   2          if (VOL_DIM_MODULE == p->type)
1494   2          {
1495   3            read_dgusii_vp(0x1100, dim_gear, 4);
1496   3            //      set_master_send_hr(master_send_hr,22,0xffff);
1497   3            //      set_master_send_hr(master_send_hr,23,dim_gear[1]);
1498   3            //      set_master_send_hr(master_send_hr,24,dim_gear[3]);
1499   3            //      set_master_send_hr(master_send_hr,25,dim_gear[5]);
1500   3            //      set_master_send_hr(master_send_hr,26,dim_gear[7]);
1501   3          }
1502   2          else
1503   2          {
1504   3            read_dgusii_vp(0x1013, dim_gear, 4);
1505   3          }
1506   2          set_master_send_hr(master_send_hr, 22, 0xffff);
1507   2          set_master_send_hr(master_send_hr, 23, dim_gear[1]);
C51 COMPILER V9.60.0.0   MODULE                                                            11/04/2023 11:13:36 PAGE 26  

1508   2          set_master_send_hr(master_send_hr, 24, dim_gear[3]);
1509   2          set_master_send_hr(master_send_hr, 25, dim_gear[5]);
1510   2          set_master_send_hr(master_send_hr, 26, dim_gear[7]);
1511   2          HR[23] = g_var_module.dim_light_bak[0] = master_send_hr[23];
1512   2          HR[24] = g_var_module.dim_light_bak[1] = master_send_hr[24];
1513   2          HR[25] = g_var_module.dim_light_bak[2] = master_send_hr[25];
1514   2          HR[26] = g_var_module.dim_light_bak[3] = master_send_hr[26];
1515   2          if (((y_coordinate > 262) && (y_coordinate < 550) && ((3 == key_down_flag) || (1 == key_up_flag))))
1516   2      
1517   2          {
1518   3            USER_PRINTF("-->send--OK \n");
1519   3            dim_send_flag = 1;
1520   3            key_down_flag = 0;
1521   3            key_up_flag = 0;
1522   3          }
1523   2      
1524   2          //    USER_PRINTF("g_var_module.dim_light_bak-->");
1525   2          //    printf_tab(8,g_var_module.dim_light_bak);
1526   2          if (1 == dim_send_flag)
1527   2          {
1528   3            //      USER_PRINTF("dim_send_flag --> 1 \n");
1529   3            dim_send_flag = 0;
1530   3            pack_data_send(&user_modbus, p->adr, MD_FR_MHR, 22, 6);
1531   3      
1532   3            USER_PRINTF("-->DIM_MODULE dim_send_ok  \n");
1533   3          }
1534   2        }
1535   1        else
1536   1        {
1537   2          key_down_flag = 0;
1538   2          key_up_flag = 0;
1539   2        }
1540   1      }
1541          // 调光全开全关
1542          void dim_all_ctrl(module_t *p)
1543          {
1544   1        //  unsigned char i = 0;
1545   1        unsigned short key_nb = 0;
1546   1        //  unsigned char dim_gear[8] = {0};
1547   1        get_key_value(0x100c, &key_nb);
1548   1        if ((0x11 == key_nb) || (0x12 == key_nb))
1549   1        {
1550   2      
1551   2          set_master_send_hr(master_send_hr, 22, 0xffff);
1552   2          set_master_send_hr(master_send_hr, 23, p->type == VOL_DIM_MODULE ? (key_nb > 0x11 ? 0 : 10) : (key_nb > 
             -0x11 ? 0 : 100));
1553   2          set_master_send_hr(master_send_hr, 24, p->type == VOL_DIM_MODULE ? (key_nb > 0x11 ? 0 : 10) : (key_nb > 
             -0x11 ? 0 : 100));
1554   2          set_master_send_hr(master_send_hr, 25, p->type == VOL_DIM_MODULE ? (key_nb > 0x11 ? 0 : 10) : (key_nb > 
             -0x11 ? 0 : 100));
1555   2          set_master_send_hr(master_send_hr, 26, p->type == VOL_DIM_MODULE ? (key_nb > 0x11 ? 0 : 10) : (key_nb > 
             -0x11 ? 0 : 100));
1556   2          set_master_send_hr(master_send_hr, 27, ENTERPRISE);
1557   2          pack_data_send(&user_modbus, p->adr, MD_FR_MHR, 22, 6);
1558   2          clear_key_value(0x100c, &key_nb);
1559   2          write_dgusii_vp(VOL_DIM_MODULE == p->type ? 0x1100 : 0x1013, (unsigned char *)(master_send_hr + 23), 4);
1560   2          HR[23] = g_var_module.dim_light_bak[0] = master_send_hr[23];
1561   2          HR[24] = g_var_module.dim_light_bak[1] = master_send_hr[24];
1562   2          HR[25] = g_var_module.dim_light_bak[2] = master_send_hr[25];
1563   2          HR[26] = g_var_module.dim_light_bak[3] = master_send_hr[26];
1564   2        }
1565   1      }
C51 COMPILER V9.60.0.0   MODULE                                                            11/04/2023 11:13:36 PAGE 27  

1566          // 发送开关广播命令
1567          void all_dim_on_off(void)
1568          {
1569   1        //  unsigned char i = 0;
1570   1        unsigned short key_nb = 0;
1571   1        //  unsigned char dim_gear[8] = {0};
1572   1        get_key_value(DIM_MODULE_KEY_ALL_ON_ADR, &key_nb);
1573   1        if (1 == key_nb)
1574   1        {
1575   2      
1576   2          set_master_send_hr(master_send_hr, 22, 0xffff);
1577   2          set_master_send_hr(master_send_hr, 23, 100);
1578   2          set_master_send_hr(master_send_hr, 24, 100);
1579   2          set_master_send_hr(master_send_hr, 25, 100);
1580   2          set_master_send_hr(master_send_hr, 26, 100);
1581   2          set_master_send_hr(master_send_hr, 27, ENTERPRISE);
1582   2          pack_data_send(&user_modbus, 0, MD_FR_MHR, 22, 6);
1583   2          clear_key_value(DIM_MODULE_KEY_ALL_ON_ADR, &key_nb);
1584   2          HR[23] = g_var_module.dim_light_bak[0] = master_send_hr[23];
1585   2          HR[24] = g_var_module.dim_light_bak[1] = master_send_hr[24];
1586   2          HR[25] = g_var_module.dim_light_bak[2] = master_send_hr[25];
1587   2          HR[26] = g_var_module.dim_light_bak[3] = master_send_hr[26];
1588   2        }
1589   1        get_key_value(DIM_MODULE_KEY_ALL_OFF_ADR, &key_nb);
1590   1        if (1 == key_nb)
1591   1        {
1592   2      
1593   2          set_master_send_hr(master_send_hr, 22, 0xffff);
1594   2          set_master_send_hr(master_send_hr, 23, 0);
1595   2          set_master_send_hr(master_send_hr, 24, 0);
1596   2          set_master_send_hr(master_send_hr, 25, 0);
1597   2          set_master_send_hr(master_send_hr, 26, 0);
1598   2          set_master_send_hr(master_send_hr, 27, ENTERPRISE);
1599   2          pack_data_send(&user_modbus, 0, MD_FR_MHR, 22, 6);
1600   2          clear_key_value(DIM_MODULE_KEY_ALL_OFF_ADR, &key_nb);
1601   2          HR[23] = g_var_module.dim_light_bak[0] = master_send_hr[23];
1602   2          HR[24] = g_var_module.dim_light_bak[1] = master_send_hr[24];
1603   2          HR[25] = g_var_module.dim_light_bak[2] = master_send_hr[25];
1604   2          HR[26] = g_var_module.dim_light_bak[3] = master_send_hr[26];
1605   2        }
1606   1      }
1607          // 调光状态刷新
1608          void dim_refesh(module_t *p)
1609          {
1610   1        unsigned short key_nb = 0;
1611   1        get_key_value(0x100c, &key_nb);
1612   1        if (0x13 == key_nb)
1613   1        {
1614   2          pack_data_send(&user_modbus, p->adr, MD_RD_HR, 23, 4);
1615   2      
1616   2          clear_key_value(0x100c, &key_nb);
1617   2        }
1618   1      }
1619          // 调光界面控制
1620          void dim_ctrl(module_t *p)
1621          {
1622   1        dim_single_ctrl(p);
1623   1        dim_all_ctrl(p);
1624   1        dim_refesh(p);
1625   1      }
1626          // 显示设置界面
1627          void display_interface(module_t *p)
C51 COMPILER V9.60.0.0   MODULE                                                            11/04/2023 11:13:36 PAGE 28  

1628          {
1629   1        if (0 == p->data_sta)
1630   1        {
1631   2          return;
1632   2        }
1633   1        switch (p->type)
1634   1        {
1635   2        case SINGLE_RELAY_MODULE:
1636   2        case SINGLE_TIME_RELAY_MODULE:
1637   2        case DOUBLE_RELAY_MODULE:
1638   2        case DOUBLE_TIME_RELAY_MODULE:
1639   2      
1640   2          display_relay_interface(p);
1641   2          USER_PRINTF("-->display_relay_interface\n");
1642   2          relay_read(p);
1643   2          break;
1644   2        case VOL_DIM_MODULE:
1645   2        case SCR_DIM_MODULE:
1646   2          clear_touch_sta();
1647   2          display_dim_interface(p);
1648   2          USER_PRINTF("-->display_dim_interface\n");
1649   2          dim_read(p);
1650   2          break;
1651   2        default:
1652   2      
1653   2          break;
1654   2        }
1655   1      }
1656          // 打开模块
1657          
1658          void module_touch(module_t *p, unsigned char key)
1659          {
1660   1        norflash_read((key - 1) * MODULE_FLASH_SIZE, (unsigned char *)p, MODULE_FLASH_SIZE);
1661   1        display_interface(p);
1662   1      }
1663          void module_touch_ctrl(void)
1664          {
1665   1        unsigned short key_nb = 0;
1666   1        get_key_value(0x100a, &key_nb);
1667   1        if (key_nb)
1668   1        {
1669   2          //    clear_led_sta(led_sta);
1670   2          module_touch(&module, key_nb);
1671   2          clear_key_value(0x100a, &key_nb);
1672   2          key_nb = 0;
1673   2        }
1674   1      }
1675          // 恢复出厂设置
1676          void factory_data_reset(void)
1677          {
1678   1      
1679   1        unsigned char ret_tab[4] = {0x55, 0xaa, 0x5a, 0xa5};
1680   1        unsigned short key_nb = 0;
1681   1        unsigned char i = 0;
1682   1        get_key_value(0x100b, &key_nb);
1683   1        if (1 == key_nb)
1684   1        {
1685   2          // 读写T5L片内256KW Flash，mod=0x5A 为读取，mod=0xA5为写入
1686   2          // addr=DGUS变量地址，必须是偶数；addr_flash=flash读取地址，必须是偶数；len=读取字长度，必须是偶数。
1687   2          // 从屏幕的变量地址区域找一块连续的全是0的，然后将数据写入到数据库进行覆盖
1688   2          for (i = 0; i < 61; i++) // 清到F400 一些参数设置不清空
1689   2          {
C51 COMPILER V9.60.0.0   MODULE                                                            11/04/2023 11:13:36 PAGE 29  

1690   3            T5L_Flash(0xA5, 0Xe000, 1024 * i, 1024); // 写0FLASH清除
1691   3          }
1692   2          //    T5L_Flash(0x5A,0X3110, 0,1024); //读为0
1693   2          clear_key_value(0x100a, &key_nb);
1694   2          key_nb = 0;
1695   2          write_dgusii_vp(0x04, (unsigned char *)&ret_tab, 2); // MCU复位
1696   2        }
1697   1      }
1698          
1699          /**
1700           * @brief 修改模块-显示编辑页面
1701           * @param {module_t} *p 模块指针
1702           * @return {*}
1703           */
1704          void display_edit_interface(module_t *p)
1705          {
1706   1      
1707   1        USER_PRINTF("display_edit_interface\n");
1708   1        // USER_PRINTF("current module type is %bd\n", p->type);
1709   1        write_dgus(0x2000, p->adr);
1710   1        module_type_bak = p->type;
1711   1        write_dgusii_vp(0x3110, (unsigned char *)&module_name_tab[p->type], 6);
1712   1        write_dgus(0x1000, p->channel_nb);
1713   1        write_dgusii_vp(0x3000, (unsigned char *)&p->module_name, 8);
1714   1        //  sprintf(p->channel_name,"%.256s",p->channel_name);
1715   1        // USER_PRINTF("-->module name is %s\n", p->module_name);
1716   1        // USER_PRINTF("-->module channel name is %s\n", p->channel_name);
1717   1        write_dgusii_vp(0x3008, (unsigned char *)&p->channel_name, 8 * 16);
1718   1        switch (p->channel_nb)
1719   1        {
1720   2        case 4:
1721   2          if ((DOUBLE_RELAY_MODULE == p->type) || (DOUBLE_TIME_RELAY_MODULE == p->type))
1722   2            pic_set(DOUBLE_MODULE_4_CHANNEL_EDIT_PAGE);
1723   2          else if ((SINGLE_RELAY_MODULE == p->type) || (SINGLE_TIME_RELAY_MODULE == p->type))
1724   2            pic_set(SINGLE_MODULE_4_CHANNEL_EDIT_PAGE);
1725   2          else if ((VOL_DIM_MODULE == p->type))
1726   2            pic_set(PWM_MODULE_4_CHANNEL_EDIT_PAGE);
1727   2          else if ((SCR_DIM_MODULE == p->type))
1728   2            pic_set(SCR_MODULE_4_CHANNEL_EDIT_PAGE);
1729   2          break;
1730   2        case 6:
1731   2          if ((DOUBLE_RELAY_MODULE == p->type) || (DOUBLE_TIME_RELAY_MODULE == p->type))
1732   2            pic_set(DOUBLE_MODULE_6_CHANNEL_EDIT_PAGE);
1733   2          else if ((SINGLE_RELAY_MODULE == p->type) || (SINGLE_TIME_RELAY_MODULE == p->type))
1734   2            pic_set(SINGLE_MODULE_6_CHANNEL_EDIT_PAGE);
1735   2      
1736   2          break;
1737   2        case 8:
1738   2          if ((DOUBLE_RELAY_MODULE == p->type) || (DOUBLE_TIME_RELAY_MODULE == p->type))
1739   2            pic_set(DOUBLE_MODULE_8_CHANNEL_EDIT_PAGE);
1740   2          else if ((SINGLE_RELAY_MODULE == p->type) || (SINGLE_TIME_RELAY_MODULE == p->type))
1741   2            pic_set(SINGLE_MODULE_8_CHANNEL_EDIT_PAGE);
1742   2      
1743   2          break;
1744   2        case 10:
1745   2          if ((DOUBLE_RELAY_MODULE == p->type) || (DOUBLE_TIME_RELAY_MODULE == p->type))
1746   2            pic_set(DOUBLE_MODULE_10_CHANNEL_EDIT_PAGE);
1747   2          else if ((SINGLE_RELAY_MODULE == p->type) || (SINGLE_TIME_RELAY_MODULE == p->type))
1748   2            pic_set(SINGLE_MODULE_10_CHANNEL_EDIT_PAGE);
1749   2      
1750   2          break;
1751   2        case 12:
C51 COMPILER V9.60.0.0   MODULE                                                            11/04/2023 11:13:36 PAGE 30  

1752   2          if ((DOUBLE_RELAY_MODULE == p->type) || (DOUBLE_TIME_RELAY_MODULE == p->type))
1753   2            pic_set(DOUBLE_MODULE_12_CHANNEL_EDIT_PAGE);
1754   2          else if ((SINGLE_RELAY_MODULE == p->type) || (SINGLE_TIME_RELAY_MODULE == p->type))
1755   2            pic_set(SINGLE_MODULE_12_CHANNEL_EDIT_PAGE);
1756   2      
1757   2          break;
1758   2        case 14:
1759   2          if ((DOUBLE_RELAY_MODULE == p->type) || (DOUBLE_TIME_RELAY_MODULE == p->type))
1760   2            pic_set(DOUBLE_MODULE_14_CHANNEL_EDIT_PAGE);
1761   2      
1762   2          break;
1763   2        case 16:
1764   2          if ((DOUBLE_RELAY_MODULE == p->type) || (DOUBLE_TIME_RELAY_MODULE == p->type))
1765   2            pic_set(DOUBLE_MODULE_16_CHANNEL_EDIT_PAGE);
1766   2          break;
1767   2        default:
1768   2          break;
1769   2        }
1770   1      }
1771          
1772          // 配置模块信息
1773          void modifying_module_information(module_t *p)
1774          
1775          {
1776   1        unsigned short key_nb = 0;
1777   1        unsigned char select_index = 0;
1778   1        get_key_value(0x1009, &key_nb);
1779   1        if (1 == key_nb) // 添加模块
1780   1        {
1781   2          clear_key_value(0x1009, &key_nb);
1782   2          USER_PRINTF("-->ctrl_mgmt_sta\n");
1783   2          modfity_index = find_index(0, MODULE_FLASH_SIZE, MODULE_NUB_LIMIT);
1784   2          if (OVERFLOW_SIZE == modfity_index)
1785   2          {
1786   3            USER_PRINTF("-->waring! too many module \n");
1787   3            pop_menu_key_ctrl(OVERFLOW_WARING_CODE);
1788   3            return;
1789   3          }
1790   2          pic_set(MODULE_ADD_PAGE);
1791   2          //    USER_PRINTF("<--get_blank_index -->%bd\n", modfity_index);
1792   2          write_dgusii_vp(0x3110, (unsigned char *)&module_name_tab[0], 6);
1793   2          write_dgusii_vp(0x3008, (unsigned char *)&default_module_channel_name, 256);
1794   2          write_dgusii_vp(0x3000, (unsigned char *)module_default_name, 8);
1795   2          write_dgus(0X1000, 4);
1796   2        }
1797   1        if ((3 == key_nb)) // 修改模块
1798   1        {
1799   2          clear_key_value(0x1009, &key_nb);
1800   2          // select_index = get_selected_sequence_number(0x1104, 8);
1801   2          select_index = get_box_select_number(0x1400, 64);
1802   2          // USER_PRINTF("select_index-->%bd\n", select_index);
1803   2          if ((select_index > 0) && (FULL == check_whether_data_exists(0, select_index - 1, MODULE_FLASH_SIZE)))
1804   2          {
1805   3            modfity_index = select_index - 1;
1806   3            norflash_read((select_index - 1) * MODULE_FLASH_SIZE, (unsigned char *)p, MODULE_FLASH_SIZE);
1807   3            //      display_interface(p);
1808   3            display_edit_interface(p);
1809   3            USER_PRINTF("-->modify module successfully!\n");
1810   3            delete_arr_data(&g_var_module.module_adr[0], modfity_index);
1811   3            // g_var_module.module_edit_sta = MODIFY;
1812   3          }
1813   2        }
C51 COMPILER V9.60.0.0   MODULE                                                            11/04/2023 11:13:36 PAGE 31  

1814   1      }
1815          
1816          // 删除选中模块信息
1817          void clear_select_module_information(void)
1818          
1819          {
1820   1        unsigned short key_nb = 0;
1821   1        unsigned char select_index = 0;
1822   1        //  unsigned char i = 0;
1823   1        get_key_value(0x1012, &key_nb);
1824   1        if ((1 == key_nb))
1825   1        {
1826   2          //    select_index = get_selected_sequence_number(0x1104, 8);
1827   2          select_index = get_box_select_number(0x1400, 64);
1828   2          // USER_PRINTF("select_index-->%bd\n", select_index);
1829   2          if (select_index)
1830   2          {
1831   3            //      if(FULL == p->data_sta)
1832   3            //      {
1833   3            T5L_Flash(0xA5, 0Xe000, (select_index - 1) * MODULE_FLASH_SIZE, MODULE_FLASH_SIZE);            // 写0FLASH清
             -除
1834   3            T5L_Flash(0x5A, 0X3520 + (select_index - 1) * 32, (select_index - 1) * MODULE_FLASH_SIZE, 32); // 读为0
             -控制器信息
1835   3            //        T5L_Flash(0x5A,0X3120+(select_index-1)*32, TIMING_SCENE_INFOR_FLASH_ADR_END,32); //读为0控制器信
             -
1836   3            T5L_Flash(0x5A, 0x3120 + (select_index - 1) * 8, (select_index - 1) * MODULE_FLASH_SIZE, 8); // 读为0
1837   3            write_dgusii_vp(0x3120 + 8 * (select_index - 1), (unsigned char *)module_no_name, 8);
1838   3            delete_arr_data(&g_var_module.module_adr[0], select_index - 1);
1839   3            printf_tab(20, &g_var_module.module_adr[0]);
1840   3            //      }
1841   3          }
1842   2          clear_all_module_var_en(0x1400, 64);
1843   2          clear_key_value(0x1012, &key_nb);
1844   2        }
1845   1      }
1846          // 清空所有模块信息
1847          void clear_all_module_information(void)
1848          
1849          {
1850   1        unsigned short key_nb = 0;
1851   1        unsigned char i = 0;
1852   1        //  unsigned char select_index = 0;
1853   1        get_key_value(0x1011, &key_nb);
1854   1        if ((1 == key_nb))
1855   1        {
1856   2          USER_PRINTF("clear_all_module_information\n");
1857   2          //    T5L_Flash(0xA5,0Xe000, 0,1024);     //写0FLASH清除
1858   2          //    T5L_Flash(0xA5,0Xe000, 1024,1024);  //写0FLASH清除
1859   2          //    T5L_Flash(0xA5,0Xe000, 2048,1024);  //写0FLASH清除
1860   2          //    T5L_Flash(0xA5,0Xe000, 3072,1024);  //写0FLASH清除
1861   2          //    T5L_Flash(0xA5,0Xe000, 4096,1024);  //写0FLASH清除
1862   2          //    T5L_Flash(0xA5,0Xe000, 8192,768);   //写0FLASH清除
1863   2          for (i = 0; i < 8; i++)
1864   2          {
1865   3            T5L_Flash(0xA5, 0Xe000, 1024 * i, 1024); // 写0FLASH清除
1866   3          }
1867   2          T5L_Flash(0xA5, 0Xe000, 8192, 768);  // 写0FLASH清除
1868   2          T5L_Flash(0x5A, 0X3520, 0, 32 * 64); // 读为0
1869   2          T5L_Flash(0x5A, 0x3120, 0, 8 * 64);  // 读为0
1870   2          clear_arr_data(&g_var_module.module_adr, MODULE_NUB_LIMIT);
1871   2          // for (i = 0; i < 64; i++)
1872   2          // {
C51 COMPILER V9.60.0.0   MODULE                                                            11/04/2023 11:13:36 PAGE 32  

1873   2          //  write_dgusii_vp(0x3120 + 8 * i, (unsigned char *)module_default_name, 8);
1874   2          // }
1875   2          //    T5L_Flash(0x5A,0X3120, 0,1024); //读为0
1876   2          clear_key_value(0x1011, &key_nb);
1877   2        }
1878   1      }
1879          // 初始化密码
1880          void init_pwd_f(void)
1881          {
1882   1        unsigned char mask[4] = {0};
1883   1        unsigned char pwd_enable = 0;
1884   1        norflash_read(0x020002, (unsigned char *)&mask, 2);
1885   1      
1886   1        pwd_enable = read_dgus(PWD_SELECT_FRAME_ADR);
1887   1        if (0xff != mask[0])
1888   1        {
1889   2          init_pwd = read_dgus(0x2050);
1890   2        }
1891   1        else
1892   1        {
1893   2          T5L_Flash(0x5a, PWD_SELECT_FRAME_ADR, PWD_FLASH_ADR, 2); // 读密码使能
1894   2          T5L_Flash(0x5A, 0x2050, 0x020000, 2);                    // 从FLASH读密码
1895   2          init_pwd = read_dgus(0x2050);
1896   2        }
1897   1        // printf_tab(2, mask);
1898   1        // USER_PRINTF("-->read pwd enable is %bd\n", pwd_enable);
1899   1        // USER_PRINTF("-->read_pwd var is %d\n", init_pwd);
1900   1      }
1901          // 修改密码
1902          void change_pwd(unsigned short *pwd_init)
1903          {
1904   1        unsigned short key_nb = 0;
1905   1        unsigned char mask[4] = {0xff, 0xff, 0xff, 0xff};
1906   1        get_key_value(0x111e, &key_nb);
1907   1        if (1 == key_nb)
1908   1        {
1909   2          clear_key_value(0x111e, &key_nb);
1910   2          if (*pwd_init != read_dgus(0x2050))
1911   2          {
1912   3            *pwd_init = read_dgus(0x2050);
1913   3            T5L_Flash(0xA5, 0x2050, 0x020000, 2); // 写密码到FLASH
1914   3            norflash_write(0x020002, (unsigned char *)&mask, 2);
1915   3            USER_PRINTF("-->change password success!\n");
1916   3            printf_tab(2, mask);
1917   3          }
1918   2        }
1919   1      }
1920          // 选择密码使能
1921          void select_password_enable(void)
1922          {
1923   1        //  static unsigned char var_enable = 0;
1924   1        unsigned short key_nb = 0;
1925   1        unsigned char pwd_enable = 0xff;
1926   1        get_key_value(0x1242, &key_nb);
1927   1        if (1 == key_nb)
1928   1        {
1929   2      
1930   2          pwd_enable = check_or_not_frame(PWD_SELECT_FRAME_ADR);
1931   2          if (1 == check_constant(pwd_enable, &g_var_module.pwd_enable_bak))
1932   2          {
1933   3            T5L_Flash(0xA5, PWD_SELECT_FRAME_ADR, PWD_FLASH_ADR, 2); // 写密码使能到FLASH
1934   3                                                                     // USER_PRINTF("-->set password enable is %bd\n", pwd_enable);
C51 COMPILER V9.60.0.0   MODULE                                                            11/04/2023 11:13:36 PAGE 33  

1935   3          }
1936   2      
1937   2          clear_key_value(0x1242, &key_nb);
1938   2        }
1939   1      }
1940          // 初始化蜂鸣器参数
1941          void init_beep_enable(void)
1942          {
1943   1        unsigned char mask[4] = {0};
1944   1        unsigned char beep_enable = 0;
1945   1        norflash_read(0x020008, (unsigned char *)&mask, 2);
1946   1      
1947   1        if (0xff != mask[0])
1948   1        {
1949   2      
1950   2          USER_PRINTF("-->init_beep_error\n");
1951   2        }
1952   1        else
1953   1        {
1954   2      
1955   2          T5L_Flash(0x5A, BEEP_ENABLE_DGUS_ADR, 0x020006, 2); // 从FLASH读使能
1956   2        }
1957   1        beep_enable = read_dgus(BEEP_ENABLE_DGUS_ADR);
1958   1        sys_delay_about_ms(5);
1959   1        beep_ctrl(beep_enable); // control蜂鸣器声音
1960   1        USER_PRINTF("-->read beep enable is %bd\n", beep_enable);
1961   1      }
1962          // 选择蜂鸣器开关
1963          void select_beep_enable(void)
1964          {
1965   1        unsigned char mask[4] = {0xff, 0xff, 0xff, 0xff};
1966   1        unsigned short key_nb = 0;
1967   1        unsigned char beep_enable = 0xff;
1968   1        get_key_value(0x1241, &key_nb);
1969   1        if ((1 == key_nb))
1970   1        {
1971   2          beep_enable = check_or_not_frame(0x1800);
1972   2      
1973   2          if (1 == check_constant(beep_enable, &g_var_module.beep_enable_bak))
1974   2          {
1975   3            T5L_Flash(0xA5, BEEP_ENABLE_DGUS_ADR, 0x020006, 2); // 写蜂鸣器使能到FLASH
1976   3            norflash_write(0x020008, (unsigned char *)&mask, 2);
1977   3            beep_ctrl(beep_enable); // control蜂鸣器声音
1978   3                                    // USER_PRINTF("-->set beep enable is %bd,\n!", beep_enable);
1979   3          }
1980   2          clear_key_value(0x1241, &key_nb);
1981   2        }
1982   1      }
1983          // 清除密码
1984          void clear_pwd(unsigned short adr)
1985          {
1986   1        write_dgus(adr, 0xffff);
1987   1      }
1988          // 密码是否一致
1989          void check_whether_the_passwords_are_consistent(unsigned char password_enable, unsigned short pwd_input, u
             -nsigned short pwd_init)
1990          {
1991   1        if ((password_enable))
1992   1        {
1993   2          if ((pwd_init == pwd_input) || (SUPER_PASSWORD == pwd_input))
1994   2          {
1995   3            pic_set(1);
C51 COMPILER V9.60.0.0   MODULE                                                            11/04/2023 11:13:36 PAGE 34  

1996   3            clear_pwd(0x204f);
1997   3          }
1998   2          else
1999   2          {
2000   3          }
2001   2        }
2002   1      }
2003          // 主页判断密码
2004          void starup_page_pwd(unsigned char password_enable)
2005          {
2006   1        unsigned short key_nb = 0;
2007   1        get_key_value(0x111c, &key_nb);
2008   1        if ((1 == key_nb))
2009   1        {
2010   2          if (1 == password_enable)
2011   2          {
2012   3            pop_menu_key_ctrl(0x20);
2013   3          }
2014   2          else
2015   2          {
2016   3            pic_set(1);
2017   3            pic_page = 1;
2018   3          }
2019   2          clear_key_value(0x111c, &key_nb);
2020   2        }
2021   1        check_whether_the_passwords_are_consistent(password_enable, read_dgus(0x204f), init_pwd);
2022   1      }
2023          // 初始化背光参数 读flash
2024          void init_back_light_parameters(void)
2025          {
2026   1        unsigned char mask[4] = {0};
2027   1        unsigned char backlight_enable = 0;
2028   1        unsigned char work_light = 0;
2029   1        unsigned short sleep_time = 0;
2030   1        norflash_read(0x02000e, (unsigned char *)&mask, 2);
2031   1      
2032   1        if (0xff != mask[0])
2033   1        {
2034   2        }
2035   1        else
2036   1        {
2037   2          USER_PRINTF("-->read_back_light_parameters_successfully!\n");
2038   2          T5L_Flash(0x5A, 0x1704, 0x02000a, 2); // 从FLASH读数据
2039   2          T5L_Flash(0x5A, 0x2052, 0x02000c, 2); // 从FLASH读数据
2040   2        }
2041   1      
2042   1        backlight_enable = read_dgus(0x1704);
2043   1        // USER_PRINTF("-->read backlight enable is %bd\n", backlight_enable);
2044   1        sys_delay_about_ms(5);
2045   1        work_light = read_dgus(0x2052);
2046   1        // USER_PRINTF("-->read work_light is %bd\n", work_light);
2047   1        sys_delay_about_ms(5);
2048   1        sleep_time = read_dgus(0x2053) * 100;
2049   1        // USER_PRINTF("-->read sleep_time is %ds\n", sleep_time / 100);
2050   1        sys_delay_about_ms(5);
2051   1        back_light_ctrl(backlight_enable);
2052   1        sys_delay_about_ms(2);
2053   1        sys_led_config(work_light, 0, sleep_time);
2054   1      }
2055          // 保存背光参数到flash
2056          void save_back_light_parameters(void)
2057          {
C51 COMPILER V9.60.0.0   MODULE                                                            11/04/2023 11:13:36 PAGE 35  

2058   1        unsigned char mask[4] = {0xff, 0xff, 0xff, 0xff};
2059   1        T5L_Flash(0xA5, 0x1704, 0x02000a, 2); // 写自动锁屏参数到FLASH
2060   1        T5L_Flash(0xA5, 0x2052, 0x02000c, 2); // 写背光参数到FLASH
2061   1        norflash_write(0x02000e, (unsigned char *)&mask, 2);
2062   1        USER_PRINTF("-->save_back_light_parameters_successfully!\n");
2063   1      }
2064          /**
2065           * @brief 框选设置
2066           * @param {unsigned short} adr 框选地址
2067           * @return {*}框选是否选中 1选中  0未选中
2068           */
2069          unsigned char check_or_not_frame(unsigned short adr)
2070          {
2071   1        unsigned char check_var = 0;
2072   1        check_var = read_dgus(adr);
2073   1      
2074   1        check_var ^= 1;
2075   1        sys_delay_about_ms(3);
2076   1        write_dgus(adr, check_var);
2077   1        // USER_PRINTF("--> 0x%x check_var is %bd\n", adr, check_var);
2078   1        return check_var;
2079   1      }
2080          /**
2081           * @brief 锁屏控制
2082           * @return {*}
2083           */
2084          void lock_screen_enable_ctrl(void)
2085          {
2086   1        unsigned char backlight_enable = 0;
2087   1        unsigned short key_nb = 0;
2088   1        get_key_value(0x1240, &key_nb);
2089   1        if ((1 == key_nb))
2090   1        {
2091   2          backlight_enable = check_or_not_frame(0x1704);
2092   2      
2093   2          if (1 == check_constant(backlight_enable, &g_var_module.backlight_enable_bak))
2094   2          {
2095   3            back_light_ctrl(backlight_enable);
2096   3            USER_PRINTF("-->backlight_enable is %bd\n", backlight_enable);
2097   3            save_back_light_parameters();
2098   3          }
2099   2      
2100   2          clear_key_value(0x1240, &key_nb);
2101   2        }
2102   1      }
2103          // 背光设置
2104          void back_light_set(void)
2105          {
2106   1        unsigned short key_nb = 0;
2107   1        unsigned char back_enable = 0;
2108   1        unsigned char work_light = 0;
2109   1        unsigned short sleep_time = 0;
2110   1        get_key_value(0x1126, &key_nb);
2111   1        if ((1 == key_nb))
2112   1        {
2113   2          // back_enable = read_dgus(0x1128);
2114   2          // sys_delay_about_ms(5);
2115   2          work_light = read_dgus(0x2052);
2116   2          sys_delay_about_ms(5);
2117   2          sleep_time = read_dgus(0x2053) * 100;
2118   2          // USER_PRINTF("-->sleep_time is %d\n", sleep_time);
2119   2          sys_delay_about_ms(5);
C51 COMPILER V9.60.0.0   MODULE                                                            11/04/2023 11:13:36 PAGE 36  

2120   2          sys_led_config(work_light, 0, sleep_time);
2121   2          // back_light_ctrl(back_enable);
2122   2          // sys_delay_about_ms(5);
2123   2          // sys_led_config(work_light, 0, sleep_time);
2124   2          clear_key_value(0x1126, &key_nb);
2125   2          USER_PRINTF("-->back_light_set_ok!\n");
2126   2          save_back_light_parameters();
2127   2          pop_menu_key_ctrl(0xdd);
2128   2        }
2129   1      }
2130          // 黑屏切换到主页
2131          void black_screen_switches_to_home_page(void)
2132          {
2133   1        static unsigned char s_sta = 0;
2134   1        unsigned char read_data[2] = {0};
2135   1        read_dgusii_vp(0x31, read_data, 1);
2136   1        if (0 == s_sta)
2137   1        {
2138   2          //    s_sta = 1;
2139   2          if (0 == read_data[1]) // 屏幕亮度为0
2140   2          {
2141   3            s_sta = 1;
2142   3            pic_set(0);
2143   3          }
2144   2        }
2145   1        if (0 != read_data[1])
2146   1        {
2147   2          s_sta = 0;
2148   2        }
2149   1        //  printf_tab(2,read_data);
2150   1      }
2151          // 清除时控参数设置变量
2152          void clear_batch_set_var(void)
2153          {
2154   1        if (g_var_module.batch_send_count > MODULE_NUB_LIMIT)
2155   1        {
2156   2          g_var_module.batch_send_count = 0;
2157   2          g_var_module.batch_set_parameters_flag = 0;
2158   2          g_var_module.batch_send_cyc_time = 0;
2159   2          pop_menu_key_ctrl(0xf0); // 清除弹窗
2160   2          // pic_set(57);
2161   2          USER_PRINTF("-->time module batch set parameter successfully!\n");
2162   2        }
2163   1      }
2164          // 执行对应的动作函数
2165          void run_timing_module_parameter_set(module_t *p, unsigned char fun_execute_nb, unsigned char channel, uns
             -igned char parameter_set_sta)
2166          {
2167   1        switch (fun_execute_nb)
2168   1        {
2169   2        case 0:
2170   2          timing_module_parameter_ongitude_latitude_send(p);
2171   2          break;
2172   2        case 1:
2173   2          timing_module_parameter_time_send(p);
2174   2          break;
2175   2        case 2:
2176   2          timing_module_parameter_week_enable_channel_send(p, channel, parameter_set_sta);
2177   2          break;
2178   2        case 3:
2179   2          timing_module_parameter_solar_channel_send(p, channel, parameter_set_sta);
2180   2          break;
C51 COMPILER V9.60.0.0   MODULE                                                            11/04/2023 11:13:36 PAGE 37  

2181   2        case 4:
2182   2          timing_module_parameter_time_frame_channel_send(p, channel, parameter_set_sta);
2183   2          break;
2184   2        default:
2185   2          break;
2186   2        }
2187   1      }
2188          // 时控参数批量设置
2189          void timing_module_parameter_batch_send(void)
2190          {
2191   1        //  static unsigned char state = 0;
2192   1        //  unsigned char channel = 0;
2193   1        if (((1 <= g_var_module.batch_set_parameters_flag) && (g_var_module.batch_set_parameters_flag <= 5)) || (
             -0x13 == g_var_module.batch_set_parameters_flag) || (0x14 == g_var_module.batch_set_parameters_flag) || (0x15 == g_var_mo
             -dule.batch_set_parameters_flag)) // 不知为何会有异常值出现，排除异常的值
2194   1        {
2195   2          //    USER_PRINTF("-->batch_set_parameters_flag is %bd\n",g_var_module.batch_set_parameters_flag);
2196   2          if ((0 == g_var_module.batch_send_cyc_time) && (mbh_getState() == MBH_STATE_IDLE))
2197   2          {
2198   3            g_var_module.batch_send_cyc_time = 300;
2199   3            norflash_read(g_var_module.batch_send_count * 140, (unsigned char *)&temp_module, 140);
2200   3            if (FULL == temp_module.data_sta)
2201   3            {
2202   4              if ((temp_module.type == SINGLE_TIME_RELAY_MODULE) || (temp_module.type == DOUBLE_TIME_RELAY_MODULE))
2203   4              {
2204   5                //          USER_PRINTF("-->temp_module.adr is %bd\n",temp_module.adr);
2205   5                run_timing_module_parameter_set(&temp_module, g_var_module.parameter_set_fun_execute_nb, g_var_module
             -.parameter_set_channel_number, g_var_module.parameter_set_sta);
2206   5                g_var_module.batch_send_count++;
2207   5              }
2208   4              else
2209   4              {
2210   5                g_var_module.batch_send_count++;
2211   5              }
2212   4            }
2213   3            else
2214   3            {
2215   4              g_var_module.batch_send_count++;
2216   4            }
2217   3          }
2218   2        }
2219   1        clear_batch_set_var();
2220   1      }
2221          /**
2222           * @brief 批量设置时控参数
2223           * @return {*}
2224           */
2225          void batch_set_time_parameters(void)
2226          {
2227   1        unsigned short key_nb = 0;
2228   1        get_key_value(0x112a, &key_nb);
2229   1        if ((key_nb))
2230   1        {
2231   2          switch (key_nb)
2232   2          {
2233   3          case 1: // 经纬度设置
2234   3            g_var_module.parameter_set_fun_execute_nb = 0;
2235   3            g_var_module.parameter_set_channel_number = 0;
2236   3            g_var_module.parameter_set_sta = SINGLE_CHANNEL_STATE;
2237   3            break;
2238   3          case 2: // 时间设置
2239   3            g_var_module.parameter_set_fun_execute_nb = 1;
C51 COMPILER V9.60.0.0   MODULE                                                            11/04/2023 11:13:36 PAGE 38  

2240   3            g_var_module.parameter_set_channel_number = 0;
2241   3            g_var_module.parameter_set_sta = SINGLE_CHANNEL_STATE;
2242   3            break;
2243   3          case 3: // 假日设置
2244   3            g_var_module.parameter_set_fun_execute_nb = 2;
2245   3            g_var_module.parameter_set_channel_number = read_dgus(0x1B04);
2246   3            g_var_module.parameter_set_sta = BATCH_CHANNEL_STATE;
2247   3            break;
2248   3          case 4: // 光照度设置
2249   3            g_var_module.parameter_set_fun_execute_nb = 3;
2250   3            g_var_module.parameter_set_channel_number = read_dgus(0x1B0C);
2251   3            g_var_module.parameter_set_sta = BATCH_CHANNEL_STATE;
2252   3            break;
2253   3          case 5: // 时段设置
2254   3            g_var_module.parameter_set_fun_execute_nb = 4;
2255   3            g_var_module.parameter_set_channel_number = read_dgus(0x1B0F);
2256   3            g_var_module.parameter_set_sta = BATCH_CHANNEL_STATE;
2257   3            break;
2258   3          case 0x13: // 批量假日设置
2259   3            g_var_module.parameter_set_fun_execute_nb = 2;
2260   3            g_var_module.parameter_set_channel_number = 0;
2261   3            g_var_module.parameter_set_sta = BATCH_CHANNELS_STATE;
2262   3            break;
2263   3          case 0x14: // 批量光照度设置
2264   3            g_var_module.parameter_set_fun_execute_nb = 3;
2265   3            g_var_module.parameter_set_channel_number = 0;
2266   3            g_var_module.parameter_set_sta = BATCH_CHANNELS_STATE;
2267   3            break;
2268   3          case 0x15: // 批量时段设置
2269   3            g_var_module.parameter_set_fun_execute_nb = 4;
2270   3            g_var_module.parameter_set_channel_number = 0;
2271   3            g_var_module.parameter_set_sta = BATCH_CHANNELS_STATE;
2272   3            break;
2273   3          default:
2274   3            break;
2275   3          }
2276   2          pop_menu_key_ctrl(0x31); // 弹窗
2277   2          g_var_module.batch_set_parameters_flag = key_nb;
2278   2          // USER_PRINTF("-->batch_set_parameters_flag is %bd\n", g_var_module.batch_set_parameters_flag);
2279   2          clear_key_value(0x112a, &key_nb);
2280   2        }
2281   1      }
2282          // 自动检索设备命令
2283          void automatically_retrieve_cmd(void)
2284          {
2285   1      
2286   1        unsigned short key_nb = 0;
2287   1        get_key_value(0x112c, &key_nb);
2288   1        if ((1 == key_nb))
2289   1        {
2290   2          g_var_module.auto_retrieve_flag = 1;
2291   2          pop_menu_key_ctrl(0x0d); // 弹窗操作中
2292   2          clear_key_value(0x112c, &key_nb);
2293   2        }
2294   1      }
2295          // 读设备信息
2296          void read_device_information(unsigned char adr)
2297          {
2298   1        pack_data_send(&user_modbus, adr, MD_RD_HR, 14, 1);
2299   1      }
2300          // 自动检索设备
2301          void automatically_retrieve(void)
C51 COMPILER V9.60.0.0   MODULE                                                            11/04/2023 11:13:36 PAGE 39  

2302          {
2303   1        static unsigned char send_flag = 0;
2304   1        if (g_var_module.auto_retrieve_flag == 1)
2305   1        {
2306   2          //    g_var_module.retrieve_device_adr
2307   2          //    if( 0 == send_flag)
2308   2          //    {
2309   2          //      send_flag = 1;
2310   2          //      g_var_module.retrieve_device_adr = 1;
2311   2          //    }
2312   2          if ((0 == g_var_module.auto_retrieve_cyc_time) && (mbh_getState() == MBH_STATE_IDLE))
2313   2          {
2314   3            g_var_module.auto_retrieve_cyc_time = 500;
2315   3            read_device_information(g_var_module.retrieve_device_adr);
2316   3            g_var_module.retrieve_device_adr++;
2317   3            // USER_PRINTF("-->retrieve_device_adr is %bd\n", g_var_module.retrieve_device_adr);
2318   3          }
2319   2          //    if(mbh_getState() == MBH_STATE_REC_ERR)
2320   2          //    {
2321   2          //      g_var_module.auto_retrieve_cyc_time = 500;
2322   2          //    }
2323   2        }
2324   1      
2325   1        if ((g_var_module.retrieve_device_adr > DEVICE_NB)) //&&(0 == g_var_module.batch_send_cyc_time)
2326   1        {
2327   2          g_var_module.auto_retrieve_flag = 0;
2328   2          //    g_var_module.retrieve_device_adr = 1;
2329   2      
2330   2          send_flag = 1;
2331   2        }
2332   1        if ((1 == send_flag) && (0 == g_var_module.auto_retrieve_cyc_time))
2333   1        {
2334   2          send_flag = 0;
2335   2          g_var_module.retrieve_device_adr = 1;
2336   2          pop_menu_key_ctrl(0xf0); // 清除弹窗
2337   2          USER_PRINTF("-->auto add module over!\n");
2338   2        }
2339   1      }
2340          // 自动添加设备信息
2341          void auto_add_module(void)
2342          {
2343   1      
2344   1        unsigned char device_channel = 0;
2345   1        if (HR[DEVICE_INFOR_INDEX])
2346   1        {
2347   2          auto_module.index = find_index(0, MODULE_FLASH_SIZE, MODULE_NUB_LIMIT);
2348   2          device_channel = HR[DEVICE_INFOR_INDEX] & 0x0f;
2349   2          device_channel = device_channel > 14 ? 16 : device_channel;
2350   2          auto_module.adr = g_var_module.slave_adr;
2351   2          auto_module.channel_nb = device_channel;
2352   2          auto_module.data_sta = FULL;
2353   2          auto_module.type = (HR[DEVICE_INFOR_INDEX] >> 4) & 0x0f;
2354   2          sprintf(auto_module.module_name, "房间%bd", auto_module.adr);
2355   2          //    sprintf(auto_module.channel_name,"%s",default_module_channel_name);
2356   2          //    auto_module.module_name[strlen(auto_module.module_name)] = '\0';
2357   2      
2358   2          read_dgusii_vp(0xa008, (unsigned char *)&auto_module.channel_name, 8 * 16);
2359   2          // USER_PRINTF("-->auto_module.adr is %bd\n", auto_module.adr);
2360   2          // USER_PRINTF("-->auto_module.channel_nb is %bd\n", auto_module.channel_nb);
2361   2      
2362   2          //    snprintf(auto_module.channel_name, 256, auto_module.channel_name);
2363   2          //    USER_PRINTF("-->auto_module.adr is %s\n",auto_module.adr );
C51 COMPILER V9.60.0.0   MODULE                                                            11/04/2023 11:13:36 PAGE 40  

2364   2          //    USER_PRINTF("-->auto_module.adr is %bd\n",auto_module.adr );
2365   2          //    USER_PRINTF("-->auto_module.adr is %bd\n",auto_module.adr );
2366   2      
2367   2          norflash_write(auto_module.index * MODULE_FLASH_SIZE, (unsigned char *)&auto_module, MODULE_FLASH_SIZE);
             - // 存储flash
2368   2          write_dgusii_vp(0x3120 + 8 * auto_module.index, (unsigned char *)&auto_module.module_name, 8);           //
2369   2          display_module_information(&auto_module, auto_module.index);                                             // 显示模块信息
2370   2          USER_PRINTF("-->auto adding module successfully!\n");
2371   2          HR[DEVICE_INFOR_INDEX] = 0;
2372   2        }
2373   1      }
2374          #define BOARDCAST_ALL_ON_ADR 0X1B21
2375          #define BOARDCAST_ALL_OFF_ADR 0X1B22
2376          /**
2377           * @brief 模块控制广播全开全关
2378           * @return {*}
2379           */
2380          void module_all_ctrl(void)
2381          {
2382   1        unsigned short key_nb = 0;
2383   1        get_key_value(BOARDCAST_ALL_ON_ADR, &key_nb);
2384   1        if ((1 == key_nb))
2385   1        {
2386   2          set_master_send_hr(master_send_hr, 22, 0xffff);
2387   2          set_master_send_hr(master_send_hr, 23, (100));
2388   2          set_master_send_hr(master_send_hr, 24, (100));
2389   2          set_master_send_hr(master_send_hr, 25, (100));
2390   2          set_master_send_hr(master_send_hr, 26, (100));
2391   2          set_master_send_hr(master_send_hr, 27, ENTERPRISE);
2392   2          set_master_send_hr(master_send_hr, 28, 0);
2393   2          set_master_send_hr(master_send_hr, 29, 0);
2394   2          set_master_send_hr(master_send_hr, 30, 0);
2395   2          set_master_send_hr(master_send_hr, 31, 0xffff);
2396   2          set_master_send_hr(master_send_hr, 32, 0xffff);
2397   2          set_master_send_hr(master_send_hr, 33, ENTERPRISE);
2398   2          pack_data_send(&user_modbus, 0, MD_FR_MHR, 22, 13);
2399   2          clear_key_value(BOARDCAST_ALL_ON_ADR, &key_nb);
2400   2        }
2401   1        get_key_value(BOARDCAST_ALL_OFF_ADR, &key_nb);
2402   1        if ((1 == key_nb))
2403   1        {
2404   2          set_master_send_hr(master_send_hr, 22, 0xffff);
2405   2          set_master_send_hr(master_send_hr, 23, (0));
2406   2          set_master_send_hr(master_send_hr, 24, (0));
2407   2          set_master_send_hr(master_send_hr, 25, (0));
2408   2          set_master_send_hr(master_send_hr, 26, (0));
2409   2          set_master_send_hr(master_send_hr, 27, ENTERPRISE);
2410   2          set_master_send_hr(master_send_hr, 28, 0);
2411   2          set_master_send_hr(master_send_hr, 29, 0);
2412   2          set_master_send_hr(master_send_hr, 30, 0);
2413   2          set_master_send_hr(master_send_hr, 31, 0xffff);
2414   2          set_master_send_hr(master_send_hr, 32, 0);
2415   2          set_master_send_hr(master_send_hr, 33, ENTERPRISE);
2416   2          pack_data_send(&user_modbus, 0, MD_FR_MHR, 22, 13);
2417   2          clear_key_value(BOARDCAST_ALL_OFF_ADR, &key_nb);
2418   2        }
2419   1      }
2420          /**
2421           * @brief 返回页面
2422           * @return {*}
2423           */
2424          void return_page(void)
C51 COMPILER V9.60.0.0   MODULE                                                            11/04/2023 11:13:36 PAGE 41  

2425          {
2426   1        unsigned short key_nb = 0;
2427   1        get_key_value(0x1b23, &key_nb);
2428   1        if (key_nb)
2429   1        {
2430   2          pic_page = key_nb;
2431   2          clear_key_value(0x1b23, &key_nb);
2432   2        }
2433   1        get_key_value(0x1b24, &key_nb);
2434   1        if (1 == key_nb)
2435   1        {
2436   2          pic_set(pic_page);
2437   2          USER_PRINTF("-->%bd\n", pic_page);
2438   2          clear_key_value(0x1b24, &key_nb);
2439   2        }
2440   1      }
2441          // 模块配置
2442          void module_modify(void)
2443          {
2444   1        unsigned short page = 0;
2445   1        unsigned short size_struct = 0;
2446   1        page = read_pic();
2447   1        size_struct = sizeof(module_t);
2448   1        /*module edit page*/
2449   1        if (((page <= 16) && (page >= 5)) || (page == 63) || (page == 64) || ((page <= SCR_MODULE_4_CHANNEL_EDIT_
             -PAGE) && (page >= SINGLE_MODULE_4_CHANNEL_EDIT_PAGE)))
2450   1        {
2451   2          //    USER_PRINTF("-->page is %d\n", page);
2452   2          set_module_type();
2453   2          save_module_information(&module);
2454   2        }
2455   1        // set_selected_sequence_number(0x110c, 0x1104, 8);
2456   1        set_box_select(0x110c, 0x1400, 64, &module_key_nb_bak, &module_select_sta_bak);
2457   1        modifying_module_information(&module);
2458   1        clear_select_module_information();
2459   1        clear_all_module_information();
2460   1        timing_module_parameter_key_ctrl(&module, channel_number);
2461   1        display_timing_module_parameter(&module, channel_number);
2462   1        select_either_or_all();
2463   1        starup_page_pwd(read_dgus(PWD_SELECT_FRAME_ADR));
2464   1        change_pwd(&init_pwd);
2465   1        select_beep_enable();
2466   1        back_light_set();
2467   1      
2468   1        black_screen_switches_to_home_page();
2469   1        batch_set_time_parameters();
2470   1        automatically_retrieve_cmd();
2471   1        module_all_ctrl();
2472   1        return_page();
2473   1      }
2474          
2475          /**
2476           * @brief 初始化flash参数
2477           * @return {*}
2478           */
2479          void init_flash_parameters(void)
2480          {
2481   1        init_pwd_f();
2482   1        init_beep_enable();
2483   1        init_back_light_parameters();
2484   1        USER_PRINTF("-->read_flash_successfully\n");
2485   1        g_var_module.batch_set_parameters_flag = 0;
C51 COMPILER V9.60.0.0   MODULE                                                            11/04/2023 11:13:36 PAGE 42  

2486   1        g_var_module.retrieve_device_adr = 1;
2487   1        g_var_module.beep_enable_bak = 0xff;
2488   1        g_var_module.backlight_enable_bak = 0xff;
2489   1        g_var_module.pwd_enable_bak = 0xff;
2490   1      }
2491          /**
2492           * @brief 模拟按压触发
2493           * @return {*}
2494           */
2495          void simulate_touch(void)
2496          {
2497   1        unsigned short cmd = 0;
2498   1        write_dgus(0xd4, 0x5aa5);
2499   1        cmd = read_dgus(0xd4);
2500   1      
2501   1        write_dgus(0x00D5, 0x0001);
2502   1        write_dgus(0x00D6, 0x03E8);
2503   1        write_dgus(0x00D7, 0x03E8);
2504   1      
2505   1        while (cmd)
2506   1        {
2507   2          cmd = read_dgus(0xd4);
2508   2        }
2509   1      
2510   1        write_dgus(0xd4, 0x5aa5);
2511   1        write_dgus(0x00D5, 0x0002);
2512   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  14144    ----
   CONSTANT SIZE    =   1375    ----
   XDATA SIZE       =   2137     581
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
