C51 COMPILER V9.60.0.0   MODULE                                                            11/02/2023 18:49:06 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MODULE
OBJECT MODULE PLACED IN .\OBJ\module.obj
COMPILER INVOKED BY: C:\Keil_C51\C51\BIN\C51.EXE module.c LARGE OMF2 OPTIMIZE(9,SIZE) BROWSE INCDIR(..\USER;..\FUNC_HAND
                    -LER;..\GUI_APP) DEBUG PRINT(.\OBJ\module.lst) TABS(2) OBJECT(.\OBJ\module.obj)

line level    source

   1          /*
   2           * @Author: xw.qu
   3           * @Date: 2023-08-31 09:22:42
   4           * @LastEditors: xw.qu
   5           * @LastEditTime: 2023-11-02 18:49:04
   6           * @FilePath: \USER\module.c
   7           * @Description: relay module configuration
   8           *
   9           * Copyright (c) 2023 by xw.qu, All Rights Reserved.
  10           */
  11          #include "module.h"
  12          #include "Uart.h"
  13          #include "T5LLIB.h"
  14          #include "T5lOS8051.h"
  15          v_module_t g_var_module;
  16          #define DEVICE_NB 10
  17          #define DEVICE_INFOR_INDEX 14
  18          u16 xdata num4 = 4;
  19          unsigned char modfity_index = 0;
  20          unsigned char var_previous_page = 0;
  21          static unsigned char para_set_fun = 0;
  22          unsigned char channel_number = 0;
  23          unsigned short module_key_nb_bak = 0;
  24          unsigned char module_select_sta_bak = 0;
  25          unsigned short temp_adr = 0;
  26          unsigned short init_pwd = 8888; // default password
  27          module_t module = {
  28              {1},
  29              {2},
  30              {0},
  31              {0},
  32              {1},
  33              {4},
  34              {"房间1"}, // 普通模块
  35              {"通道1           通道2           通道3           通道4           通道5           通道6           通道7 
             -          通道8           通道9           通道10          通道11          通道12          通道13          通道14        
             -  通道15          通道16          "},
  36          };
  37          module_t auto_module = {
  38              {1},
  39              {2},
  40              {0},
  41              {0},
  42              {1},
  43              {4},
  44              {0}, // 普通模块
  45              {"通道1           通道2           通道3           通道4           通道5           通道6           通道7 
             -          通道8           通道9           通道10          通道11          通道12          通道13          通道14        
             -  通道15          通道16          "},
  46          };
  47          module_t st_module = {
  48              {1},
  49              {2},
  50              {0},
C51 COMPILER V9.60.0.0   MODULE                                                            11/02/2023 18:49:06 PAGE 2   

  51              {0},
  52              {1},
  53              {4},
  54              {"房间1"}, // 普通模块
  55              {"通道1           通道2           通道3           通道4           通道5           通道6           通道7 
             -          通道8           通道9           通道10          通道11          通道12          通道13          通道14        
             -  通道15          通道16          "},
  56          };
  57          module_t timing_module = {
  58              {0},
  59              {0},
  60              {0},
  61              {0},
  62              {0},
  63              {0},
  64              {"房间1"}, // 普通模块
  65              {"通道1           通道2           通道3           通道4           通道5           通道6           通道7 
             -          通道8           通道9           通道10          通道11          通道12          通道13          通道14        
             -  通道15          通道16          "},
  66          };
  67          module_t temp_module = {
  68              {0},
  69              {0},
  70              {0},
  71              {0},
  72              {0},
  73              {0},
  74              {"房间1"}, // 普通模块
  75              {"通道1           通道2           通道3           通道4           通道5           通道6           通道7 
             -          通道8           通道9           通道10          通道11          通道12          通道13          通道14        
             -  通道15          通道16          "},
  76          };
  77          unsigned char module_tab[10] = {
  78              1, 2, 3, 4, 5, 6, 7, 8, 9, 10
  79              //  {2},
  80              //  {0},
  81              //  {0},
  82              //  {1},
  83              //  {4},
  84              //  {"房间1"},         //普通模块
  85              //  {"通道1","通道2","通道3","通道4","通道5","通道6","通道7","通道8","通道9","通道10","通道11","通道12","
             -通道13","通道14","通道15","通道16"},
  86          
  87          };
  88          // bit key_flag = 0;
  89          unsigned short xdata key, num_return;
  90          unsigned short xdata channel = 0;
  91          unsigned short module_type = 0, module_type_bak = 0;
  92          unsigned short adr = 0;
  93          void timing_module_parameter_week_enable_channel_send(struct this_module *p, unsigned char channel, unsign
             -ed char state);
  94          void timing_module_parameter_solar_channel_send(struct this_module *p, unsigned char channel, unsigned cha
             -r state);
  95          void timing_module_parameter_time_frame_channel_send(struct this_module *p, unsigned char channel, unsigne
             -d char state);
  96          void timing_module_parameter_ongitude_latitude_send(struct this_module *p);
  97          void timing_module_parameter_time_send(struct this_module *p);
  98          unsigned char check_or_not_frame(unsigned short adr);
  99          // void (*timing_module_parameter_set_send)(struct   this_module* xdata p,unsigned char channel,unsigned c
             -har state);
 100          // void (*fun)(module_t* p,unsigned char channel,unsigned char state);
 101          
C51 COMPILER V9.60.0.0   MODULE                                                            11/02/2023 18:49:06 PAGE 3   

 102          // code  void (*p_fun_tab[5])( struct   this_module xdata * p,unsigned char xdata channel,unsigned char xd
             -ata state) =
 103          //{
 104          //  timing_module_parameter_ongitude_latitude_send,
 105          //  timing_module_parameter_time_send,
 106          //  timing_module_parameter_week_enable_channel_send,
 107          //  timing_module_parameter_solar_channel_send,
 108          //  timing_module_parameter_time_frame_channel_send,
 109          
 110          //};
 111          // unsigned char *p_module_name;
 112          unsigned char xdata module_default_name[17] = {
 113              "房间1"};
 114          unsigned char xdata module_no_name[17] = {
 115              ""};
 116          unsigned char xdata module_name_tab[6][13] = {
 117              "普通模块    ", // 普通模块
 118              "时控模块    ", // 时控模块
 119              "调光模块    ", // 调光模块
 120              "可控硅模块  ", // 可控硅模块
 121              "双层普通模块", // 双层普通模块
 122              "双层时控模块", // 双层时控模块
 123          
 124          };
 125          
 126          unsigned char default_module_channel_name[16][16] = {
 127              {"通道1"},
 128              {"通道2"},
 129              {"通道3"},
 130              {"通道4"},
 131              {"通道5"},
 132              {"通道6"},
 133              {"通道7"},
 134              {"通道8"},
 135              {"通道9"},
 136              {"通道10"},
 137              {"通道11"},
 138              {"通道12"},
 139              {"通道13"},
 140              {"通道14"},
 141              {"通道15"},
 142              {"通道16"},
 143          };
 144          
 145          // 获取键值
 146          void get_key_value(unsigned short adr, unsigned short *key_value)
 147          {
 148   1        read_dgusii_vp(adr, (unsigned char *)key_value, 1);
 149   1      }
 150          // 键值清0
 151          void clear_key_value(unsigned short adr, unsigned short *key_value)
 152          {
 153   1        unsigned short key_zero = 0;
 154   1        USER_PRINTF("<--0x%x  key_value is---%d\n", adr, *key_value);
 155   1        write_dgusii_vp(adr, (unsigned char *)&key_zero, 1);
 156   1        //  key_flag = 1;
 157   1      }
 158          // 触摸状态清0
 159          void clear_touch_sta(void)
 160          {
 161   1        unsigned char tab_zero[8] = {0};
 162   1        write_dgusii_vp(0x16, (unsigned char *)&tab_zero, 4);
C51 COMPILER V9.60.0.0   MODULE                                                            11/02/2023 18:49:06 PAGE 4   

 163   1        //  key_flag = 1;
 164   1      }
 165          // 查找数据是否存在
 166          unsigned char check_whether_data_exists(unsigned int adr_start, unsigned char index, unsigned char flash_b
             -lock)
 167          {
 168   1        unsigned char ch_data = 0;
 169   1        unsigned char tab_data[4] = {0};
 170   1        norflash_read(index * flash_block + adr_start, tab_data, 2);
 171   1        //  printf_tab(4,tab_data);
 172   1        if (0 == tab_data[0])
 173   1        {
 174   2          ch_data = BLANK;
 175   2          // USER_PRINTF("<--index %bd is blank \n", index);
 176   2        }
 177   1        else
 178   1          ch_data = FULL;
 179   1      
 180   1        return ch_data;
 181   1      }
 182          
 183          // 返回空白数据序号
 184          unsigned short find_index(unsigned int adr_start, unsigned char flash_size, unsigned short quantity)
 185          {
 186   1        unsigned short index = 0;
 187   1        for (index = 0; index < quantity; index++)
 188   1        {
 189   2          if (BLANK == check_whether_data_exists(adr_start, index, flash_size))
 190   2          {
 191   3            return index;
 192   3          }
 193   2        }
 194   1        return 0xff;
 195   1      }
 196          // void set_channel_name_default(unsigned short adr)
 197          // {
 198          
 199          // }
 200          // void return_to_previous_page(unsigned char page)
 201          //{
 202          //  pic_set(page);
 203          // }
 204          // 设置模块信息
 205          void set_module_information(module_t *p, unsigned char index, unsigned short module_type)
 206          {
 207   1        unsigned short temp = 0;
 208   1        //  p->data_sta = 1;
 209   1        //  unsigned char data_sta;
 210   1        //  unsigned char index;
 211   1        //  unsigned char reserve;
 212   1        //  unsigned char type;
 213   1        //  unsigned char adr;
 214   1        //  unsigned char channel_nb;
 215   1        //  unsigned char module_name[16];
 216   1        //  unsigned char channel_name[16][16];
 217   1        //  unsigned char index = 0 ;
 218   1        //  for(index = 0;index<MODULE_NUB_LIMIT;index++)
 219   1        //  {
 220   1        //    if( BLANK == check_whether_data_exists(index))
 221   1        //    {
 222   1        //      save_module_information(p,index);
 223   1        // memset(p,0,sizeof(module_t));
C51 COMPILER V9.60.0.0   MODULE                                                            11/02/2023 18:49:06 PAGE 5   

 224   1        p->index = index;
 225   1        read_dgusii_vp(0x2000, (unsigned char *)&temp, 1);
 226   1        p->adr = (unsigned char)temp;
 227   1        read_dgusii_vp(0x1002, (unsigned char *)&temp, 1);
 228   1        p->channel_nb = (unsigned char)temp;
 229   1        // USER_PRINTF("-->module_name is %s;\n",p->module_name);
 230   1        read_dgusii_vp(0x3000, (unsigned char *)&p->module_name, 8);
 231   1        // printf_tab(16,(unsigned char *)&p->module_name);
 232   1        // USER_PRINTF("-->module_name is %s;\n",p->module_name);
 233   1      
 234   1        // removeWhitespace(p->module_name);
 235   1        // USER_PRINTF("-->module_name is %s;\n",p->module_name);
 236   1        read_dgusii_vp(0x3008, (unsigned char *)&p->channel_name, 128);
 237   1        p->data_sta = FULL;
 238   1        p->type = module_type;
 239   1        //  USER_PRINTF("P->TYEP is %d\n",module_type);
 240   1        //      break;
 241   1        //    }
 242   1        //  }
 243   1      }
 244          // 显示模块信息
 245          void display_module_information(module_t *p, unsigned char index)
 246          {
 247   1        unsigned char mod_infom_tab[64] = {0};
 248   1        unsigned char module_name_1[13] = {0};
 249   1        //  USER_PRINTF("-->module type is %bd\n",p->type);
 250   1        if (p->type <= 2)
 251   1        {
 252   2          strncpy(module_name_1, &module_name_tab[p->type], 8);
 253   2        }
 254   1        else if (p->type == 3)
 255   1        {
 256   2          strncpy(module_name_1, &module_name_tab[p->type], 10);
 257   2        }
 258   1        else
 259   1        {
 260   2          strncpy(module_name_1, &module_name_tab[p->type], 12);
 261   2        }
 262   1        //  USER_PRINTF("-->module_name is %s;\n", p->module_name);
 263   1        strrpl(p->module_name, " ", "");
 264   1        // strrpl(p->module_name, "  ", "");
 265   1      
 266   1        // sprintf(mod_infom_tab, "类型:%s,模块:%.16s,地址:%bd,通道:%bd", module_name_1, p->module_name, p->adr, 
             -p->channel_nb);
 267   1        sprintf(mod_infom_tab, "类型:%s,地址:%bd,通道:%bd,模块:%s", module_name_1, p->adr, p->channel_nb, p->modu
             -le_name);
 268   1        //  USER_PRINTF("-->mod_infom_tab is %s\n", mod_infom_tab);
 269   1        //  USER_PRINTF("-->p->index %bd\n", p->index);
 270   1        write_dgusii_vp(0x3520 + index * 32, (unsigned char *)mod_infom_tab, 32);
 271   1      }
 272          // 是否存在重复地址
 273          //  unsigned char if_adr_repeat(unsigned char edit_sta,unsigned char adr,unsigned char *p)
 274          //  {
 275          //    switch (edit_sta)
 276          //    {
 277          //      case ADD:
 278          //      if(find_nub_index(p,adr))
 279          //      {
 280          //        USER_PRINTF("--> adr already exist\n!");
 281          //        USER_PRINTF("--> save module information fail!\n");
 282          //        return 1;
 283          //      }
C51 COMPILER V9.60.0.0   MODULE                                                            11/02/2023 18:49:06 PAGE 6   

 284          //      break;
 285          //      case MODIFY:
 286          //      if(find_nub_index(p,adr))
 287          //      {
 288          //        USER_PRINTF("--> adr already exist\n!");
 289          //        USER_PRINTF("--> save module information fail!\n");
 290          //        return 1;
 291          //      }
 292          //      break;
 293          //      default:
 294          //      break;
 295          //    }
 296          //    return 0;
 297          
 298          // }
 299          // 存储模块信息
 300          void save_module_information(module_t *p)
 301          {
 302   1        // unsigned short key_nb1 = 0;
 303   1        unsigned short key_nb2 = 0;
 304   1        //  static unsigned char temp_index = 0;
 305   1        // read_dgusii_vp(0x1009, (unsigned char *)&key_nb1, 1);
 306   1        // if (1 == key_nb1)//添加模块
 307   1        // {
 308   1        //  key_nb1 = 0;
 309   1        //  write_dgusii_vp(0x1009, (unsigned char *)&key_nb1, 1);
 310   1        //  USER_PRINTF("-->ctrl_mgmt_sta\n");
 311   1        //  modfity_index = find_index(0, MODULE_FLASH_SIZE, MODULE_NUB_LIMIT);
 312   1        //  if(OVERFLOW_SIZE == modfity_index)
 313   1        //  {
 314   1        //    USER_PRINTF("-->waring! too many module \n");
 315   1        //    pop_menu_key_ctrl(OVERFLOW_WARING_CODE);
 316   1        //    return;
 317   1        //  }
 318   1        //  pic_set(MODULE_ADD_PAGE);
 319   1        //  //    USER_PRINTF("<--get_blank_index -->%bd\n", modfity_index);
 320   1        //  write_dgusii_vp(0x3110, (unsigned char *)&module_name_tab[0], 6);
 321   1        //  write_dgusii_vp(0x3008, (unsigned char *)&default_module_channel_name, 256);
 322   1        //  write_dgusii_vp(0x3000, (unsigned char *)module_default_name, 8);
 323   1        //  write_dgus(0X1000, 4);
 324   1        // }
 325   1        sys_delay_about_ms(5);
 326   1        read_dgusii_vp(0x1006, (unsigned char *)&key_nb2, 1);
 327   1        // if (key_nb2)
 328   1        // {
 329   1        //  USER_PRINTF("-->key_value ---%d\n", key_nb2);
 330   1        // }
 331   1        if ((4 == key_nb2) || (6 == key_nb2) || (8 == key_nb2) || (10 == key_nb2) || (12 == key_nb2) || (14 == ke
             -y_nb2) || (16 == key_nb2) || (0x14 == key_nb2) || (0x24 == key_nb2))
 332   1        {
 333   2          key_nb2 = 0;
 334   2          sys_delay_about_ms(1);
 335   2          write_dgusii_vp(0x1006, (unsigned char *)&key_nb2, 1);
 336   2          printf_tab(20, &g_var_module.module_adr[0]);
 337   2          read_dgusii_vp(0x2000, (unsigned char *)&temp_adr, 1);
 338   2          sys_delay_about_ms(2);
 339   2          if (find_nub_index(&g_var_module.module_adr[0], temp_adr))
 340   2          {
 341   3            pop_menu_key_ctrl(0x1f);
 342   3            USER_PRINTF("--> adr already exist!\n");
 343   3            USER_PRINTF("--> save module information fail!\n");
 344   3            return;
C51 COMPILER V9.60.0.0   MODULE                                                            11/02/2023 18:49:06 PAGE 7   

 345   3          }
 346   2          set_module_information(p, modfity_index, (unsigned char)module_type_bak);
 347   2          //    USER_PRINTF("-->module_type_bak is %d\n",module_type_bak);
 348   2      
 349   2          add_arr_data(&g_var_module.module_adr[0], p->adr, modfity_index);
 350   2      
 351   2          norflash_write(modfity_index * MODULE_FLASH_SIZE, (unsigned char *)p, MODULE_FLASH_SIZE);
 352   2          write_dgusii_vp(0x3120 + 8 * modfity_index, (unsigned char *)p->module_name, 8);
 353   2          display_module_information(p, modfity_index);
 354   2          USER_PRINTF("-->save_module_information_ok\n");
 355   2          if (modfity_index >= 5)
 356   2          {
 357   3            pic_page = 88 + modfity_index / 5 - 1;
 358   3            pic_set(pic_page);
 359   3          }
 360   2          else
 361   2          {
 362   3            pic_page = 2;
 363   3            pic_set(pic_page);
 364   3          }
 365   2          module_type_bak = 0;
 366   2        }
 367   1        else if (0xff == key_nb2)
 368   1        {
 369   2          key_nb2 = 0;
 370   2          sys_delay_about_ms(1);
 371   2          write_dgusii_vp(0x1006, (unsigned char *)&key_nb2, 1);
 372   2          pic_set(pic_page);
 373   2          // if (modfity_index >= 5)
 374   2          // {
 375   2          //  pic_set(88 + modfity_index / 5 - 1);
 376   2          // }
 377   2          // else
 378   2          // {
 379   2          //  pic_set(2);
 380   2          // }
 381   2        }
 382   1      
 383   1        //  sys_delay_about_ms(10);//这个延时必须加,可以防止莫名其妙的错误
 384   1      }
 385          // 设置模块选中序号 touch_key_adr-0x110c; select_key_adr-0x1104
 386          void set_selected_sequence_number(unsigned short touch_key_adr, unsigned short select_key_adr, unsigned ch
             -ar page_nb)
 387          {
 388   1        unsigned short key_nb = 0;
 389   1        static unsigned char select_sta = 0;
 390   1        static unsigned char page = 0;
 391   1        unsigned char i = 0;
 392   1        get_key_value(touch_key_adr, &key_nb);
 393   1        if ((key_nb))
 394   1        {
 395   2          for (i = 0; i < page_nb; i++)
 396   2          {
 397   3            write_dgus(select_key_adr + i, 0);
 398   3          }
 399   2          if (page != ((key_nb - 1) / 8))
 400   2          {
 401   3            page = (key_nb - 1) / 8;
 402   3            select_sta = 0;
 403   3          }
 404   2          select_sta = select_sta == (key_nb - (page * 8)) ? ((select_sta > 0) ? 0 : (key_nb - (page * 8))) : (key
             -_nb - (page * 8));
C51 COMPILER V9.60.0.0   MODULE                                                            11/02/2023 18:49:06 PAGE 8   

 405   2          // USER_PRINTF("-->set_select_sta is--%bd\n", select_sta);
 406   2          write_dgus(select_key_adr + (key_nb - 1) / 8, select_sta);
 407   2          clear_key_value(touch_key_adr, &key_nb);
 408   2        }
 409   1      }
 410          /**
 411           * @brief 设置选择框
 412           * @param {unsigned short} touch_key_adr 按键地址
 413           * @param {unsigned short} select_key_adr 框地址
 414           * @param {unsigned char} nb 数量
 415           * @param {unsigned short} *p_key_nb_bak 按键值备份
 416           * @param {unsigned char} *p_select_sta  框选备份
 417           * @return {*}
 418           */
 419          void set_box_select(unsigned short touch_key_adr, unsigned short select_key_adr, unsigned char nb, unsigne
             -d short *p_key_nb_bak, unsigned char *p_select_sta)
 420          {
 421   1        unsigned short key_nb = 0;
 422   1        // static unsigned short key_nb_bak = 0;
 423   1        // static unsigned char select_sta = 0;
 424   1        unsigned char i = 0;
 425   1        get_key_value(touch_key_adr, &key_nb);
 426   1      
 427   1        if ((key_nb)) // 按键触发
 428   1        {
 429   2          for (i = 0; i < nb; i++)
 430   2          {
 431   3            if (i == key_nb - 1)
 432   3            {
 433   4              continue;
 434   4            }
 435   3            write_dgus(select_key_adr + i, 0); // 除了触发的框其他都写0
 436   3          }
 437   2          if (*p_key_nb_bak != key_nb)
 438   2          {
 439   3            *p_key_nb_bak = key_nb;
 440   3            *p_select_sta = 0;
 441   3          }
 442   2          // USER_PRINTF("-->set_select_sta before is--%bd\n", select_sta);
 443   2          *p_select_sta ^= 1;
 444   2          // USER_PRINTF("-->set_select_sta after is--%bd\n", select_sta);
 445   2          write_dgus(select_key_adr + (key_nb - 1), *p_select_sta);
 446   2          clear_key_value(touch_key_adr, &key_nb);
 447   2        }
 448   1      }
 449          
 450          // 获取模块选中序号 0x1104
 451          
 452          unsigned char get_box_select_number(unsigned short select_key_adr, unsigned char nb)
 453          {
 454   1        unsigned char i = 0;
 455   1        unsigned char seq_nb = 0;
 456   1        for (i = 0; i < nb; i++)
 457   1        {
 458   2          seq_nb = read_dgus(select_key_adr + i);
 459   2          if (seq_nb)
 460   2          {
 461   3            seq_nb = seq_nb + i;
 462   3            // USER_PRINTF("-->get_select_sta is--%bd\n", seq_nb);
 463   3            return (seq_nb);
 464   3          }
 465   2        }
C51 COMPILER V9.60.0.0   MODULE                                                            11/02/2023 18:49:06 PAGE 9   

 466   1        return 0;
 467   1      }
 468          unsigned char get_selected_sequence_number(unsigned short select_key_adr, unsigned char page)
 469          {
 470   1        unsigned char i = 0;
 471   1        unsigned char seq_nb = 0;
 472   1        for (i = 0; i < page; i++)
 473   1        {
 474   2          seq_nb = read_dgus(select_key_adr + i);
 475   2          if (seq_nb)
 476   2          {
 477   3            seq_nb = seq_nb + i * 8;
 478   3            // USER_PRINTF("-->get_select_sta is--%bd\n", seq_nb);
 479   3            return (seq_nb);
 480   3          }
 481   2        }
 482   1        return 0;
 483   1      }
 484          void delay_us(unsigned short t)
 485          {
 486   1        char i;
 487   1        while (t)
 488   1        {
 489   2          for (i = 0; i < 50; i++)
 490   2          {
 491   3            i = i;
 492   3          }
 493   2          t--;
 494   2        }
 495   1      }
 496          // 读所在页面值
 497          unsigned short read_pic(void)
 498          {
 499   1        unsigned short pic = 0;
 500   1        pic = read_dgus(0x0014);
 501   1        sys_delay_about_ms(2);
 502   1        return pic;
 503   1      }
 504          
 505          // 页面切换
 506          void pic_set(unsigned int pic) // pic为跳转到的页面
 507          {
 508   1        unsigned short run_num = 0;
 509   1        run_num = 0x5A01;
 510   1        write_dgusii_vp(0x0085, (unsigned char *)&pic, 1);
 511   1        write_dgusii_vp(0x0084, (unsigned char *)&run_num, 1);
 512   1        while (run_num >> 8) // 看高八位5A是否清零
 513   1        {
 514   2          read_dgusii_vp(0x0084, (unsigned char *)&run_num, 1);
 515   2          delay_us(3000); //**********
 516   2        }
 517   1      }
 518          // 设置通道数量
 519          void set_channel_nb(void)
 520          {
 521   1        read_dgusii_vp(0x1000, (unsigned char *)&channel, 1);
 522   1      
 523   1        //  USER_PRINTF("channel value ---- %d\n",channel);
 524   1        {
 525   2          switch (channel)
 526   2          {
 527   3          case 0:
C51 COMPILER V9.60.0.0   MODULE                                                            11/02/2023 18:49:06 PAGE 10  

 528   3            //        write_dgusii_vp(0x1002,(unsigned char *)&num4,1);
 529   3            //      display_icon();
 530   3            break;
 531   3          case 4:
 532   3            //        channel_bak = 0;
 533   3            write_dgusii_vp(0x1002, (unsigned char *)&channel, 1);
 534   3            //        write_dgus(17,54);
 535   3            //        channel_bak = channel;
 536   3            break;
 537   3          case 6:
 538   3            //        channel_bak = 0;
 539   3            write_dgusii_vp(0x1002, (unsigned char *)&channel, 1);
 540   3            //        write_dgus(17,54);
 541   3            //        channel_bak = channel;
 542   3            break;
 543   3          case 8:
 544   3            //        channel_bak = 1;
 545   3            write_dgusii_vp(0x1002, (unsigned char *)&channel, 1);
 546   3            //        write_dgus(17,55);
 547   3            //        channel_bak = channel;
 548   3            break;
 549   3          case 10:
 550   3            //        channel_bak = 1;
 551   3            write_dgusii_vp(0x1002, (unsigned char *)&channel, 1);
 552   3            //        write_dgus(17,55);
 553   3            //        channel_bak = channel;
 554   3            break;
 555   3          case 12:
 556   3            //        channel_bak = 2;
 557   3            write_dgusii_vp(0x1002, (unsigned char *)&channel, 1);
 558   3            //        write_dgusii_vp(0x1003,(unsigned char*)&channel_bak,1);
 559   3            //        channel_bak = channel;
 560   3            break;
 561   3          case 14:
 562   3            //        channel_bak = 2;
 563   3            write_dgusii_vp(0x1002, (unsigned char *)&channel, 1);
 564   3            //        write_dgusii_vp(0x1003,(unsigned char*)&channel_bak,1);
 565   3            //        channel_bak = channel;
 566   3            break;
 567   3          case 16:
 568   3            //        channel_bak = 3;
 569   3            write_dgusii_vp(0x1002, (unsigned char *)&channel, 1);
 570   3            //        write_dgus(17,53);
 571   3            //        channel_bak = channel;
 572   3            break;
 573   3          default:
 574   3            //        write_dgusii_vp(0x1000,(unsigned char*)&channel_bak,1);
 575   3            break;
 576   3          }
 577   2        }
 578   1      }
 579          
 580          // 设置模块类型
 581          void set_module_type(void)
 582          {
 583   1      
 584   1        //  data_t* p;
 585   1        //  static char i = 0;
 586   1        //    //void write_dgusii_vp(unsigned int addr,unsigned char *buf,unsigned int len)
 587   1        //  read_dgusii_vp(0x3010,(unsigned char *)&num_test,8);
 588   1        //  read_dgusii_vp(0x1000,(unsigned char *)&num_return,1);
 589   1      
C51 COMPILER V9.60.0.0   MODULE                                                            11/02/2023 18:49:06 PAGE 11  

 590   1        //  num_test = 0X03;
 591   1        //  static unsigned short module_type = 0;
 592   1        unsigned short default_channel = 4;
 593   1        //  USER_PRINTF("touch key value ---- %d\n",key);
 594   1        read_dgusii_vp(0x1001, (unsigned char *)&module_type, 1);
 595   1        // if (module_type < 0xff)
 596   1        //  USER_PRINTF("-->MODULE_TYPE = %d\n", module_type);
 597   1        switch (module_type)
 598   1        {
 599   2        case 0:
 600   2          module_type_bak = 0;
 601   2          write_dgusii_vp(0x3110, (unsigned char *)&module_name_tab[module_type_bak], 6);
 602   2      
 603   2          //      set_channel_nb();
 604   2          //      write_dgusii_vp(0x1000,(unsigned char *)&default_channel,1);
 605   2          module_type = 0xff;
 606   2          write_dgusii_vp(0x1001, (unsigned char *)&module_type, 1);
 607   2          // USER_PRINTF("-->module_type_bak = %d\n", module_type_bak);
 608   2          break;
 609   2        case 1:
 610   2          module_type_bak = 0;
 611   2          write_dgusii_vp(0x3110, (unsigned char *)&module_name_tab[module_type_bak], 6);
 612   2          //      set_channel_nb();
 613   2          write_dgusii_vp(0x1000, (unsigned char *)&default_channel, 1);
 614   2          module_type = 0xff;
 615   2          write_dgusii_vp(0x1001, (unsigned char *)&module_type, 1);
 616   2          // USER_PRINTF("-->module_type_bak = %d\n", module_type_bak);
 617   2          break;
 618   2        case 2:
 619   2          module_type_bak = 1;
 620   2          write_dgusii_vp(0x3110, (unsigned char *)&module_name_tab[module_type_bak], 6);
 621   2          //      set_channel_nb();
 622   2          write_dgusii_vp(0x1000, (unsigned char *)&default_channel, 1);
 623   2          module_type = 0xff;
 624   2          write_dgusii_vp(0x1001, (unsigned char *)&module_type, 1);
 625   2          // USER_PRINTF("-->module_type_bak = %d\n", module_type_bak);
 626   2          break;
 627   2      
 628   2        case 3:
 629   2          module_type_bak = 2;
 630   2          write_dgusii_vp(0x3110, (unsigned char *)&module_name_tab[module_type_bak], 6);
 631   2          write_dgusii_vp(0x1000, (unsigned char *)&default_channel, 1);
 632   2          module_type = 0xff;
 633   2          write_dgusii_vp(0x1001, (unsigned char *)&module_type, 1);
 634   2          //      write_dgusii_vp(0x1002,(unsigned char *)&num4,1);
 635   2          // USER_PRINTF("-->module_type_bak = %d\n", module_type_bak);
 636   2          break;
 637   2        case 4:
 638   2          module_type_bak = 3;
 639   2          write_dgusii_vp(0x3110, (unsigned char *)&module_name_tab[module_type_bak], 6);
 640   2          write_dgusii_vp(0x1000, (unsigned char *)&default_channel, 1);
 641   2          module_type = 0xff;
 642   2          write_dgusii_vp(0x1001, (unsigned char *)&module_type, 1);
 643   2          //      USER_PRINTF("MODULE_TYPE = %bd\n",module_type);
 644   2          //      write_dgusii_vp(0x1002,(unsigned char *)&num4,1);
 645   2          //      write_dgusii_vp(0x1000,(unsigned char *)&num,1);
 646   2      
 647   2          //      enable_touch_set(72,9,0);
 648   2          // USER_PRINTF("-->module_type_bak = %d\n", module_type_bak);
 649   2          break;
 650   2        case 5:
 651   2          module_type_bak = 4;
C51 COMPILER V9.60.0.0   MODULE                                                            11/02/2023 18:49:06 PAGE 12  

 652   2          write_dgusii_vp(0x3110, (unsigned char *)&module_name_tab[module_type_bak], 6);
 653   2          write_dgusii_vp(0x1000, (unsigned char *)&default_channel, 1);
 654   2          module_type = 0xff;
 655   2          write_dgusii_vp(0x1001, (unsigned char *)&module_type, 1);
 656   2          //      write_dgusii_vp(0x1002,(unsigned char *)&num4,1);
 657   2          // USER_PRINTF("-->module_type_bak = %d\n", module_type_bak);
 658   2          //    pic_set(84);
 659   2          break;
 660   2        case 6:
 661   2          module_type_bak = 5;
 662   2          write_dgusii_vp(0x3110, (unsigned char *)&module_name_tab[module_type_bak], 6);
 663   2          write_dgusii_vp(0x1000, (unsigned char *)&default_channel, 1);
 664   2          module_type = 0xff;
 665   2          write_dgusii_vp(0x1001, (unsigned char *)&module_type, 1);
 666   2          //      write_dgusii_vp(0x1002,(unsigned char *)&num4,1);
 667   2          // USER_PRINTF("-->module_type_bak = %d\n", module_type_bak);
 668   2      
 669   2          //    pic_set(84);
 670   2          break;
 671   2        default:
 672   2      
 673   2          set_channel_nb();
 674   2          module_type = 0xff;
 675   2          write_dgusii_vp(0x1001, (unsigned char *)&module_type, 1);
 676   2          //    module_type_bak = 0;
 677   2          //    USER_PRINTF("-->module_type_bak = %d\n", module_type_bak);
 678   2          //      USER_PRINTF("module_type_default_run\n");
 679   2          //      USER_PRINTF("module_type_bak = %d\n",module_type_bak);
 680   2          //      write_dgusii_vp(0x3010,&module_p[0],8);
 681   2          break;
 682   2        }
 683   1        //  return 1;
 684   1      }
 685          // D7=年(0-0x63) D6=月(0-0x0C) D5=日(0-0x1F) D4=星期（0-0x6） D3=小时(0-0x17) D2=分钟(0-0x3B) D1=秒(0-0x3B
             -) D0 未定义
 686          void read_sys_time(unsigned char *p)
 687          {
 688   1        read_dgusii_vp(0x10, p, 4);
 689   1      }
 690          // 设置时间前读取一下时间
 691          void read_dgus_time(void)
 692          {
 693   1        unsigned short key_nb = 0;
 694   1        unsigned char rtc_parm[8] = {0};
 695   1        //  read_dgusii_vp(0x0010,(u8*)rtcdata,4);  //写入DGUS变量空间
 696   1      
 697   1        //  read_dgusii_vp(0x1008,(unsigned char *)&key_nb,1);
 698   1        get_key_value(0x1008, &key_nb);
 699   1        if (5 == key_nb)
 700   1        {
 701   2          //    USER_PRINTF(" key_value --->%d\n", key_nb);
 702   2          read_sys_time(rtc_parm);
 703   2          //    read_dgusii_vp(0x10,rtc_parm,4);
 704   2          // 重新排序rtc_parm[3] = week
 705   2          rtc_parm[3] = rtc_parm[4];
 706   2          rtc_parm[4] = rtc_parm[5];
 707   2          rtc_parm[5] = rtc_parm[6];
 708   2          rtc_parm[6] = rtc_parm[7];
 709   2          rtc_parm[7] = 0;
 710   2          printf_tab(8, rtc_parm);
 711   2          //    key_nb = 0;
 712   2          USER_PRINTF("-->read_dgus_time\n");
C51 COMPILER V9.60.0.0   MODULE                                                            11/02/2023 18:49:06 PAGE 13  

 713   2          read_dgus(0x10);
 714   2          //    write_dgusii_vp(0x1008,(unsigned char *)&key_nb,1);
 715   2          clear_key_value(0x1008, &key_nb);
 716   2          write_dgusii_vp(0x9d, rtc_parm, 4);
 717   2        }
 718   1      }
 719          /**
 720           * @brief 切换继电器模块显示界面
 721           * @param {module_t} *p模块指针
 722           * @param {unsigned char} relay_page继电器页面
 723           * @param {unsigned char} time_relay_page时控继电器页面
 724           * @param {unsigned char} *p_var_page记录当前页面
 725           * @return {*}
 726           */
 727          void relay_interface_trigger(module_t *p, unsigned char relay_page, unsigned char time_relay_page, unsigne
             -d char *p_var_page)
 728          {
 729   1        if ((DOUBLE_RELAY_MODULE == p->type) || (SINGLE_RELAY_MODULE == p->type))
 730   1        {
 731   2          pic_set(relay_page);
 732   2          *p_var_page = relay_page;
 733   2        }
 734   1        else
 735   1        {
 736   2          pic_set(time_relay_page);
 737   2          *p_var_page = time_relay_page;
 738   2        }
 739   1      }
 740          // 显示继电器模块界面
 741          void display_relay_interface(module_t *p)
 742          {
 743   1        write_dgus(0x4088, p->adr);
 744   1        //      write_dgusii_vp(0x4088,(unsigned char *)&p->adr,1);
 745   1        write_dgusii_vp(0x4000, (unsigned char *)&p->module_name, 8);
 746   1        write_dgusii_vp(0x4008, (unsigned char *)&p->channel_name, 8 * 16);
 747   1        switch (p->channel_nb)
 748   1        {
 749   2        case 4:
 750   2          relay_interface_trigger(p, 38, 31, &var_previous_page);
 751   2          break;
 752   2        case 6:
 753   2          relay_interface_trigger(p, 39, 32, &var_previous_page);
 754   2          break;
 755   2        case 8:
 756   2          relay_interface_trigger(p, 40, 33, &var_previous_page);
 757   2      
 758   2          break;
 759   2        case 10:
 760   2          relay_interface_trigger(p, 41, 34, &var_previous_page);
 761   2          break;
 762   2        case 12:
 763   2          relay_interface_trigger(p, 42, 35, &var_previous_page);
 764   2          break;
 765   2        case 14:
 766   2          relay_interface_trigger(p, 43, 36, &var_previous_page);
 767   2          break;
 768   2        case 16:
 769   2          relay_interface_trigger(p, 44, 37, &var_previous_page);
 770   2          break;
 771   2        default:
 772   2          break;
 773   2        }
C51 COMPILER V9.60.0.0   MODULE                                                            11/02/2023 18:49:06 PAGE 14  

 774   1      }
 775          // 显示调光模块界面
 776          void display_dim_interface(module_t *p)
 777          {
 778   1        write_dgus(0x4088, p->adr);
 779   1        //  write_dgusii_vp(0x4088,(unsigned char *)&p->adr,1);
 780   1        write_dgusii_vp(0x4000, (unsigned char *)&p->module_name, 8);
 781   1        write_dgusii_vp(0x4008, (unsigned char *)&p->channel_name, 8 * 16);
 782   1        switch (p->type)
 783   1        {
 784   2        case VOL_DIM_MODULE: // 普通调光
 785   2          pic_set(DIM_CTRL_PAGE);
 786   2          break;
 787   2        case SCR_DIM_MODULE: // 可控硅调光
 788   2          pic_set(SCR_CTRL_PAGE);
 789   2          break;
 790   2        default:
 791   2          break;
 792   2        }
 793   1      }
 794          /**
 795           * @brief 返回之前页面
 796           * @return {*}
 797           */
 798          void return_to_previous_page(void)
 799          {
 800   1        pic_set(var_previous_page);
 801   1      }
 802          /**
 803           * @brief 发送读取时间指令
 804           * @param {module_t} *p
 805           * @return {*}
 806           */
 807          void read_timing_module_parameter(module_t *p)
 808          {
 809   1        pack_data_send(&user_modbus, p->adr, MD_RD_HR, 35, 146);
 810   1      }
 811          /**
 812           * @brief 读取时间段设定
 813           * @param {module_t} *p
 814           * @return {*}
 815           */
 816          void read_timing_module_set_parameter(module_t *p)
 817          {
 818   1        unsigned short key_nb = 0;
 819   1        get_key_value(0x10dd, &key_nb);
 820   1        if (key_nb)
 821   1        {
 822   2          
 823   2          // USER_PRINTF("-->channel number is %bd\n", channel_number);
 824   2          if (0x12 != key_nb)
 825   2          {
 826   3            channel_number = key_nb;
 827   3            pack_data_send(&user_modbus, p->adr, MD_RD_HR, 35, 200); // 从35开始读200个
 828   3            g_var_module.read_time_set_para_flag = 1;
 829   3          }
 830   2      
 831   2          clear_key_value(0x10dd, &key_nb);
 832   2        }
 833   1      }
 834          // 显示模块假日参数
 835          void display_week_parameter(unsigned short week_enable_adr, unsigned char week_enable)
C51 COMPILER V9.60.0.0   MODULE                                                            11/02/2023 18:49:06 PAGE 15  

 836          {
 837   1        unsigned char i = 0;
 838   1        static unsigned char week_enable_bak = 0;
 839   1        if (week_enable_bak != week_enable)
 840   1        {
 841   2          week_enable_bak = week_enable;
 842   2          USER_PRINTF("-->week enable is %bd\n", week_enable);
 843   2          for (i = 0; i < 7; i++)
 844   2          {
 845   3            write_dgus(week_enable_adr + i, (week_enable >> i) & 0x01);
 846   3          }
 847   2        }
 848   1      }
 849          // 显示模块光照度参数
 850          void display_solar_parameter(unsigned short solar_adr, unsigned short solar_en_adr, unsigned char solar_en
             -able, unsigned char solar_up, unsigned char solar_down)
 851          {
 852   1        static unsigned char solar_down_bak = 15, solar_up_bak = 25, solar_en_bak = 0;
 853   1        if (solar_en_bak != solar_enable)
 854   1        {
 855   2          solar_en_bak = solar_enable;
 856   2          write_dgus(solar_en_adr, solar_enable);
 857   2        }
 858   1        if (solar_up_bak != solar_up)
 859   1        {
 860   2          solar_up_bak = solar_up;
 861   2          write_dgus(solar_adr + 1, solar_up);
 862   2        }
 863   1        if (solar_down_bak != solar_down)
 864   1        {
 865   2          solar_down_bak = solar_down;
 866   2          write_dgus(solar_adr, solar_down);
 867   2        }
 868   1      }
 869          
 870          // 显示模块时段参数
 871          void display_time_frame_parameter(unsigned short time_frame_adr, unsigned char *p_data)
 872          {
 873   1        static unsigned char time_frame_bak[16] = {18, 30, 6, 30, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
 874   1        unsigned char i = 0;
 875   1        for (i = 0; i < 16; i++)
 876   1        {
 877   2          if (time_frame_bak[i] != p_data[i])
 878   2          {
 879   3            time_frame_bak[i] = p_data[i];
 880   3            write_dgus(time_frame_adr + i, p_data[i]);
 881   3          }
 882   2        }
 883   1      }
 884          // 显示模块定时参数
 885          void display_timing_module_parameter(module_t *p, unsigned char channel)
 886          {
 887   1        unsigned short week_enable_adr = 0;
 888   1        unsigned char week_enable = 0;
 889   1        unsigned short solar_adr = 0;
 890   1        unsigned short solar_en_adr = 0;
 891   1        unsigned char solar_enable = 0;
 892   1        unsigned char solar_up = 0;
 893   1        unsigned char solar_down = 0;
 894   1        unsigned short time_frame_adr = 0;
 895   1        unsigned char p_data[17] = {0};
 896   1        if (SINGLE_TIME_PARA_SET_PAGE != read_pic())
C51 COMPILER V9.60.0.0   MODULE                                                            11/02/2023 18:49:06 PAGE 16  

 897   1          return;
 898   1        // USER_PRINTF("-->display_timing_module_parameter_page\n");
 899   1        if ((g_var_module.read_time_set_para_flag == 1) && (3 == mbh_getRecHookState()))
 900   1        {
 901   2          printf_tab(80,(unsigned char *)(HR+49));
 902   2          g_var_module.read_time_set_para_flag = 0;
 903   2          mbh_clearRecHookState();
 904   2          USER_PRINTF("-->read_time_para_successfully!\n");
 905   2          if ((DOUBLE_TIME_RELAY_MODULE == p->type) && (mbHost.errTimes < MBH_ERR_MAX_TIMES))
 906   2          {
 907   3            USER_PRINTF("-->double!\n");
 908   3            solar_enable = HR[200 + channel] >> 15 & 0x01;
 909   3            solar_up = HR[200 + channel] >> 8 & 0x7f;
 910   3            solar_down = HR[200 + channel] & 0xff;
 911   3            memcpy(p_data, (unsigned char *)(HR + 53 + (channel - 1) * 8), 16);
 912   3          }
 913   2          else if ((SINGLE_TIME_RELAY_MODULE == p->type) && (mbHost.errTimes < MBH_ERR_MAX_TIMES))
 914   2          {
 915   3            USER_PRINTF("-->single!\n");
 916   3            // USER_PRINTF("-->current channel is %bd!\n",channel);
 917   3            solar_enable = (HR[160 + channel] >> 15) & 0x01;
 918   3            solar_up = (HR[160 + channel] >> 8) & 0x7f;
 919   3            solar_down = HR[160 + channel] & 0xff;
 920   3            USER_PRINTF("-->current solar_up is %bd!\n",solar_up);
 921   3            USER_PRINTF("-->current solar_down is %bd!\n",solar_down);
 922   3            USER_PRINTF("-->current time_frame is %d!\n",HR[49]);
 923   3            memcpy(p_data, (unsigned char *)(HR + 49 + (channel - 1) * 8), 16);
 924   3          }
 925   2          else
 926   2          {
 927   3          }
 928   2          week_enable = ~HR[34 + channel];
 929   2          week_enable_adr = 0x10de;
 930   2          solar_en_adr = 0x10ed;
 931   2          solar_adr = 0x201d;
 932   2          time_frame_adr = 0x201f;
 933   2          write_dgus(0x201c, channel);
 934   2          //  USER_PRINTF("-->solar_enable is %bd\n",solar_enable);
 935   2          //  USER_PRINTF("-->solar_up is %bd\n",solar_up);
 936   2          //  USER_PRINTF("-->solar_down is %bd\n",solar_down);
 937   2          //  printf_tab(16,p_data);
 938   2          //  USER_PRINTF("-->solar_enable is %bd\n",solar_enable);
 939   2          display_week_parameter(week_enable_adr, week_enable);
 940   2          display_solar_parameter(solar_adr, solar_en_adr, solar_enable, solar_up, solar_down);
 941   2          display_time_frame_parameter(time_frame_adr, p_data);
 942   2        }
 943   1      }
 944          // 通道设置
 945          unsigned short get_channel_set(struct this_module *p, unsigned char channel, unsigned char state)
 946          {
 947   1        unsigned short channel_enable = 0;
 948   1        switch (state)
 949   1        {
 950   2        case SINGLE_CHANNEL_STATE:
 951   2        case BATCH_CHANNEL_STATE:
 952   2          if ((DOUBLE_TIME_RELAY_MODULE == p->type))
 953   2          {
 954   3            channel_enable = (1 << channel) & 0xffff;
 955   3          }
 956   2          else
 957   2          {
 958   3            channel_enable = ((1 << (channel + 3)) | 0X08) & 0xffff;
C51 COMPILER V9.60.0.0   MODULE                                                            11/02/2023 18:49:06 PAGE 17  

 959   3          }
 960   2          break;
 961   2        case SINGLE_CHANNELS_STATE:
 962   2        case BATCH_CHANNELS_STATE:
 963   2          channel_enable = 0xffff;
 964   2          break;
 965   2        }
 966   1        return channel_enable;
 967   1      }
 968          // 假日设置
 969          void timing_module_parameter_week_enable_channel_send(struct this_module *p, unsigned char channel, unsign
             -ed char state)
 970          {
 971   1        unsigned char week_adr_start = 0;
 972   1        unsigned char week_adr_end = 0;
 973   1        unsigned char data_len = 0;
 974   1        unsigned char week_enable = 0, i = 0;
 975   1        switch (state)
 976   1        {
 977   2        case SINGLE_CHANNEL_STATE:
 978   2          week_enable = (~get_timing_week_enable(0x10DE)) & 0xffff;
 979   2          break;
 980   2        case SINGLE_CHANNELS_STATE:
 981   2          week_enable = (~get_timing_week_enable(0x10e6)) & 0xffff;
 982   2          break;
 983   2        case BATCH_CHANNEL_STATE:
 984   2        case BATCH_CHANNELS_STATE:
 985   2          week_enable = (~get_timing_week_enable(0x1b05)) & 0xffff;
 986   2          break;
 987   2        default:
 988   2          break;
 989   2        }
 990   1        if ((DOUBLE_TIME_RELAY_MODULE == p->type))
 991   1        {
 992   2          week_adr_start = 34;
 993   2          data_len = 18;
 994   2          week_adr_end = 51;
 995   2        }
 996   1        else
 997   1        {
 998   2          week_adr_start = 34;
 999   2          data_len = 14;
1000   2          week_adr_end = 47;
1001   2        }
1002   1      
1003   1        // USER_PRINTF("-->channel_enable is %x\n", get_channel_set(p, channel, state));
1004   1        // USER_PRINTF("-->week_enable is %bx\n", week_enable);
1005   1        set_master_send_hr(master_send_hr, week_adr_start, get_channel_set(p, channel, state));
1006   1        for (i = 0; i < p->channel_nb; i++)
1007   1        {
1008   2          set_master_send_hr(master_send_hr, week_adr_start + 1 + i, week_enable);
1009   2        }
1010   1        set_master_send_hr(master_send_hr, week_adr_end, ENTERPRISE);
1011   1        pack_data_send(&user_modbus, p->adr, MD_FR_MHR, week_adr_start, data_len);
1012   1      }
1013          // 光照设置
1014          void timing_module_parameter_solar_channel_send(struct this_module *p, unsigned char channel, unsigned cha
             -r state)
1015          {
1016   1        unsigned char solar_adr_start = 0;
1017   1        unsigned char solar_adr_end = 0;
1018   1        unsigned char data_len = 0;
C51 COMPILER V9.60.0.0   MODULE                                                            11/02/2023 18:49:06 PAGE 18  

1019   1        //  unsigned short channel_enable = 0;
1020   1        unsigned char solar_enable = 0, i = 0;
1021   1        unsigned char solar_up = 0, solar_down = 0;
1022   1        unsigned short solar_parameter = 0;
1023   1        switch (state)
1024   1        {
1025   2        case SINGLE_CHANNEL_STATE:
1026   2          solar_enable = read_dgus(0x10ed);
1027   2          solar_down = read_dgus(0x201d);
1028   2          solar_up = read_dgus(0x201e);
1029   2      
1030   2          break;
1031   2        case SINGLE_CHANNELS_STATE:
1032   2          //    channel_enable = 0xffff;
1033   2          solar_enable = read_dgus(0x10ee);
1034   2          solar_down = read_dgus(0x202f);
1035   2          solar_up = read_dgus(0x2030);
1036   2          break;
1037   2        case BATCH_CHANNEL_STATE:
1038   2        case BATCH_CHANNELS_STATE:
1039   2          solar_enable = read_dgus(0x1B20);
1040   2          solar_down = read_dgus(0x1B0D);
1041   2          solar_up = read_dgus(0x1B0E);
1042   2          break;
1043   2        default:
1044   2          break;
1045   2        }
1046   1        if ((DOUBLE_TIME_RELAY_MODULE == p->type))
1047   1        {
1048   2          solar_adr_start = 200;
1049   2          data_len = 18;
1050   2          solar_adr_end = 217;
1051   2        }
1052   1        else
1053   1        {
1054   2          solar_adr_start = 160;
1055   2          data_len = 14;
1056   2          solar_adr_end = 173;
1057   2        }
1058   1      
1059   1        solar_parameter = solar_enable << 15 | solar_up << 8 | solar_down;
1060   1        set_master_send_hr(master_send_hr, solar_adr_start, get_channel_set(p, channel, state));
1061   1        for (i = 0; i < p->channel_nb; i++)
1062   1        {
1063   2          set_master_send_hr(master_send_hr, solar_adr_start + 1 + i, solar_parameter);
1064   2        }
1065   1        set_master_send_hr(master_send_hr, solar_adr_end, ENTERPRISE);
1066   1        pack_data_send(&user_modbus, p->adr, MD_FR_MHR, solar_adr_start, data_len);
1067   1      }
1068          // 时段设置
1069          void timing_module_parameter_time_frame_channel_send(struct this_module *p, unsigned char channel, unsigne
             -d char state)
1070          {
1071   1        unsigned char time_frame_adr_start = 0;
1072   1        unsigned char time_frame_adr_end = 0;
1073   1        unsigned char data_len = 0;
1074   1        unsigned short time_frame_set_adr = 0;
1075   1        //  unsigned short channel_enable = 0;
1076   1        unsigned char i = 0;
1077   1        unsigned short time_frame_parameter[8] = 0;
1078   1        switch (state)
1079   1        {
C51 COMPILER V9.60.0.0   MODULE                                                            11/02/2023 18:49:06 PAGE 19  

1080   2        case SINGLE_CHANNEL_STATE:
1081   2          time_frame_set_adr = 0x201f;
1082   2          //    time_frame_parameter[0] = read_dgus(0x201f) << 8 | read_dgus(0x2020);
1083   2          //    time_frame_parameter[1] = read_dgus(0x2021) << 8 | read_dgus(0x2022);
1084   2          //    time_frame_parameter[2] = read_dgus(0x2023) << 8 | read_dgus(0x2024);
1085   2          //    time_frame_parameter[3] = read_dgus(0x2025) << 8 | read_dgus(0x2026);
1086   2          //    time_frame_parameter[4] = read_dgus(0x2027) << 8 | read_dgus(0x2028);
1087   2          //    time_frame_parameter[5] = read_dgus(0x2029) << 8 | read_dgus(0x202a);
1088   2          //    time_frame_parameter[6] = read_dgus(0x202b) << 8 | read_dgus(0x202c);
1089   2          //    time_frame_parameter[7] = read_dgus(0x202d) << 8 | read_dgus(0x202e);
1090   2      
1091   2          break;
1092   2        case SINGLE_CHANNELS_STATE:
1093   2          time_frame_set_adr = 0x2031;
1094   2          //    time_frame_parameter[0] = read_dgus(0x2031) << 8 | read_dgus(0x2032);
1095   2          //    time_frame_parameter[1] = read_dgus(0x2033) << 8 | read_dgus(0x2034);
1096   2          //    time_frame_parameter[2] = read_dgus(0x2035) << 8 | read_dgus(0x2036);
1097   2          //    time_frame_parameter[3] = read_dgus(0x2037) << 8 | read_dgus(0x2038);
1098   2          //    time_frame_parameter[4] = read_dgus(0x2039) << 8 | read_dgus(0x203a);
1099   2          //    time_frame_parameter[5] = read_dgus(0x203b) << 8 | read_dgus(0x203c);
1100   2          //    time_frame_parameter[6] = read_dgus(0x203d) << 8 | read_dgus(0x203e);
1101   2          //    time_frame_parameter[7] = read_dgus(0x203f) << 8 | read_dgus(0x2040);
1102   2          break;
1103   2        case BATCH_CHANNEL_STATE:
1104   2        case BATCH_CHANNELS_STATE:
1105   2          time_frame_set_adr = 0X1B10;
1106   2      
1107   2          break;
1108   2        default:
1109   2          break;
1110   2        }
1111   1        time_frame_parameter[0] = read_dgus(time_frame_set_adr++) << 8 | read_dgus(time_frame_set_adr++);
1112   1        time_frame_parameter[1] = read_dgus(time_frame_set_adr++) << 8 | read_dgus(time_frame_set_adr++);
1113   1        time_frame_parameter[2] = read_dgus(time_frame_set_adr++) << 8 | read_dgus(time_frame_set_adr++);
1114   1        time_frame_parameter[3] = read_dgus(time_frame_set_adr++) << 8 | read_dgus(time_frame_set_adr++);
1115   1        time_frame_parameter[4] = read_dgus(time_frame_set_adr++) << 8 | read_dgus(time_frame_set_adr++);
1116   1        time_frame_parameter[5] = read_dgus(time_frame_set_adr++) << 8 | read_dgus(time_frame_set_adr++);
1117   1        time_frame_parameter[6] = read_dgus(time_frame_set_adr++) << 8 | read_dgus(time_frame_set_adr++);
1118   1        time_frame_parameter[7] = read_dgus(time_frame_set_adr++) << 8 | read_dgus(time_frame_set_adr++);
1119   1        if ((DOUBLE_TIME_RELAY_MODULE == p->type))
1120   1        {
1121   2          time_frame_adr_start = 52;
1122   2          data_len = 130;
1123   2          time_frame_adr_end = 181;
1124   2        }
1125   1        else
1126   1        {
1127   2          time_frame_adr_start = 48;
1128   2          data_len = 98;
1129   2          time_frame_adr_end = 145;
1130   2        }
1131   1        set_master_send_hr(master_send_hr, time_frame_adr_start, get_channel_set(p, channel, state));
1132   1        // USER_PRINTF("-->p->channel_nb is %bd\n", p->channel_nb);
1133   1        for (i = 0; i < p->channel_nb; i++)
1134   1        {
1135   2          set_master_send_hr(master_send_hr, time_frame_adr_start + 1 + i * 8, time_frame_parameter[0]);
1136   2          set_master_send_hr(master_send_hr, time_frame_adr_start + 2 + i * 8, time_frame_parameter[1]);
1137   2          set_master_send_hr(master_send_hr, time_frame_adr_start + 3 + i * 8, time_frame_parameter[2]);
1138   2          set_master_send_hr(master_send_hr, time_frame_adr_start + 4 + i * 8, time_frame_parameter[3]);
1139   2          set_master_send_hr(master_send_hr, time_frame_adr_start + 5 + i * 8, time_frame_parameter[4]);
1140   2          set_master_send_hr(master_send_hr, time_frame_adr_start + 6 + i * 8, time_frame_parameter[5]);
1141   2          set_master_send_hr(master_send_hr, time_frame_adr_start + 7 + i * 8, time_frame_parameter[6]);
C51 COMPILER V9.60.0.0   MODULE                                                            11/02/2023 18:49:06 PAGE 20  

1142   2          set_master_send_hr(master_send_hr, time_frame_adr_start + 8 + i * 8, time_frame_parameter[7]);
1143   2        }
1144   1        set_master_send_hr(master_send_hr, time_frame_adr_end, ENTERPRISE);
1145   1        pack_data_send(&user_modbus, p->adr, MD_FR_MHR, time_frame_adr_start, data_len);
1146   1      }
1147          // 二选一
1148          unsigned char select_either_or_single(unsigned short key_adr, unsigned short adr1, unsigned short adr2)
1149          {
1150   1        unsigned short key_nb = 0;
1151   1        get_key_value(key_adr, &key_nb);
1152   1        if (key_nb)
1153   1        {
1154   2          switch (key_nb)
1155   2          {
1156   3          case 1:
1157   3            if ((1 == read_dgus(adr1)))
1158   3            {
1159   4              write_dgus(adr1, 0);
1160   4              write_dgus(adr2, 1);
1161   4            }
1162   3            else if (0 == read_dgus(adr1))
1163   3            {
1164   4              write_dgus(adr1, 1);
1165   4              write_dgus(adr2, 0);
1166   4            }
1167   3            break;
1168   3          case 2:
1169   3            if ((1 == read_dgus(adr2)))
1170   3            {
1171   4              write_dgus(adr1, 1);
1172   4              write_dgus(adr2, 0);
1173   4            }
1174   3            else if (0 == read_dgus(adr2))
1175   3            {
1176   4              write_dgus(adr1, 0);
1177   4              write_dgus(adr2, 1);
1178   4            }
1179   3            break;
1180   3          default:
1181   3            break;
1182   3          }
1183   2          clear_key_value(key_adr, &key_nb);
1184   2          return 1;
1185   2        }
1186   1        return 0;
1187   1      }
1188          // 二选一选择框控制
1189          void select_either_or_all(void)
1190          {
1191   1        select_either_or_single(0x1117, 0x110d, 0x110e);
1192   1        select_either_or_single(0x1118, 0x110f, 0x1110);
1193   1        select_either_or_single(0x1119, 0x1111, 0x1112);
1194   1        select_either_or_single(0x111a, 0x1113, 0x1114);
1195   1        select_either_or_single(0x111b, 0x1115, 0x1116);
1196   1      }
1197          // 经纬度设置
1198          void timing_module_parameter_ongitude_latitude_send(struct this_module *p)
1199          {
1200   1      
1201   1        set_master_send_hr(master_send_hr, 23, 0X88 << 8 | read_dgus(0x1111) << 7 | read_dgus(0x1110) << 6 | read
             -_dgus(0x110E) << 4 | read_dgus(0x2041));
1202   1        set_master_send_hr(master_send_hr, 24, read_dgus(0x2042)); // 经度L
C51 COMPILER V9.60.0.0   MODULE                                                            11/02/2023 18:49:06 PAGE 21  

1203   1        set_master_send_hr(master_send_hr, 25, read_dgus(0x2043)); // 经度H
1204   1        set_master_send_hr(master_send_hr, 26, read_dgus(0x2044)); // 纬度L
1205   1        set_master_send_hr(master_send_hr, 27, read_dgus(0x2045)); // 纬度H
1206   1        set_master_send_hr(master_send_hr, 28, ENTERPRISE);
1207   1        // 日落加减1 偏移时间7高八  日出加减1 偏移时间7低八
1208   1        set_master_send_hr(master_send_hr, 29, read_dgus(0x1701) << 15 | read_dgus(0x2047) << 8 | read_dgus(0x170
             -0) << 7 | read_dgus(0x2046));
1209   1        // 日出日落通道使能位
1210   1        set_master_send_hr(master_send_hr, 30, read_dgus(0x10FF) << 15 | read_dgus(0x10FE) << 14 | read_dgus(0x10
             -FD) << 13 | read_dgus(0x10FC) << 12 | read_dgus(0x10FB) << 11 | read_dgus(0x10FA) << 10 | read_dgus(0x10F9) << 9 | read_
             -dgus(0x10F8) << 8 | read_dgus(0x10F7) << 7 | read_dgus(0x10F6) << 6 | read_dgus(0x10F5) << 5 | read_dgus(0x10F4) << 4 | 
             -read_dgus(0x10F3) << 3 | read_dgus(0x10F2) << 2 | read_dgus(0x10F1) << 1 | read_dgus(0x10F0));
1211   1      
1212   1        pack_data_send(&user_modbus, p->adr, MD_FR_MHR, 23, 8);
1213   1      }
1214          // 时间设置
1215          void timing_module_parameter_time_send(struct this_module *p)
1216          {
1217   1        set_master_send_hr(master_send_hr, 241, 0x88);
1218   1        set_master_send_hr(master_send_hr, 242, read_dgus(0x2048));
1219   1        set_master_send_hr(master_send_hr, 243, read_dgus(0x2049));
1220   1        set_master_send_hr(master_send_hr, 244, read_dgus(0x204a));
1221   1        set_master_send_hr(master_send_hr, 245, read_dgus(0x204b));
1222   1        set_master_send_hr(master_send_hr, 246, read_dgus(0x204c));
1223   1        set_master_send_hr(master_send_hr, 247, read_dgus(0x204d));
1224   1        set_master_send_hr(master_send_hr, 248, read_dgus(0x204e));
1225   1        set_master_send_hr(master_send_hr, 249, ENTERPRISE);
1226   1        // USER_PRINTF("-->p->adr is %bd\n", p->adr);
1227   1        pack_data_send(&user_modbus, p->adr, MD_FR_MHR, 241, 9);
1228   1      }
1229          void timing_module_parameter_ctrl(unsigned char fun, struct this_module *p, unsigned char channel)
1230          {
1231   1        unsigned short key_nb = 0;
1232   1        get_key_value(CONFIRM_POP_VALUE_ADR, &key_nb);
1233   1        if (1 == key_nb)
1234   1        {
1235   2          switch (fun)
1236   2          {
1237   3          case 1:
1238   3            timing_module_parameter_week_enable_channel_send(p, channel, SINGLE_CHANNEL_STATE);
1239   3            break;
1240   3          case 2:
1241   3            timing_module_parameter_solar_channel_send(p, channel, SINGLE_CHANNEL_STATE);
1242   3            break;
1243   3          case 3:
1244   3            timing_module_parameter_time_frame_channel_send(p, channel, SINGLE_CHANNEL_STATE);
1245   3            break;
1246   3          case 0xa:
1247   3            timing_module_parameter_ongitude_latitude_send(p);
1248   3            break;
1249   3          case 0xb:
1250   3            timing_module_parameter_time_send(p);
1251   3            break;
1252   3          case 0x11:
1253   3            timing_module_parameter_week_enable_channel_send(p, channel, SINGLE_CHANNELS_STATE);
1254   3            break;
1255   3          case 0x12:
1256   3            timing_module_parameter_solar_channel_send(p, channel, SINGLE_CHANNELS_STATE);
1257   3            break;
1258   3          case 0x13:
1259   3            timing_module_parameter_time_frame_channel_send(p, channel, SINGLE_CHANNELS_STATE);
1260   3            break;
C51 COMPILER V9.60.0.0   MODULE                                                            11/02/2023 18:49:06 PAGE 22  

1261   3          default:
1262   3            break;
1263   3          }
1264   2          clear_key_value(CONFIRM_POP_VALUE_ADR, &key_nb);
1265   2        }
1266   1      }
1267          // 时控 参数发送控制
1268          void timing_module_parameter_key_ctrl(struct this_module *p, unsigned char channel)
1269          {
1270   1        unsigned short key_nb = 0;
1271   1        get_key_value(0x10E5, &key_nb);
1272   1        if (key_nb)
1273   1        {
1274   2          para_set_fun = key_nb;
1275   2          switch (key_nb)
1276   2          {
1277   3          case 4:
1278   3          case 0x14:
1279   3            return_to_previous_page();
1280   3            break;
1281   3          default:
1282   3            break;
1283   3          }
1284   2          pop_menu_key_ctrl(CONFIRM_POP_KEY_ADR);
1285   2          clear_key_value(0x10E5, &key_nb);
1286   2        }
1287   1        timing_module_parameter_ctrl(para_set_fun, p, channel);
1288   1      }
1289          unsigned short led_sta[16] = {0};
1290          // 清空led状态
1291          void clear_led_sta(unsigned short *p)
1292          {
1293   1        unsigned char i = 0;
1294   1        for (i = 0; i < 16; i++)
1295   1        {
1296   2          *(p + i) = 0;
1297   2        }
1298   1      }
1299          // 读继电器状态
1300          void relay_read(module_t *p)
1301          {
1302   1        pack_data_send(&user_modbus, p->adr, MD_RD_HR, 32, 1);
1303   1      }
1304          // 继电器控制
1305          void relay_single_ctrl(module_t *p)
1306          {
1307   1      
1308   1        unsigned short key_nb = 0;
1309   1        unsigned char i = 0;
1310   1        unsigned char single_key_tab[5][12] =
1311   1            {
1312   1                {2, 4, 11, 9},                           // 4路
1313   1                {2, 3, 4, 11, 10, 9},                    // 6路
1314   1                {2, 3, 4, 6, 7, 11, 10, 9},              // 8路
1315   1                {1, 2, 3, 4, 5, 12, 11, 10, 9, 8},       // 10路
1316   1                {1, 2, 3, 4, 5, 6, 7, 12, 11, 10, 9, 8}, // 12路
1317   1            };
1318   1        unsigned char double_key_tab[16] = {0x01, 0x02, 0x04, 0x05, 12, 11, 9, 8, 0x81, 0x82, 0x84, 0x85, 0x8c, 0
             -x8b, 0x89, 0x88};
1319   1        get_key_value(0x1010, &key_nb);
1320   1        if (HR[32] != g_var_module.led_sta_bak) // 状态变换
1321   1      
C51 COMPILER V9.60.0.0   MODULE                                                            11/02/2023 18:49:06 PAGE 23  

1322   1        {
1323   2          USER_PRINTF("-->relay state has been changed!\n");
1324   2          g_var_module.led_sta_bak = HR[32];
1325   2          // USER_PRINTF("-->g_var_module.led_sta_bak is %d!\n", g_var_module.led_sta_bak);
1326   2          for (i = 0; i < 16; i++)
1327   2          {
1328   3            led_sta[i] = (HR[32] >> i) & 0x01;
1329   3            write_dgusii_vp(0x1030 + i, (unsigned char *)&led_sta[i], 1);
1330   3            //      sys_delay_about_ms(1);
1331   3          }
1332   2        }
1333   1        if ((key_nb) && (mbh_getState() == MBH_STATE_IDLE))
1334   1        {
1335   2      
1336   2          led_sta[key_nb - 1] ^= 1;
1337   2          printf_tab(32, (unsigned char *)&led_sta[0]);
1338   2          write_dgusii_vp(0x1030 + key_nb - 1, (unsigned char *)&led_sta[key_nb - 1], 1);
1339   2          if ((SINGLE_RELAY_MODULE == p->type) || (SINGLE_TIME_RELAY_MODULE == p->type))
1340   2          {
1341   3            if (4 == p->channel_nb)
1342   3              set_master_send_hr(master_send_hr, 0, single_key_tab[0][key_nb - 1]);
1343   3            else if (6 == p->channel_nb)
1344   3              set_master_send_hr(master_send_hr, 0, single_key_tab[1][key_nb - 1]);
1345   3            else if (8 == p->channel_nb)
1346   3              set_master_send_hr(master_send_hr, 0, single_key_tab[2][key_nb - 1]);
1347   3            else if (10 == p->channel_nb)
1348   3              set_master_send_hr(master_send_hr, 0, single_key_tab[3][key_nb - 1]);
1349   3            else if (12 == p->channel_nb)
1350   3              set_master_send_hr(master_send_hr, 0, single_key_tab[4][key_nb - 1]);
1351   3          }
1352   2          else if ((DOUBLE_RELAY_MODULE == p->type) || (DOUBLE_TIME_RELAY_MODULE == p->type))
1353   2          {
1354   3            set_master_send_hr(master_send_hr, 0, double_key_tab[key_nb - 1]);
1355   3          }
1356   2          set_master_send_hr(master_send_hr, 1, ENTERPRISE);
1357   2          pack_data_send(&user_modbus, p->adr, MD_FR_MHR, 0, 2);
1358   2          HR[32] = g_var_module.led_sta_bak = master_send_hr[32];
1359   2          clear_key_value(0x1010, &key_nb);
1360   2        }
1361   1      }
1362          // 继电器全开全关
1363          void relay_all_ctrl(module_t *p)
1364          {
1365   1        unsigned char i = 0;
1366   1        unsigned short key_nb = 0;
1367   1        get_key_value(0x100c, &key_nb);
1368   1        if ((1 == key_nb) || (2 == key_nb))
1369   1        {
1370   2          for (i = 0; i < 16; i++)
1371   2          {
1372   3            led_sta[i] = key_nb > 1 ? 0 : 1;
1373   3            write_dgusii_vp(0x1030 + i, (unsigned char *)&led_sta[i], 1);
1374   3          }
1375   2          set_master_send_hr(master_send_hr, 31, 0xffff);
1376   2          set_master_send_hr(master_send_hr, 32, key_nb > 1 ? 0 : 0xffff);
1377   2          set_master_send_hr(master_send_hr, 33, ENTERPRISE);
1378   2          pack_data_send(&user_modbus, p->adr, MD_FR_MHR, 31, 3);
1379   2          clear_key_value(0x100c, &key_nb);
1380   2          HR[32] = g_var_module.led_sta_bak = master_send_hr[32];
1381   2        }
1382   1      }
1383          // 发送继电器开关广播命令
C51 COMPILER V9.60.0.0   MODULE                                                            11/02/2023 18:49:06 PAGE 24  

1384          void all_module_on_off(void)
1385          {
1386   1        unsigned short key_nb = 0;
1387   1        get_key_value(RELAY_MODULE_KEY_ALL_ON_ADR, &key_nb);
1388   1        if ((1 == key_nb))
1389   1        {
1390   2          set_master_send_hr(master_send_hr, 31, 0xffff);
1391   2          set_master_send_hr(master_send_hr, 32, 0xffff);
1392   2          set_master_send_hr(master_send_hr, 33, ENTERPRISE);
1393   2          pack_data_send(&user_modbus, 0, MD_FR_MHR, 31, 3);
1394   2          clear_key_value(RELAY_MODULE_KEY_ALL_ON_ADR, &key_nb);
1395   2          HR[32] = g_var_module.led_sta_bak = 0xffff;
1396   2        }
1397   1        get_key_value(RELAY_MODULE_KEY_ALL_OFF_ADR, &key_nb);
1398   1        if ((1 == key_nb))
1399   1        {
1400   2          set_master_send_hr(master_send_hr, 31, 0xffff);
1401   2          set_master_send_hr(master_send_hr, 32, 0);
1402   2          set_master_send_hr(master_send_hr, 33, ENTERPRISE);
1403   2          pack_data_send(&user_modbus, 0, MD_FR_MHR, 31, 3);
1404   2          clear_key_value(RELAY_MODULE_KEY_ALL_OFF_ADR, &key_nb);
1405   2          HR[32] = g_var_module.led_sta_bak = 0;
1406   2        }
1407   1      }
1408          // 继电器状态刷新
1409          void relay_refesh(module_t *p)
1410          {
1411   1        unsigned short key_nb = 0;
1412   1        get_key_value(0x100c, &key_nb);
1413   1        if (3 == key_nb)
1414   1        {
1415   2          pack_data_send(&user_modbus, p->adr, MD_RD_HR, 32, 1);
1416   2      
1417   2          clear_key_value(0x100c, &key_nb);
1418   2        }
1419   1      }
1420          // 继电器界面控制
1421          void relay_ctrl(module_t *p)
1422          {
1423   1        relay_single_ctrl(p);
1424   1        relay_all_ctrl(p);
1425   1        relay_refesh(p);
1426   1      }
1427          // 读调光
1428          void dim_read(module_t *p)
1429          {
1430   1        delay_us(1000);
1431   1        pack_data_send(&user_modbus, p->adr, MD_RD_HR, 23, 4);
1432   1      }
1433          // 调光控制
1434          void dim_single_ctrl(module_t *p)
1435          {
1436   1        unsigned char i = 0;
1437   1        static unsigned char dim_send_flag = 0, key_down_flag = 0, key_up_flag = 0;
1438   1        unsigned short key_nb = 0;
1439   1        unsigned short y_coordinate = 0;
1440   1        unsigned short x_coordinate = 0;
1441   1        unsigned char dim_gear[8] = {0};
1442   1        unsigned char touch_sta[8] = {0};
1443   1        for (i = 0; i < 4; i++)
1444   1        {
1445   2          if (g_var_module.dim_light_bak[i] != HR[23 + i])
C51 COMPILER V9.60.0.0   MODULE                                                            11/02/2023 18:49:06 PAGE 25  

1446   2          {
1447   3            USER_PRINTF("-->dim state has been changed!\n");
1448   3            g_var_module.dim_light_bak[i] = HR[23 + i];
1449   3            if (VOL_DIM_MODULE == p->type)
1450   3            {
1451   4      
1452   4              write_dgus(0x1100 + i, g_var_module.dim_light_bak[i]);
1453   4            }
1454   3            else
1455   3            {
1456   4              write_dgus(0x1013 + i, g_var_module.dim_light_bak[i]);
1457   4            }
1458   3          }
1459   2          //    sys_delay_about_ms(1);
1460   2        }
1461   1        if ((DIM_CTRL_PAGE == read_pic()) || (SCR_CTRL_PAGE == read_pic()))
1462   1        {
1463   2      
1464   2          //    USER_PRINTF("display_pic_dim_edit \n");
1465   2          read_dgusii_vp(0x16, touch_sta, 4);
1466   2          if (touch_sta[0])
1467   2          {
1468   3            printf_tab(8, touch_sta);
1469   3      
1470   3            y_coordinate = touch_sta[4] * 256 + touch_sta[5];
1471   3            x_coordinate = touch_sta[2] * 256 + touch_sta[3];
1472   3            if ((3 == touch_sta[1]) && (0 == key_down_flag))
1473   3            {
1474   4              key_down_flag = 1;
1475   4              key_up_flag = 0;
1476   4              USER_PRINTF("-->key_down_flag = 1 \n");
1477   4            }
1478   3            else if ((2 == touch_sta[1]) && (1 == key_down_flag))
1479   3            {
1480   4              key_down_flag = 3;
1481   4              key_up_flag = 0;
1482   4              USER_PRINTF("-->key_down_flag = 3 \n");
1483   4            }
1484   3            else if ((2 == touch_sta[1]) && (0 == key_down_flag) && (0 == key_up_flag))
1485   3            {
1486   4              key_up_flag = 1;
1487   4              USER_PRINTF("-->key_up_flag = 1 \n");
1488   4            }
1489   3            touch_sta[0] = 0;
1490   3            touch_sta[1] = 0;
1491   3            touch_sta[2] = 0;
1492   3            touch_sta[3] = 0;
1493   3            touch_sta[4] = 0;
1494   3            touch_sta[5] = 0;
1495   3            write_dgusii_vp(0x16, touch_sta, 4);
1496   3            USER_PRINTF("-->x_coordinate = %d,y_coordinate = %d \n", x_coordinate, y_coordinate);
1497   3          }
1498   2      
1499   2          set_master_send_hr(master_send_hr, 27, ENTERPRISE);
1500   2          if (VOL_DIM_MODULE == p->type)
1501   2          {
1502   3            read_dgusii_vp(0x1100, dim_gear, 4);
1503   3            //      set_master_send_hr(master_send_hr,22,0xffff);
1504   3            //      set_master_send_hr(master_send_hr,23,dim_gear[1]);
1505   3            //      set_master_send_hr(master_send_hr,24,dim_gear[3]);
1506   3            //      set_master_send_hr(master_send_hr,25,dim_gear[5]);
1507   3            //      set_master_send_hr(master_send_hr,26,dim_gear[7]);
C51 COMPILER V9.60.0.0   MODULE                                                            11/02/2023 18:49:06 PAGE 26  

1508   3          }
1509   2          else
1510   2          {
1511   3            read_dgusii_vp(0x1013, dim_gear, 4);
1512   3          }
1513   2          set_master_send_hr(master_send_hr, 22, 0xffff);
1514   2          set_master_send_hr(master_send_hr, 23, dim_gear[1]);
1515   2          set_master_send_hr(master_send_hr, 24, dim_gear[3]);
1516   2          set_master_send_hr(master_send_hr, 25, dim_gear[5]);
1517   2          set_master_send_hr(master_send_hr, 26, dim_gear[7]);
1518   2          HR[23] = g_var_module.dim_light_bak[0] = master_send_hr[23];
1519   2          HR[24] = g_var_module.dim_light_bak[1] = master_send_hr[24];
1520   2          HR[25] = g_var_module.dim_light_bak[2] = master_send_hr[25];
1521   2          HR[26] = g_var_module.dim_light_bak[3] = master_send_hr[26];
1522   2          if (((y_coordinate > 262) && (y_coordinate < 550) && ((3 == key_down_flag) || (1 == key_up_flag))))
1523   2      
1524   2          {
1525   3            USER_PRINTF("-->send--OK \n");
1526   3            dim_send_flag = 1;
1527   3            key_down_flag = 0;
1528   3            key_up_flag = 0;
1529   3          }
1530   2      
1531   2          //    USER_PRINTF("g_var_module.dim_light_bak-->");
1532   2          //    printf_tab(8,g_var_module.dim_light_bak);
1533   2          if (1 == dim_send_flag)
1534   2          {
1535   3            //      USER_PRINTF("dim_send_flag --> 1 \n");
1536   3            dim_send_flag = 0;
1537   3            pack_data_send(&user_modbus, p->adr, MD_FR_MHR, 22, 6);
1538   3      
1539   3            USER_PRINTF("-->DIM_MODULE dim_send_ok  \n");
1540   3          }
1541   2        }
1542   1        else
1543   1        {
1544   2          key_down_flag = 0;
1545   2          key_up_flag = 0;
1546   2        }
1547   1      }
1548          // 调光全开全关
1549          void dim_all_ctrl(module_t *p)
1550          {
1551   1        //  unsigned char i = 0;
1552   1        unsigned short key_nb = 0;
1553   1        //  unsigned char dim_gear[8] = {0};
1554   1        get_key_value(0x100c, &key_nb);
1555   1        if ((0x11 == key_nb) || (0x12 == key_nb))
1556   1        {
1557   2      
1558   2          set_master_send_hr(master_send_hr, 22, 0xffff);
1559   2          set_master_send_hr(master_send_hr, 23, p->type == VOL_DIM_MODULE ? (key_nb > 0x11 ? 0 : 10) : (key_nb > 
             -0x11 ? 0 : 100));
1560   2          set_master_send_hr(master_send_hr, 24, p->type == VOL_DIM_MODULE ? (key_nb > 0x11 ? 0 : 10) : (key_nb > 
             -0x11 ? 0 : 100));
1561   2          set_master_send_hr(master_send_hr, 25, p->type == VOL_DIM_MODULE ? (key_nb > 0x11 ? 0 : 10) : (key_nb > 
             -0x11 ? 0 : 100));
1562   2          set_master_send_hr(master_send_hr, 26, p->type == VOL_DIM_MODULE ? (key_nb > 0x11 ? 0 : 10) : (key_nb > 
             -0x11 ? 0 : 100));
1563   2          set_master_send_hr(master_send_hr, 27, ENTERPRISE);
1564   2          pack_data_send(&user_modbus, p->adr, MD_FR_MHR, 22, 6);
1565   2          clear_key_value(0x100c, &key_nb);
C51 COMPILER V9.60.0.0   MODULE                                                            11/02/2023 18:49:06 PAGE 27  

1566   2          write_dgusii_vp(VOL_DIM_MODULE == p->type ? 0x1100 : 0x1013, (unsigned char *)(master_send_hr + 23), 4);
1567   2          HR[23] = g_var_module.dim_light_bak[0] = master_send_hr[23];
1568   2          HR[24] = g_var_module.dim_light_bak[1] = master_send_hr[24];
1569   2          HR[25] = g_var_module.dim_light_bak[2] = master_send_hr[25];
1570   2          HR[26] = g_var_module.dim_light_bak[3] = master_send_hr[26];
1571   2        }
1572   1      }
1573          // 发送开关广播命令
1574          void all_dim_on_off(void)
1575          {
1576   1        //  unsigned char i = 0;
1577   1        unsigned short key_nb = 0;
1578   1        //  unsigned char dim_gear[8] = {0};
1579   1        get_key_value(DIM_MODULE_KEY_ALL_ON_ADR, &key_nb);
1580   1        if (1 == key_nb)
1581   1        {
1582   2      
1583   2          set_master_send_hr(master_send_hr, 22, 0xffff);
1584   2          set_master_send_hr(master_send_hr, 23, 100);
1585   2          set_master_send_hr(master_send_hr, 24, 100);
1586   2          set_master_send_hr(master_send_hr, 25, 100);
1587   2          set_master_send_hr(master_send_hr, 26, 100);
1588   2          set_master_send_hr(master_send_hr, 27, ENTERPRISE);
1589   2          pack_data_send(&user_modbus, 0, MD_FR_MHR, 22, 6);
1590   2          clear_key_value(DIM_MODULE_KEY_ALL_ON_ADR, &key_nb);
1591   2          HR[23] = g_var_module.dim_light_bak[0] = master_send_hr[23];
1592   2          HR[24] = g_var_module.dim_light_bak[1] = master_send_hr[24];
1593   2          HR[25] = g_var_module.dim_light_bak[2] = master_send_hr[25];
1594   2          HR[26] = g_var_module.dim_light_bak[3] = master_send_hr[26];
1595   2        }
1596   1        get_key_value(DIM_MODULE_KEY_ALL_OFF_ADR, &key_nb);
1597   1        if (1 == key_nb)
1598   1        {
1599   2      
1600   2          set_master_send_hr(master_send_hr, 22, 0xffff);
1601   2          set_master_send_hr(master_send_hr, 23, 0);
1602   2          set_master_send_hr(master_send_hr, 24, 0);
1603   2          set_master_send_hr(master_send_hr, 25, 0);
1604   2          set_master_send_hr(master_send_hr, 26, 0);
1605   2          set_master_send_hr(master_send_hr, 27, ENTERPRISE);
1606   2          pack_data_send(&user_modbus, 0, MD_FR_MHR, 22, 6);
1607   2          clear_key_value(DIM_MODULE_KEY_ALL_OFF_ADR, &key_nb);
1608   2          HR[23] = g_var_module.dim_light_bak[0] = master_send_hr[23];
1609   2          HR[24] = g_var_module.dim_light_bak[1] = master_send_hr[24];
1610   2          HR[25] = g_var_module.dim_light_bak[2] = master_send_hr[25];
1611   2          HR[26] = g_var_module.dim_light_bak[3] = master_send_hr[26];
1612   2        }
1613   1      }
1614          // 调光状态刷新
1615          void dim_refesh(module_t *p)
1616          {
1617   1        unsigned short key_nb = 0;
1618   1        get_key_value(0x100c, &key_nb);
1619   1        if (0x13 == key_nb)
1620   1        {
1621   2          pack_data_send(&user_modbus, p->adr, MD_RD_HR, 23, 4);
1622   2      
1623   2          clear_key_value(0x100c, &key_nb);
1624   2        }
1625   1      }
1626          // 调光界面控制
1627          void dim_ctrl(module_t *p)
C51 COMPILER V9.60.0.0   MODULE                                                            11/02/2023 18:49:06 PAGE 28  

1628          {
1629   1        dim_single_ctrl(p);
1630   1        dim_all_ctrl(p);
1631   1        dim_refesh(p);
1632   1      }
1633          // 显示设置界面
1634          void display_interface(module_t *p)
1635          {
1636   1        if (0 == p->data_sta)
1637   1        {
1638   2          return;
1639   2        }
1640   1        switch (p->type)
1641   1        {
1642   2        case SINGLE_RELAY_MODULE:
1643   2        case SINGLE_TIME_RELAY_MODULE:
1644   2        case DOUBLE_RELAY_MODULE:
1645   2        case DOUBLE_TIME_RELAY_MODULE:
1646   2      
1647   2          display_relay_interface(p);
1648   2          USER_PRINTF("-->display_relay_interface\n");
1649   2          relay_read(p);
1650   2          break;
1651   2        case VOL_DIM_MODULE:
1652   2        case SCR_DIM_MODULE:
1653   2          clear_touch_sta();
1654   2          display_dim_interface(p);
1655   2          USER_PRINTF("-->display_dim_interface\n");
1656   2          dim_read(p);
1657   2          break;
1658   2        default:
1659   2      
1660   2          break;
1661   2        }
1662   1      }
1663          // 打开模块
1664          
1665          void module_touch(module_t *p, unsigned char key)
1666          {
1667   1        norflash_read((key - 1) * MODULE_FLASH_SIZE, (unsigned char *)p, MODULE_FLASH_SIZE);
1668   1        display_interface(p);
1669   1      }
1670          void module_touch_ctrl(void)
1671          {
1672   1        unsigned short key_nb = 0;
1673   1        get_key_value(0x100a, &key_nb);
1674   1        if (key_nb)
1675   1        {
1676   2          //    clear_led_sta(led_sta);
1677   2          module_touch(&module, key_nb);
1678   2          clear_key_value(0x100a, &key_nb);
1679   2          key_nb = 0;
1680   2        }
1681   1      }
1682          // 恢复出厂设置
1683          void factory_data_reset(void)
1684          {
1685   1      
1686   1        unsigned char ret_tab[4] = {0x55, 0xaa, 0x5a, 0xa5};
1687   1        unsigned short key_nb = 0;
1688   1        unsigned char i = 0;
1689   1        get_key_value(0x100b, &key_nb);
C51 COMPILER V9.60.0.0   MODULE                                                            11/02/2023 18:49:06 PAGE 29  

1690   1        if (1 == key_nb)
1691   1        {
1692   2          // 读写T5L片内256KW Flash，mod=0x5A 为读取，mod=0xA5为写入
1693   2          // addr=DGUS变量地址，必须是偶数；addr_flash=flash读取地址，必须是偶数；len=读取字长度，必须是偶数。
1694   2          // 从屏幕的变量地址区域找一块连续的全是0的，然后将数据写入到数据库进行覆盖
1695   2          for (i = 0; i < 61; i++) // 清到F400 一些参数设置不清空
1696   2          {
1697   3            T5L_Flash(0xA5, 0Xe000, 1024 * i, 1024); // 写0FLASH清除
1698   3          }
1699   2          //    T5L_Flash(0x5A,0X3110, 0,1024); //读为0
1700   2          clear_key_value(0x100a, &key_nb);
1701   2          key_nb = 0;
1702   2          write_dgusii_vp(0x04, (unsigned char *)&ret_tab, 2); // MCU复位
1703   2        }
1704   1      }
1705          
1706          /**
1707           * @brief 修改模块-显示编辑页面
1708           * @param {module_t} *p 模块指针
1709           * @return {*}
1710           */
1711          void display_edit_interface(module_t *p)
1712          {
1713   1      
1714   1        USER_PRINTF("display_edit_interface\n");
1715   1        // USER_PRINTF("current module type is %bd\n", p->type);
1716   1        write_dgus(0x2000, p->adr);
1717   1        module_type_bak = p->type;
1718   1        write_dgusii_vp(0x3110, (unsigned char *)&module_name_tab[p->type], 6);
1719   1        write_dgus(0x1000, p->channel_nb);
1720   1        write_dgusii_vp(0x3000, (unsigned char *)&p->module_name, 8);
1721   1        //  sprintf(p->channel_name,"%.256s",p->channel_name);
1722   1        // USER_PRINTF("-->module name is %s\n", p->module_name);
1723   1        // USER_PRINTF("-->module channel name is %s\n", p->channel_name);
1724   1        write_dgusii_vp(0x3008, (unsigned char *)&p->channel_name, 8 * 16);
1725   1        switch (p->channel_nb)
1726   1        {
1727   2        case 4:
1728   2          if ((DOUBLE_RELAY_MODULE == p->type) || (DOUBLE_TIME_RELAY_MODULE == p->type))
1729   2            pic_set(DOUBLE_MODULE_4_CHANNEL_EDIT_PAGE);
1730   2          else if ((SINGLE_RELAY_MODULE == p->type) || (SINGLE_TIME_RELAY_MODULE == p->type))
1731   2            pic_set(SINGLE_MODULE_4_CHANNEL_EDIT_PAGE);
1732   2          else if ((VOL_DIM_MODULE == p->type))
1733   2            pic_set(PWM_MODULE_4_CHANNEL_EDIT_PAGE);
1734   2          else if ((SCR_DIM_MODULE == p->type))
1735   2            pic_set(SCR_MODULE_4_CHANNEL_EDIT_PAGE);
1736   2          break;
1737   2        case 6:
1738   2          if ((DOUBLE_RELAY_MODULE == p->type) || (DOUBLE_TIME_RELAY_MODULE == p->type))
1739   2            pic_set(DOUBLE_MODULE_6_CHANNEL_EDIT_PAGE);
1740   2          else if ((SINGLE_RELAY_MODULE == p->type) || (SINGLE_TIME_RELAY_MODULE == p->type))
1741   2            pic_set(SINGLE_MODULE_6_CHANNEL_EDIT_PAGE);
1742   2      
1743   2          break;
1744   2        case 8:
1745   2          if ((DOUBLE_RELAY_MODULE == p->type) || (DOUBLE_TIME_RELAY_MODULE == p->type))
1746   2            pic_set(DOUBLE_MODULE_8_CHANNEL_EDIT_PAGE);
1747   2          else if ((SINGLE_RELAY_MODULE == p->type) || (SINGLE_TIME_RELAY_MODULE == p->type))
1748   2            pic_set(SINGLE_MODULE_8_CHANNEL_EDIT_PAGE);
1749   2      
1750   2          break;
1751   2        case 10:
C51 COMPILER V9.60.0.0   MODULE                                                            11/02/2023 18:49:06 PAGE 30  

1752   2          if ((DOUBLE_RELAY_MODULE == p->type) || (DOUBLE_TIME_RELAY_MODULE == p->type))
1753   2            pic_set(DOUBLE_MODULE_10_CHANNEL_EDIT_PAGE);
1754   2          else if ((SINGLE_RELAY_MODULE == p->type) || (SINGLE_TIME_RELAY_MODULE == p->type))
1755   2            pic_set(SINGLE_MODULE_10_CHANNEL_EDIT_PAGE);
1756   2      
1757   2          break;
1758   2        case 12:
1759   2          if ((DOUBLE_RELAY_MODULE == p->type) || (DOUBLE_TIME_RELAY_MODULE == p->type))
1760   2            pic_set(DOUBLE_MODULE_12_CHANNEL_EDIT_PAGE);
1761   2          else if ((SINGLE_RELAY_MODULE == p->type) || (SINGLE_TIME_RELAY_MODULE == p->type))
1762   2            pic_set(SINGLE_MODULE_12_CHANNEL_EDIT_PAGE);
1763   2      
1764   2          break;
1765   2        case 14:
1766   2          if ((DOUBLE_RELAY_MODULE == p->type) || (DOUBLE_TIME_RELAY_MODULE == p->type))
1767   2            pic_set(DOUBLE_MODULE_14_CHANNEL_EDIT_PAGE);
1768   2      
1769   2          break;
1770   2        case 16:
1771   2          if ((DOUBLE_RELAY_MODULE == p->type) || (DOUBLE_TIME_RELAY_MODULE == p->type))
1772   2            pic_set(DOUBLE_MODULE_16_CHANNEL_EDIT_PAGE);
1773   2          break;
1774   2        default:
1775   2          break;
1776   2        }
1777   1      }
1778          
1779          // 配置模块信息
1780          void modifying_module_information(module_t *p)
1781          
1782          {
1783   1        unsigned short key_nb = 0;
1784   1        unsigned char select_index = 0;
1785   1        get_key_value(0x1009, &key_nb);
1786   1        if (1 == key_nb) // 添加模块
1787   1        {
1788   2          clear_key_value(0x1009, &key_nb);
1789   2          USER_PRINTF("-->ctrl_mgmt_sta\n");
1790   2          modfity_index = find_index(0, MODULE_FLASH_SIZE, MODULE_NUB_LIMIT);
1791   2          if (OVERFLOW_SIZE == modfity_index)
1792   2          {
1793   3            USER_PRINTF("-->waring! too many module \n");
1794   3            pop_menu_key_ctrl(OVERFLOW_WARING_CODE);
1795   3            return;
1796   3          }
1797   2          pic_set(MODULE_ADD_PAGE);
1798   2          //    USER_PRINTF("<--get_blank_index -->%bd\n", modfity_index);
1799   2          write_dgusii_vp(0x3110, (unsigned char *)&module_name_tab[0], 6);
1800   2          write_dgusii_vp(0x3008, (unsigned char *)&default_module_channel_name, 256);
1801   2          write_dgusii_vp(0x3000, (unsigned char *)module_default_name, 8);
1802   2          write_dgus(0X1000, 4);
1803   2        }
1804   1        if ((3 == key_nb)) // 修改模块
1805   1        {
1806   2          clear_key_value(0x1009, &key_nb);
1807   2          // select_index = get_selected_sequence_number(0x1104, 8);
1808   2          select_index = get_box_select_number(0x1400, 64);
1809   2          // USER_PRINTF("select_index-->%bd\n", select_index);
1810   2          if ((select_index > 0) && (FULL == check_whether_data_exists(0, select_index - 1, MODULE_FLASH_SIZE)))
1811   2          {
1812   3            modfity_index = select_index - 1;
1813   3            norflash_read((select_index - 1) * MODULE_FLASH_SIZE, (unsigned char *)p, MODULE_FLASH_SIZE);
C51 COMPILER V9.60.0.0   MODULE                                                            11/02/2023 18:49:06 PAGE 31  

1814   3            //      display_interface(p);
1815   3            display_edit_interface(p);
1816   3            USER_PRINTF("-->modify module successfully!\n");
1817   3            delete_arr_data(&g_var_module.module_adr[0], modfity_index);
1818   3            // g_var_module.module_edit_sta = MODIFY;
1819   3          }
1820   2        }
1821   1      }
1822          
1823          // 删除选中模块信息
1824          void clear_select_module_information(void)
1825          
1826          {
1827   1        unsigned short key_nb = 0;
1828   1        unsigned char select_index = 0;
1829   1        //  unsigned char i = 0;
1830   1        get_key_value(0x1012, &key_nb);
1831   1        if ((1 == key_nb))
1832   1        {
1833   2          //    select_index = get_selected_sequence_number(0x1104, 8);
1834   2          select_index = get_box_select_number(0x1400, 64);
1835   2          // USER_PRINTF("select_index-->%bd\n", select_index);
1836   2          if (select_index)
1837   2          {
1838   3            //      if(FULL == p->data_sta)
1839   3            //      {
1840   3            T5L_Flash(0xA5, 0Xe000, (select_index - 1) * MODULE_FLASH_SIZE, MODULE_FLASH_SIZE);            // 写0FLASH清
             -除
1841   3            T5L_Flash(0x5A, 0X3520 + (select_index - 1) * 32, (select_index - 1) * MODULE_FLASH_SIZE, 32); // 读为0
             -控制器信息
1842   3            //        T5L_Flash(0x5A,0X3120+(select_index-1)*32, TIMING_SCENE_INFOR_FLASH_ADR_END,32); //读为0控制器信
             -
1843   3            T5L_Flash(0x5A, 0x3120 + (select_index - 1) * 8, (select_index - 1) * MODULE_FLASH_SIZE, 8); // 读为0
1844   3            write_dgusii_vp(0x3120 + 8 * (select_index - 1), (unsigned char *)module_no_name, 8);
1845   3            delete_arr_data(&g_var_module.module_adr[0], select_index - 1);
1846   3            printf_tab(20, &g_var_module.module_adr[0]);
1847   3            //      }
1848   3          }
1849   2          clear_all_module_var_en(0x1400, 64);
1850   2          clear_key_value(0x1012, &key_nb);
1851   2        }
1852   1      }
1853          // 清空所有模块信息
1854          void clear_all_module_information(void)
1855          
1856          {
1857   1        unsigned short key_nb = 0;
1858   1        unsigned char i = 0;
1859   1        //  unsigned char select_index = 0;
1860   1        get_key_value(0x1011, &key_nb);
1861   1        if ((1 == key_nb))
1862   1        {
1863   2          USER_PRINTF("clear_all_module_information\n");
1864   2          //    T5L_Flash(0xA5,0Xe000, 0,1024);     //写0FLASH清除
1865   2          //    T5L_Flash(0xA5,0Xe000, 1024,1024);  //写0FLASH清除
1866   2          //    T5L_Flash(0xA5,0Xe000, 2048,1024);  //写0FLASH清除
1867   2          //    T5L_Flash(0xA5,0Xe000, 3072,1024);  //写0FLASH清除
1868   2          //    T5L_Flash(0xA5,0Xe000, 4096,1024);  //写0FLASH清除
1869   2          //    T5L_Flash(0xA5,0Xe000, 8192,768);   //写0FLASH清除
1870   2          for (i = 0; i < 8; i++)
1871   2          {
1872   3            T5L_Flash(0xA5, 0Xe000, 1024 * i, 1024); // 写0FLASH清除
C51 COMPILER V9.60.0.0   MODULE                                                            11/02/2023 18:49:06 PAGE 32  

1873   3          }
1874   2          T5L_Flash(0xA5, 0Xe000, 8192, 768);  // 写0FLASH清除
1875   2          T5L_Flash(0x5A, 0X3520, 0, 32 * 64); // 读为0
1876   2          T5L_Flash(0x5A, 0x3120, 0, 8 * 64);  // 读为0
1877   2          clear_arr_data(&g_var_module.module_adr, MODULE_NUB_LIMIT);
1878   2          // for (i = 0; i < 64; i++)
1879   2          // {
1880   2          //  write_dgusii_vp(0x3120 + 8 * i, (unsigned char *)module_default_name, 8);
1881   2          // }
1882   2          //    T5L_Flash(0x5A,0X3120, 0,1024); //读为0
1883   2          clear_key_value(0x1011, &key_nb);
1884   2        }
1885   1      }
1886          // 初始化密码
1887          void init_pwd_f(void)
1888          {
1889   1        unsigned char mask[4] = {0};
1890   1        unsigned char pwd_enable = 0;
1891   1        norflash_read(0x020002, (unsigned char *)&mask, 2);
1892   1      
1893   1        pwd_enable = read_dgus(PWD_SELECT_FRAME_ADR);
1894   1        if (0xff != mask[0])
1895   1        {
1896   2          init_pwd = read_dgus(0x2050);
1897   2        }
1898   1        else
1899   1        {
1900   2          T5L_Flash(0x5a, PWD_SELECT_FRAME_ADR, PWD_FLASH_ADR, 2); // 读密码使能
1901   2          T5L_Flash(0x5A, 0x2050, 0x020000, 2);                    // 从FLASH读密码
1902   2          init_pwd = read_dgus(0x2050);
1903   2        }
1904   1        // printf_tab(2, mask);
1905   1        // USER_PRINTF("-->read pwd enable is %bd\n", pwd_enable);
1906   1        // USER_PRINTF("-->read_pwd var is %d\n", init_pwd);
1907   1      }
1908          // 修改密码
1909          void change_pwd(unsigned short *pwd_init)
1910          {
1911   1        unsigned short key_nb = 0;
1912   1        unsigned char mask[4] = {0xff, 0xff, 0xff, 0xff};
1913   1        get_key_value(0x111e, &key_nb);
1914   1        if (1 == key_nb)
1915   1        {
1916   2          clear_key_value(0x111e, &key_nb);
1917   2          if (*pwd_init != read_dgus(0x2050))
1918   2          {
1919   3            *pwd_init = read_dgus(0x2050);
1920   3            T5L_Flash(0xA5, 0x2050, 0x020000, 2); // 写密码到FLASH
1921   3            norflash_write(0x020002, (unsigned char *)&mask, 2);
1922   3            USER_PRINTF("-->change password success!\n");
1923   3            printf_tab(2, mask);
1924   3          }
1925   2        }
1926   1      }
1927          // 选择密码使能
1928          void select_password_enable(void)
1929          {
1930   1        //  static unsigned char var_enable = 0;
1931   1        unsigned short key_nb = 0;
1932   1        unsigned char pwd_enable = 0xff;
1933   1        get_key_value(0x1242, &key_nb);
1934   1        if (1 == key_nb)
C51 COMPILER V9.60.0.0   MODULE                                                            11/02/2023 18:49:06 PAGE 33  

1935   1        {
1936   2      
1937   2          pwd_enable = check_or_not_frame(PWD_SELECT_FRAME_ADR);
1938   2          if (1 == check_constant(pwd_enable, &g_var_module.pwd_enable_bak))
1939   2          {
1940   3            T5L_Flash(0xA5, PWD_SELECT_FRAME_ADR, PWD_FLASH_ADR, 2); // 写密码使能到FLASH
1941   3                                                                     // USER_PRINTF("-->set password enable is %bd\n", pwd_enable);
1942   3          }
1943   2      
1944   2          clear_key_value(0x1242, &key_nb);
1945   2        }
1946   1      }
1947          // 初始化蜂鸣器参数
1948          void init_beep_enable(void)
1949          {
1950   1        unsigned char mask[4] = {0};
1951   1        unsigned char beep_enable = 0;
1952   1        norflash_read(0x020008, (unsigned char *)&mask, 2);
1953   1      
1954   1        if (0xff != mask[0])
1955   1        {
1956   2      
1957   2          USER_PRINTF("-->init_beep_error\n");
1958   2        }
1959   1        else
1960   1        {
1961   2      
1962   2          T5L_Flash(0x5A, BEEP_ENABLE_DGUS_ADR, 0x020006, 2); // 从FLASH读使能
1963   2        }
1964   1        beep_enable = read_dgus(BEEP_ENABLE_DGUS_ADR);
1965   1        sys_delay_about_ms(5);
1966   1        beep_ctrl(beep_enable); // control蜂鸣器声音
1967   1        USER_PRINTF("-->read beep enable is %bd\n", beep_enable);
1968   1      }
1969          // 选择蜂鸣器开关
1970          void select_beep_enable(void)
1971          {
1972   1        unsigned char mask[4] = {0xff, 0xff, 0xff, 0xff};
1973   1        unsigned short key_nb = 0;
1974   1        unsigned char beep_enable = 0xff;
1975   1        get_key_value(0x1241, &key_nb);
1976   1        if ((1 == key_nb))
1977   1        {
1978   2          beep_enable = check_or_not_frame(0x1800);
1979   2      
1980   2          if (1 == check_constant(beep_enable, &g_var_module.beep_enable_bak))
1981   2          {
1982   3            T5L_Flash(0xA5, BEEP_ENABLE_DGUS_ADR, 0x020006, 2); // 写蜂鸣器使能到FLASH
1983   3            norflash_write(0x020008, (unsigned char *)&mask, 2);
1984   3            beep_ctrl(beep_enable); // control蜂鸣器声音
1985   3                                    // USER_PRINTF("-->set beep enable is %bd,\n!", beep_enable);
1986   3          }
1987   2          clear_key_value(0x1241, &key_nb);
1988   2        }
1989   1      }
1990          // 清除密码
1991          void clear_pwd(unsigned short adr)
1992          {
1993   1        write_dgus(adr, 0xffff);
1994   1      }
1995          // 密码是否一致
1996          void check_whether_the_passwords_are_consistent(unsigned char password_enable, unsigned short pwd_input, u
C51 COMPILER V9.60.0.0   MODULE                                                            11/02/2023 18:49:06 PAGE 34  

             -nsigned short pwd_init)
1997          {
1998   1        if ((password_enable))
1999   1        {
2000   2          if ((pwd_init == pwd_input) || (SUPER_PASSWORD == pwd_input))
2001   2          {
2002   3            pic_set(1);
2003   3            clear_pwd(0x204f);
2004   3          }
2005   2          else
2006   2          {
2007   3          }
2008   2        }
2009   1      }
2010          // 主页判断密码
2011          void starup_page_pwd(unsigned char password_enable)
2012          {
2013   1        unsigned short key_nb = 0;
2014   1        get_key_value(0x111c, &key_nb);
2015   1        if ((1 == key_nb))
2016   1        {
2017   2          if (1 == password_enable)
2018   2          {
2019   3            pop_menu_key_ctrl(0x20);
2020   3          }
2021   2          else
2022   2          {
2023   3            pic_set(1);
2024   3            pic_page = 1;
2025   3          }
2026   2          clear_key_value(0x111c, &key_nb);
2027   2        }
2028   1        check_whether_the_passwords_are_consistent(password_enable, read_dgus(0x204f), init_pwd);
2029   1      }
2030          // 初始化背光参数 读flash
2031          void init_back_light_parameters(void)
2032          {
2033   1        unsigned char mask[4] = {0};
2034   1        unsigned char backlight_enable = 0;
2035   1        unsigned char work_light = 0;
2036   1        unsigned short sleep_time = 0;
2037   1        norflash_read(0x02000e, (unsigned char *)&mask, 2);
2038   1      
2039   1        if (0xff != mask[0])
2040   1        {
2041   2        }
2042   1        else
2043   1        {
2044   2          USER_PRINTF("-->read_back_light_parameters_successfully!\n");
2045   2          T5L_Flash(0x5A, 0x1704, 0x02000a, 2); // 从FLASH读数据
2046   2          T5L_Flash(0x5A, 0x2052, 0x02000c, 2); // 从FLASH读数据
2047   2        }
2048   1      
2049   1        backlight_enable = read_dgus(0x1704);
2050   1        // USER_PRINTF("-->read backlight enable is %bd\n", backlight_enable);
2051   1        sys_delay_about_ms(5);
2052   1        work_light = read_dgus(0x2052);
2053   1        // USER_PRINTF("-->read work_light is %bd\n", work_light);
2054   1        sys_delay_about_ms(5);
2055   1        sleep_time = read_dgus(0x2053) * 100;
2056   1        // USER_PRINTF("-->read sleep_time is %ds\n", sleep_time / 100);
2057   1        sys_delay_about_ms(5);
C51 COMPILER V9.60.0.0   MODULE                                                            11/02/2023 18:49:06 PAGE 35  

2058   1        back_light_ctrl(backlight_enable);
2059   1        sys_delay_about_ms(2);
2060   1        sys_led_config(work_light, 0, sleep_time);
2061   1      }
2062          // 保存背光参数到flash
2063          void save_back_light_parameters(void)
2064          {
2065   1        unsigned char mask[4] = {0xff, 0xff, 0xff, 0xff};
2066   1        T5L_Flash(0xA5, 0x1704, 0x02000a, 2); // 写自动锁屏参数到FLASH
2067   1        T5L_Flash(0xA5, 0x2052, 0x02000c, 2); // 写背光参数到FLASH
2068   1        norflash_write(0x02000e, (unsigned char *)&mask, 2);
2069   1        USER_PRINTF("-->save_back_light_parameters_successfully!\n");
2070   1      }
2071          /**
2072           * @brief 框选设置
2073           * @param {unsigned short} adr 框选地址
2074           * @return {*}框选是否选中 1选中  0未选中
2075           */
2076          unsigned char check_or_not_frame(unsigned short adr)
2077          {
2078   1        unsigned char check_var = 0;
2079   1        check_var = read_dgus(adr);
2080   1      
2081   1        check_var ^= 1;
2082   1        sys_delay_about_ms(3);
2083   1        write_dgus(adr, check_var);
2084   1        // USER_PRINTF("--> 0x%x check_var is %bd\n", adr, check_var);
2085   1        return check_var;
2086   1      }
2087          /**
2088           * @brief 锁屏控制
2089           * @return {*}
2090           */
2091          void lock_screen_enable_ctrl(void)
2092          {
2093   1        unsigned char backlight_enable = 0;
2094   1        unsigned short key_nb = 0;
2095   1        get_key_value(0x1240, &key_nb);
2096   1        if ((1 == key_nb))
2097   1        {
2098   2          backlight_enable = check_or_not_frame(0x1704);
2099   2      
2100   2          if (1 == check_constant(backlight_enable, &g_var_module.backlight_enable_bak))
2101   2          {
2102   3            back_light_ctrl(backlight_enable);
2103   3            USER_PRINTF("-->backlight_enable is %bd\n", backlight_enable);
2104   3            save_back_light_parameters();
2105   3          }
2106   2      
2107   2          clear_key_value(0x1240, &key_nb);
2108   2        }
2109   1      }
2110          // 背光设置
2111          void back_light_set(void)
2112          {
2113   1        unsigned short key_nb = 0;
2114   1        unsigned char back_enable = 0;
2115   1        unsigned char work_light = 0;
2116   1        unsigned short sleep_time = 0;
2117   1        get_key_value(0x1126, &key_nb);
2118   1        if ((1 == key_nb))
2119   1        {
C51 COMPILER V9.60.0.0   MODULE                                                            11/02/2023 18:49:06 PAGE 36  

2120   2          // back_enable = read_dgus(0x1128);
2121   2          // sys_delay_about_ms(5);
2122   2          work_light = read_dgus(0x2052);
2123   2          sys_delay_about_ms(5);
2124   2          sleep_time = read_dgus(0x2053) * 100;
2125   2          // USER_PRINTF("-->sleep_time is %d\n", sleep_time);
2126   2          sys_delay_about_ms(5);
2127   2          sys_led_config(work_light, 0, sleep_time);
2128   2          // back_light_ctrl(back_enable);
2129   2          // sys_delay_about_ms(5);
2130   2          // sys_led_config(work_light, 0, sleep_time);
2131   2          clear_key_value(0x1126, &key_nb);
2132   2          USER_PRINTF("-->back_light_set_ok!\n");
2133   2          save_back_light_parameters();
2134   2          pop_menu_key_ctrl(0xdd);
2135   2        }
2136   1      }
2137          // 黑屏切换到主页
2138          void black_screen_switches_to_home_page(void)
2139          {
2140   1        static unsigned char s_sta = 0;
2141   1        unsigned char read_data[2] = {0};
2142   1        read_dgusii_vp(0x31, read_data, 1);
2143   1        if (0 == s_sta)
2144   1        {
2145   2          //    s_sta = 1;
2146   2          if (0 == read_data[1]) // 屏幕亮度为0
2147   2          {
2148   3            s_sta = 1;
2149   3            pic_set(0);
2150   3          }
2151   2        }
2152   1        if (0 != read_data[1])
2153   1        {
2154   2          s_sta = 0;
2155   2        }
2156   1        //  printf_tab(2,read_data);
2157   1      }
2158          // 清除时控参数设置变量
2159          void clear_batch_set_var(void)
2160          {
2161   1        if (g_var_module.batch_send_count > MODULE_NUB_LIMIT)
2162   1        {
2163   2          g_var_module.batch_send_count = 0;
2164   2          g_var_module.batch_set_parameters_flag = 0;
2165   2          g_var_module.batch_send_cyc_time = 0;
2166   2          pop_menu_key_ctrl(0xf0); // 清除弹窗
2167   2          // pic_set(57);
2168   2          USER_PRINTF("-->time module batch set parameter successfully!\n");
2169   2        }
2170   1      }
2171          // 执行对应的动作函数
2172          void run_timing_module_parameter_set(module_t *p, unsigned char fun_execute_nb, unsigned char channel, uns
             -igned char parameter_set_sta)
2173          {
2174   1        switch (fun_execute_nb)
2175   1        {
2176   2        case 0:
2177   2          timing_module_parameter_ongitude_latitude_send(p);
2178   2          break;
2179   2        case 1:
2180   2          timing_module_parameter_time_send(p);
C51 COMPILER V9.60.0.0   MODULE                                                            11/02/2023 18:49:06 PAGE 37  

2181   2          break;
2182   2        case 2:
2183   2          timing_module_parameter_week_enable_channel_send(p, channel, parameter_set_sta);
2184   2          break;
2185   2        case 3:
2186   2          timing_module_parameter_solar_channel_send(p, channel, parameter_set_sta);
2187   2          break;
2188   2        case 4:
2189   2          timing_module_parameter_time_frame_channel_send(p, channel, parameter_set_sta);
2190   2          break;
2191   2        default:
2192   2          break;
2193   2        }
2194   1      }
2195          // 时控参数批量设置
2196          void timing_module_parameter_batch_send(void)
2197          {
2198   1        //  static unsigned char state = 0;
2199   1        //  unsigned char channel = 0;
2200   1        if (((1 <= g_var_module.batch_set_parameters_flag) && (g_var_module.batch_set_parameters_flag <= 5)) || (
             -0x13 == g_var_module.batch_set_parameters_flag) || (0x14 == g_var_module.batch_set_parameters_flag) || (0x15 == g_var_mo
             -dule.batch_set_parameters_flag)) // 不知为何会有异常值出现，排除异常的值
2201   1        {
2202   2          //    USER_PRINTF("-->batch_set_parameters_flag is %bd\n",g_var_module.batch_set_parameters_flag);
2203   2          if ((0 == g_var_module.batch_send_cyc_time) && (mbh_getState() == MBH_STATE_IDLE))
2204   2          {
2205   3            g_var_module.batch_send_cyc_time = 300;
2206   3            norflash_read(g_var_module.batch_send_count * 140, (unsigned char *)&temp_module, 140);
2207   3            if (FULL == temp_module.data_sta)
2208   3            {
2209   4              if ((temp_module.type == SINGLE_TIME_RELAY_MODULE) || (temp_module.type == DOUBLE_TIME_RELAY_MODULE))
2210   4              {
2211   5                //          USER_PRINTF("-->temp_module.adr is %bd\n",temp_module.adr);
2212   5                run_timing_module_parameter_set(&temp_module, g_var_module.parameter_set_fun_execute_nb, g_var_module
             -.parameter_set_channel_number, g_var_module.parameter_set_sta);
2213   5                g_var_module.batch_send_count++;
2214   5              }
2215   4              else
2216   4              {
2217   5                g_var_module.batch_send_count++;
2218   5              }
2219   4            }
2220   3            else
2221   3            {
2222   4              g_var_module.batch_send_count++;
2223   4            }
2224   3          }
2225   2        }
2226   1        clear_batch_set_var();
2227   1      }
2228          /**
2229           * @brief 批量设置时控参数
2230           * @return {*}
2231           */
2232          void batch_set_time_parameters(void)
2233          {
2234   1        unsigned short key_nb = 0;
2235   1        get_key_value(0x112a, &key_nb);
2236   1        if ((key_nb))
2237   1        {
2238   2          switch (key_nb)
2239   2          {
C51 COMPILER V9.60.0.0   MODULE                                                            11/02/2023 18:49:06 PAGE 38  

2240   3          case 1: // 经纬度设置
2241   3            g_var_module.parameter_set_fun_execute_nb = 0;
2242   3            g_var_module.parameter_set_channel_number = 0;
2243   3            g_var_module.parameter_set_sta = SINGLE_CHANNEL_STATE;
2244   3            break;
2245   3          case 2: // 时间设置
2246   3            g_var_module.parameter_set_fun_execute_nb = 1;
2247   3            g_var_module.parameter_set_channel_number = 0;
2248   3            g_var_module.parameter_set_sta = SINGLE_CHANNEL_STATE;
2249   3            break;
2250   3          case 3: // 假日设置
2251   3            g_var_module.parameter_set_fun_execute_nb = 2;
2252   3            g_var_module.parameter_set_channel_number = read_dgus(0x1B04);
2253   3            g_var_module.parameter_set_sta = BATCH_CHANNEL_STATE;
2254   3            break;
2255   3          case 4: // 光照度设置
2256   3            g_var_module.parameter_set_fun_execute_nb = 3;
2257   3            g_var_module.parameter_set_channel_number = read_dgus(0x1B0C);
2258   3            g_var_module.parameter_set_sta = BATCH_CHANNEL_STATE;
2259   3            break;
2260   3          case 5: // 时段设置
2261   3            g_var_module.parameter_set_fun_execute_nb = 4;
2262   3            g_var_module.parameter_set_channel_number = read_dgus(0x1B0F);
2263   3            g_var_module.parameter_set_sta = BATCH_CHANNEL_STATE;
2264   3            break;
2265   3          case 0x13: // 批量假日设置
2266   3            g_var_module.parameter_set_fun_execute_nb = 2;
2267   3            g_var_module.parameter_set_channel_number = 0;
2268   3            g_var_module.parameter_set_sta = BATCH_CHANNELS_STATE;
2269   3            break;
2270   3          case 0x14: // 批量光照度设置
2271   3            g_var_module.parameter_set_fun_execute_nb = 3;
2272   3            g_var_module.parameter_set_channel_number = 0;
2273   3            g_var_module.parameter_set_sta = BATCH_CHANNELS_STATE;
2274   3            break;
2275   3          case 0x15: // 批量时段设置
2276   3            g_var_module.parameter_set_fun_execute_nb = 4;
2277   3            g_var_module.parameter_set_channel_number = 0;
2278   3            g_var_module.parameter_set_sta = BATCH_CHANNELS_STATE;
2279   3            break;
2280   3          default:
2281   3            break;
2282   3          }
2283   2          pop_menu_key_ctrl(0x31); // 弹窗
2284   2          g_var_module.batch_set_parameters_flag = key_nb;
2285   2          // USER_PRINTF("-->batch_set_parameters_flag is %bd\n", g_var_module.batch_set_parameters_flag);
2286   2          clear_key_value(0x112a, &key_nb);
2287   2        }
2288   1      }
2289          // 自动检索设备命令
2290          void automatically_retrieve_cmd(void)
2291          {
2292   1      
2293   1        unsigned short key_nb = 0;
2294   1        get_key_value(0x112c, &key_nb);
2295   1        if ((1 == key_nb))
2296   1        {
2297   2          g_var_module.auto_retrieve_flag = 1;
2298   2          pop_menu_key_ctrl(0x0d); // 弹窗操作中
2299   2          clear_key_value(0x112c, &key_nb);
2300   2        }
2301   1      }
C51 COMPILER V9.60.0.0   MODULE                                                            11/02/2023 18:49:06 PAGE 39  

2302          // 读设备信息
2303          void read_device_information(unsigned char adr)
2304          {
2305   1        pack_data_send(&user_modbus, adr, MD_RD_HR, 14, 1);
2306   1      }
2307          // 自动检索设备
2308          void automatically_retrieve(void)
2309          {
2310   1        static unsigned char send_flag = 0;
2311   1        if (g_var_module.auto_retrieve_flag == 1)
2312   1        {
2313   2          //    g_var_module.retrieve_device_adr
2314   2          //    if( 0 == send_flag)
2315   2          //    {
2316   2          //      send_flag = 1;
2317   2          //      g_var_module.retrieve_device_adr = 1;
2318   2          //    }
2319   2          if ((0 == g_var_module.auto_retrieve_cyc_time) && (mbh_getState() == MBH_STATE_IDLE))
2320   2          {
2321   3            g_var_module.auto_retrieve_cyc_time = 500;
2322   3            read_device_information(g_var_module.retrieve_device_adr);
2323   3            g_var_module.retrieve_device_adr++;
2324   3            // USER_PRINTF("-->retrieve_device_adr is %bd\n", g_var_module.retrieve_device_adr);
2325   3          }
2326   2          //    if(mbh_getState() == MBH_STATE_REC_ERR)
2327   2          //    {
2328   2          //      g_var_module.auto_retrieve_cyc_time = 500;
2329   2          //    }
2330   2        }
2331   1      
2332   1        if ((g_var_module.retrieve_device_adr > DEVICE_NB)) //&&(0 == g_var_module.batch_send_cyc_time)
2333   1        {
2334   2          g_var_module.auto_retrieve_flag = 0;
2335   2          //    g_var_module.retrieve_device_adr = 1;
2336   2      
2337   2          send_flag = 1;
2338   2        }
2339   1        if ((1 == send_flag) && (0 == g_var_module.auto_retrieve_cyc_time))
2340   1        {
2341   2          send_flag = 0;
2342   2          g_var_module.retrieve_device_adr = 1;
2343   2          pop_menu_key_ctrl(0xf0); // 清除弹窗
2344   2          USER_PRINTF("-->auto add module over!\n");
2345   2        }
2346   1      }
2347          // 自动添加设备信息
2348          void auto_add_module(void)
2349          {
2350   1      
2351   1        unsigned char device_channel = 0;
2352   1        if (HR[DEVICE_INFOR_INDEX])
2353   1        {
2354   2          auto_module.index = find_index(0, MODULE_FLASH_SIZE, MODULE_NUB_LIMIT);
2355   2          device_channel = HR[DEVICE_INFOR_INDEX] & 0x0f;
2356   2          device_channel = device_channel > 14 ? 16 : device_channel;
2357   2          auto_module.adr = g_var_module.slave_adr;
2358   2          auto_module.channel_nb = device_channel;
2359   2          auto_module.data_sta = FULL;
2360   2          auto_module.type = (HR[DEVICE_INFOR_INDEX] >> 4) & 0x0f;
2361   2          sprintf(auto_module.module_name, "房间%bd", auto_module.adr);
2362   2          //    sprintf(auto_module.channel_name,"%s",default_module_channel_name);
2363   2          //    auto_module.module_name[strlen(auto_module.module_name)] = '\0';
C51 COMPILER V9.60.0.0   MODULE                                                            11/02/2023 18:49:06 PAGE 40  

2364   2      
2365   2          read_dgusii_vp(0xa008, (unsigned char *)&auto_module.channel_name, 8 * 16);
2366   2          // USER_PRINTF("-->auto_module.adr is %bd\n", auto_module.adr);
2367   2          // USER_PRINTF("-->auto_module.channel_nb is %bd\n", auto_module.channel_nb);
2368   2      
2369   2          //    snprintf(auto_module.channel_name, 256, auto_module.channel_name);
2370   2          //    USER_PRINTF("-->auto_module.adr is %s\n",auto_module.adr );
2371   2          //    USER_PRINTF("-->auto_module.adr is %bd\n",auto_module.adr );
2372   2          //    USER_PRINTF("-->auto_module.adr is %bd\n",auto_module.adr );
2373   2      
2374   2          norflash_write(auto_module.index * MODULE_FLASH_SIZE, (unsigned char *)&auto_module, MODULE_FLASH_SIZE);
             - // 存储flash
2375   2          write_dgusii_vp(0x3120 + 8 * auto_module.index, (unsigned char *)&auto_module.module_name, 8);           //
2376   2          display_module_information(&auto_module, auto_module.index);                                             // 显示模块信息
2377   2          USER_PRINTF("-->auto adding module successfully!\n");
2378   2          HR[DEVICE_INFOR_INDEX] = 0;
2379   2        }
2380   1      }
2381          #define BOARDCAST_ALL_ON_ADR 0X1B21
2382          #define BOARDCAST_ALL_OFF_ADR 0X1B22
2383          /**
2384           * @brief 模块控制广播全开全关
2385           * @return {*}
2386           */
2387          void module_all_ctrl(void)
2388          {
2389   1        unsigned short key_nb = 0;
2390   1        get_key_value(BOARDCAST_ALL_ON_ADR, &key_nb);
2391   1        if ((1 == key_nb))
2392   1        {
2393   2          set_master_send_hr(master_send_hr, 22, 0xffff);
2394   2          set_master_send_hr(master_send_hr, 23, (100));
2395   2          set_master_send_hr(master_send_hr, 24, (100));
2396   2          set_master_send_hr(master_send_hr, 25, (100));
2397   2          set_master_send_hr(master_send_hr, 26, (100));
2398   2          set_master_send_hr(master_send_hr, 27, ENTERPRISE);
2399   2          set_master_send_hr(master_send_hr, 28, 0);
2400   2          set_master_send_hr(master_send_hr, 29, 0);
2401   2          set_master_send_hr(master_send_hr, 30, 0);
2402   2          set_master_send_hr(master_send_hr, 31, 0xffff);
2403   2          set_master_send_hr(master_send_hr, 32, 0xffff);
2404   2          set_master_send_hr(master_send_hr, 33, ENTERPRISE);
2405   2          pack_data_send(&user_modbus, 0, MD_FR_MHR, 22, 13);
2406   2          clear_key_value(BOARDCAST_ALL_ON_ADR, &key_nb);
2407   2        }
2408   1        get_key_value(BOARDCAST_ALL_OFF_ADR, &key_nb);
2409   1        if ((1 == key_nb))
2410   1        {
2411   2          set_master_send_hr(master_send_hr, 22, 0xffff);
2412   2          set_master_send_hr(master_send_hr, 23, (0));
2413   2          set_master_send_hr(master_send_hr, 24, (0));
2414   2          set_master_send_hr(master_send_hr, 25, (0));
2415   2          set_master_send_hr(master_send_hr, 26, (0));
2416   2          set_master_send_hr(master_send_hr, 27, ENTERPRISE);
2417   2          set_master_send_hr(master_send_hr, 28, 0);
2418   2          set_master_send_hr(master_send_hr, 29, 0);
2419   2          set_master_send_hr(master_send_hr, 30, 0);
2420   2          set_master_send_hr(master_send_hr, 31, 0xffff);
2421   2          set_master_send_hr(master_send_hr, 32, 0);
2422   2          set_master_send_hr(master_send_hr, 33, ENTERPRISE);
2423   2          pack_data_send(&user_modbus, 0, MD_FR_MHR, 22, 13);
2424   2          clear_key_value(BOARDCAST_ALL_OFF_ADR, &key_nb);
C51 COMPILER V9.60.0.0   MODULE                                                            11/02/2023 18:49:06 PAGE 41  

2425   2        }
2426   1      }
2427          /**
2428           * @brief 返回页面
2429           * @return {*}
2430           */
2431          void return_page(void)
2432          {
2433   1        unsigned short key_nb = 0;
2434   1        get_key_value(0x1b23, &key_nb);
2435   1        if (key_nb)
2436   1        {
2437   2          pic_page = key_nb;
2438   2          clear_key_value(0x1b23, &key_nb);
2439   2        }
2440   1        get_key_value(0x1b24, &key_nb);
2441   1        if (1 == key_nb)
2442   1        {
2443   2          pic_set(pic_page);
2444   2          USER_PRINTF("-->%bd\n", pic_page);
2445   2          clear_key_value(0x1b24, &key_nb);
2446   2        }
2447   1      }
2448          // 模块配置
2449          void module_modify(void)
2450          {
2451   1        unsigned short page = 0;
2452   1        unsigned short size_struct = 0;
2453   1        page = read_pic();
2454   1        size_struct = sizeof(module_t);
2455   1        /*module edit page*/
2456   1        if (((page <= 16) && (page >= 5)) || (page == 63) || (page == 64) || ((page <= SCR_MODULE_4_CHANNEL_EDIT_
             -PAGE) && (page >= SINGLE_MODULE_4_CHANNEL_EDIT_PAGE)))
2457   1        {
2458   2          //    USER_PRINTF("-->page is %d\n", page);
2459   2          set_module_type();
2460   2          save_module_information(&module);
2461   2        }
2462   1        // set_selected_sequence_number(0x110c, 0x1104, 8);
2463   1        set_box_select(0x110c, 0x1400, 64, &module_key_nb_bak, &module_select_sta_bak);
2464   1        modifying_module_information(&module);
2465   1        clear_select_module_information();
2466   1        clear_all_module_information();
2467   1        timing_module_parameter_key_ctrl(&module, channel_number);
2468   1        display_timing_module_parameter(&module, channel_number);
2469   1        select_either_or_all();
2470   1        starup_page_pwd(read_dgus(PWD_SELECT_FRAME_ADR));
2471   1        change_pwd(&init_pwd);
2472   1        select_beep_enable();
2473   1        back_light_set();
2474   1      
2475   1        black_screen_switches_to_home_page();
2476   1        batch_set_time_parameters();
2477   1        automatically_retrieve_cmd();
2478   1        module_all_ctrl();
2479   1        return_page();
2480   1      }
2481          
2482          /**
2483           * @brief 初始化flash参数
2484           * @return {*}
2485           */
C51 COMPILER V9.60.0.0   MODULE                                                            11/02/2023 18:49:06 PAGE 42  

2486          void init_flash_parameters(void)
2487          {
2488   1        init_pwd_f();
2489   1        init_beep_enable();
2490   1        init_back_light_parameters();
2491   1        USER_PRINTF("-->read_flash_successfully\n");
2492   1        g_var_module.batch_set_parameters_flag = 0;
2493   1        g_var_module.retrieve_device_adr = 1;
2494   1        g_var_module.beep_enable_bak = 0xff;
2495   1        g_var_module.backlight_enable_bak = 0xff;
2496   1        g_var_module.pwd_enable_bak = 0xff;
2497   1      }
2498          /**
2499           * @brief 模拟按压触发
2500           * @return {*}
2501           */
2502          void simulate_touch(void)
2503          {
2504   1        unsigned short cmd = 0;
2505   1        write_dgus(0xd4, 0x5aa5);
2506   1        cmd = read_dgus(0xd4);
2507   1      
2508   1        write_dgus(0x00D5, 0x0001);
2509   1        write_dgus(0x00D6, 0x03E8);
2510   1        write_dgus(0x00D7, 0x03E8);
2511   1      
2512   1        while (cmd)
2513   1        {
2514   2          cmd = read_dgus(0xd4);
2515   2        }
2516   1      
2517   1        write_dgus(0xd4, 0x5aa5);
2518   1        write_dgus(0x00D5, 0x0002);
2519   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  14144    ----
   CONSTANT SIZE    =   1375    ----
   XDATA SIZE       =   2137     581
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
