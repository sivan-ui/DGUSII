C51 COMPILER V9.60.0.0   TIME_SCENE                                                        11/02/2023 16:36:11 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE TIME_SCENE
OBJECT MODULE PLACED IN .\OBJ\time_scene.obj
COMPILER INVOKED BY: C:\Keil_C51\C51\BIN\C51.EXE time_scene.c LARGE OMF2 OPTIMIZE(9,SIZE) BROWSE INCDIR(..\USER;..\FUNC_
                    -HANDLER;..\GUI_APP) DEBUG PRINT(.\OBJ\time_scene.lst) TABS(2) OBJECT(.\OBJ\time_scene.obj)

line level    source

   1          /*
   2           * @Author: xw.qu
   3           * @Date: 2023-08-31 09:22:43
   4           * @LastEditors: xw.qu
   5           * @LastEditTime: 2023-10-28 15:32:19
   6           * @FilePath: \USER\time_scene.c
   7           * @Description: module time scene modify
   8           *
   9           * Copyright (c) 2023 by xw.qu, All Rights Reserved.
  10           */
  11          #include "time_scene.h"
  12          #include "sys.h"
  13          #include "T5LLIB.h"
  14          timing_content_t timing_content[TIMING_SCENE_NUB_SIGNLE] = {0};
  15          timing_content_t temp_timing_content = {0};
  16          // timing_content_t save_timing_content = {0};
  17          time_scene_var_t time_scene_var;
  18          // time_module_scene_set_t temp_time_module_scene_set;
  19          // time_scene_set_t  temp_time_scene_set;
  20          unsigned short time_scene_key_nb_bak = 0;
  21          unsigned char time_scene_select_sta_bak = 0;
  22          // 打印定时内容数组
  23          void time_scene_init(void)
  24          {
  25   1        //  memset((unsigned char *)&save_timing_content,1,sizeof(timing_content_t));
  26   1        //  time_scene_var.adr = TIMING_SCENE_INFOR_FLASH_ADR_SATRT;
  27   1        //  USER_PRINTF("%ld\n",time_scene_var.adr);
  28   1      }
  29          void printf_temp_timing_content(timing_content_t *p_timing_content)
  30          {
  31   1        //  unsigned char i = 0;
  32   1        //  for( i = 0;i<index;i++)
  33   1        //  {
  34   1        USER_PRINTF("timing_content[%bd].time_scene_set.data_sta is %bd\n", p_timing_content->time_scene_set.inde
             -x, p_timing_content->time_scene_set.data_sta);
  35   1      
  36   1        //  }
  37   1      }
  38          void printf_timing_content(unsigned char index)
  39          {
  40   1        unsigned char i = 0;
  41   1        for (i = 0; i < index; i++)
  42   1        {
  43   2          USER_PRINTF("timing_content[%bd].time_scene_set.index is%bd, data_sta is %bd,week_enable is %bx,led_enab
             -le is %d,led_sta is %d\n",
  44   2                      i, timing_content[i].time_scene_set.index, timing_content[i].time_scene_set.data_sta, timing_conte
             -nt[i].time_scene_set.week_enable,
  45   2                      timing_content[i].time_scene_set.time_module_scene_set.led_enable, timing_content[i].time_scene_se
             -t.time_module_scene_set.led_sta);
  46   2        }
  47   1      }
  48          // 清除变量
  49          void clear_timing_scene_var(void)
  50          {
C51 COMPILER V9.60.0.0   TIME_SCENE                                                        11/02/2023 16:36:11 PAGE 2   

  51   1        unsigned char i = 0;
  52   1        for (i = 8; i < 11; i++)
  53   1        {
  54   2          write_dgus(0x108a + i, 0);
  55   2        }
  56   1        write_dgus(0x1098, 0);
  57   1        write_dgus(0x1099, 0);
  58   1        time_scene_var.module_select_sta = 0;
  59   1        time_scene_var.all_light_select_sta = 0;
  60   1        time_scene_var.scene_select_sta = 0;
  61   1        time_scene_var.all_light_on_sta = 0;
  62   1        time_scene_var.all_light_off_sta = 0;
  63   1        //  time_scene_var.page_bak = 0;
  64   1        //  memset(&timing_module,0,sizeof(timing_module));
  65   1      }
  66          // 清除单个定时内容变量
  67          void clear_single_timing_scene_content(timing_content_t *p_timing_content)
  68          {
  69   1        memset(p_timing_content, 0, sizeof(timing_content_t));
  70   1      }
  71          // 清除所有定时内容变量
  72          void clear_all_timing_scene_content(timing_content_t *p_timing_content)
  73          {
  74   1        unsigned char i = 0;
  75   1        for (i = 0; i < TIMING_SCENE_NUB_SIGNLE; i++)
  76   1        {
  77   2          clear_single_timing_scene_content(p_timing_content + i);
  78   2        }
  79   1      }
  80          //判断定时信息是否写满
  81          unsigned char get_blank_timing_scene_infor_index(void)
  82          {
  83   1        // return find_index(SCENE_INFOR_FLASH_ADR_SATRT,SCENC_INFOR_T_SIZE,SCENE_NUB);
  84   1        unsigned char i = 0;
  85   1        //  unsigned short temp_data = 0;
  86   1        // for (i = 0; i < TIMING_SCENE_NUB_SIGNLE; i++)
  87   1        for (i = 0; i < TIMING_SCENE_NUB_SIGNLE_LIMIT; i++)
  88   1        {
  89   2          if ((0 == timing_content[i].time_scene_set.data_sta))
  90   2          {
  91   3            USER_PRINTF("-->blank_timing_content_index is %bd\n", i);
  92   3            return i;
  93   3          }
  94   2        }
  95   1        return 0xff;
  96   1      }
  97          // 获取定时场景名称选中序号
  98          unsigned char get_timing_scene_name_select_sequence_number(void)
  99          {
 100   1        // return get_selected_sequence_number(0x10bb,16);
 101   1        return get_box_select_number(0x1500, 128);
 102   1      }
 103          // 设定定时场景名称选中序号
 104          void set_timing_scene_name_select_sequence_number(void)
 105          {
 106   1        // set_selected_sequence_number(0x10ba,0x10bb,16);
 107   1        set_box_select(0x10ba, 0x1500, 128, &time_scene_key_nb_bak, &time_scene_select_sta_bak);
 108   1      }
 109          // 获取日期使能
 110          unsigned char get_timing_data_enable(void)
 111          {
 112   1        return read_dgus(0x1091);
C51 COMPILER V9.60.0.0   TIME_SCENE                                                        11/02/2023 16:36:11 PAGE 3   

 113   1      }
 114          // 设置日期使能
 115          void set_timing_data_enable(time_scene_set_t *p_time_scene_set)
 116          {
 117   1        USER_PRINTF("-->data enable is %bd\n", p_time_scene_set->date_enable);
 118   1        write_dgus(0x1091, p_time_scene_set->date_enable);
 119   1      }
 120          // 获取星期使能 108a
 121          unsigned char get_timing_week_enable(unsigned short week_enable_adr)
 122          {
 123   1      
 124   1        return (read_dgus(week_enable_adr) | (read_dgus(week_enable_adr + 1) << 1) | (read_dgus(week_enable_adr +
             - 2) << 2) |
 125   1                (read_dgus(week_enable_adr + 3) << 3) | (read_dgus(week_enable_adr + 4) << 4) | (read_dgus(week_enabl
             -e_adr + 5) << 5) | (read_dgus(week_enable_adr + 6) << 6));
 126   1      }
 127          // 设置星期使能
 128          void set_timing_week_enable(time_scene_set_t *p_time_scene_set)
 129          {
 130   1        display_week_parameter(0x108a, p_time_scene_set->week_enable);
 131   1        //  unsigned char i = 0;
 132   1        //  USER_PRINTF("-->week enable is %bd\n",p_time_scene_set->week_enable);
 133   1        //  for( i = 0;i<7;i++)
 134   1        //  {
 135   1        //    write_dgus(0x108a+i,(p_time_scene_set->week_enable>>i)&0x01);
 136   1        //  }
 137   1      
 138   1        //  return (read_dgus(0x108a)|(read_dgus(0x108b)<<1)|(read_dgus(0x108c)<<2)|(read_dgus(0x108d)<<3)|(read_d
             -gus(0x108e)<<4)|(read_dgus(0x108f)<<5)|(read_dgus(0x1090)<<6));;
 139   1      }
 140          // 得到定时的信息
 141          void get_timing_set_infor(date_t *p_s_date, date_t *p_e_data, time_t *p_time, time_scene_set_t *p_time_sce
             -ne_set)
 142          {
 143   1      
 144   1        p_time_scene_set->date_enable = get_timing_data_enable();
 145   1        p_time_scene_set->week_enable = get_timing_week_enable(0x108a);
 146   1        p_time->hour = read_dgus(0x2007);
 147   1        p_time->min = read_dgus(0x2008);
 148   1        p_time->sec = 0;
 149   1        if (1 == p_time_scene_set->date_enable)
 150   1        {
 151   2          p_s_date->year = read_dgus(TIMING_SCENE_START_YEAR);
 152   2          p_s_date->month = read_dgus(TIMING_SCENE_START_MONTH);
 153   2          p_s_date->day = read_dgus(TIMING_SCENE_START_DAY);
 154   2      
 155   2          p_e_data->year = read_dgus(TIMING_SCENE_END_YEAR);
 156   2          p_e_data->month = read_dgus(TIMING_SCENE_END_MONTH);
 157   2          p_e_data->day = read_dgus(TIMING_SCENE_END_DAY);
 158   2        }
 159   1        // USER_PRINTF("-->data enable is %bd\n", p_time_scene_set->date_enable);
 160   1        // USER_PRINTF("-->week enable is %bd\n", p_time_scene_set->week_enable);
 161   1        // USER_PRINTF("-->execute time is %bd:%bd:%bd\n", p_time->hour, p_time->min, p_time->sec);
 162   1        // USER_PRINTF("-->execute start date is %d-%bd-%bd\n", p_s_date->year, p_s_date->month, p_s_date->day);
 163   1        // USER_PRINTF("-->execute end date is %d-%bd-%bd\n", p_e_data->year, p_e_data->month, p_e_data->day);
 164   1      }
 165          // unsigned char *get_scene_name(unsigned int adr,unsigned char index)
 166          //{
 167          //  unsigned char  scene_name[17] = {0};
 168          //  read_dgusii_vp(adr+(index-1)*8,(unsigned char *)scene_name,8);
 169          //  return scene_name;
 170          // }
C51 COMPILER V9.60.0.0   TIME_SCENE                                                        11/02/2023 16:36:11 PAGE 4   

 171          // 模块场景信息显示
 172          void dis_module_scene_infor(time_module_scene_set_t *p_time_module_scene_set)
 173          {
 174   1        unsigned char i = 0;
 175   1        unsigned char temp_tab[32] = {0};
 176   1        switch (p_time_module_scene_set->type)
 177   1        {
 178   2        case SINGLE_RELAY_MODULE:
 179   2        case SINGLE_TIME_RELAY_MODULE:
 180   2        case DOUBLE_RELAY_MODULE:
 181   2        case DOUBLE_TIME_RELAY_MODULE:
 182   2          for (i = 0; i < 16; i++)
 183   2          {
 184   3            temp_tab[2 * i + 1] = (p_time_module_scene_set->led_enable >> i) & 0x1;
 185   3            ;
 186   3          }
 187   2          write_dgusii_vp(0x109a, (unsigned char *)&temp_tab, 16);
 188   2          for (i = 0; i < 16; i++)
 189   2          {
 190   3            temp_tab[2 * i + 1] = (p_time_module_scene_set->led_sta >> i) & 0x1;
 191   3            ;
 192   3          }
 193   2          write_dgusii_vp(0x10aa, (unsigned char *)&temp_tab, 16);
 194   2      
 195   2          break;
 196   2        case VOL_DIM_MODULE:
 197   2          for (i = 0; i < 4; i++)
 198   2          {
 199   3            temp_tab[2 * i + 1] = p_time_module_scene_set->diming_enable >> i & 0x1;
 200   3          }
 201   2          write_dgusii_vp(0x10cd, (unsigned char *)&temp_tab, 4);
 202   2          write_dgusii_vp(0x10d1, (unsigned char *)&(p_time_module_scene_set->dimming_duty[0]), 4);
 203   2      
 204   2          break;
 205   2        case SCR_DIM_MODULE:
 206   2          for (i = 0; i < 4; i++)
 207   2          {
 208   3            temp_tab[2 * i + 1] = p_time_module_scene_set->diming_enable >> i & 0x1;
 209   3          }
 210   2          write_dgusii_vp(0x10d5, (unsigned char *)&temp_tab, 4);
 211   2      
 212   2          write_dgusii_vp(0x10d9, (unsigned char *)&(p_time_module_scene_set->dimming_duty[0]), 4);
 213   2      
 214   2          break;
 215   2        }
 216   1      }
 217          // 设置定时信息
 218          void set_timing_set_infor(date_t *p_s_date, date_t *p_e_data, time_t *p_time, time_scene_set_t *p_time_sce
             -ne_set)
 219          {
 220   1        set_timing_data_enable(p_time_scene_set);
 221   1        set_timing_week_enable(p_time_scene_set);
 222   1        //  set_timing_set_infor(p_s_date,p_e_data,p_time,p_time_scene_set);
 223   1        write_dgus(0x2007, p_time->hour);
 224   1        write_dgus(0x2008, p_time->min);
 225   1      
 226   1        if (1 == p_time_scene_set->date_enable)
 227   1        {
 228   2          write_dgus(TIMING_SCENE_START_YEAR, p_s_date->year);
 229   2          write_dgus(TIMING_SCENE_START_MONTH, p_s_date->month);
 230   2          write_dgus(TIMING_SCENE_START_DAY, p_s_date->day);
 231   2      
C51 COMPILER V9.60.0.0   TIME_SCENE                                                        11/02/2023 16:36:11 PAGE 5   

 232   2          write_dgus(TIMING_SCENE_END_YEAR, p_e_data->year);
 233   2          write_dgus(TIMING_SCENE_END_MONTH, p_e_data->month);
 234   2          write_dgus(TIMING_SCENE_END_DAY, p_e_data->day);
 235   2        }
 236   1      }
 237          
 238          void timing_scene_infor_save_flash(timing_content_t *p_timing_content)
 239          {
 240   1        // USER_PRINTF("--> save_flash_index is %bd\n", p_timing_content->time_scene_set.index);
 241   1        norflash_write(TIMING_SCENE_INFOR_FLASH_ADR_SATRT + (p_timing_content->time_scene_set.index) * SINGLE_TIM
             -ING_SCENC_INFOR_T_SIZE, (unsigned char *)p_timing_content, SINGLE_TIMING_SCENC_INFOR_T_SIZE);
 242   1        //  printf_temp_timing_content(&save_timing_content);
 243   1        //  norflash_write(abs(TIMING_SCENE_INFOR_FLASH_ADR_SATRT),(unsigned char *)(&save_timing_content),SINGLE_
             -TIMING_SCENC_INFOR_T_SIZE);
 244   1        USER_PRINTF("--> timing scene flash store ok\n");
 245   1      }
 246          // 清空定时场景信息内容
 247          void timing_scene_infor_clear(timing_content_t *p_timing_content)
 248          {
 249   1        T5L_Flash(0xA5, 0Xe000, TIMING_SCENE_INFOR_FLASH_ADR_SATRT, ALL_TIMING_SCENC_INFOR_T_SIZE); // 写0FLASH清
             -除
 250   1        T5L_Flash(0x5A, 0X6180, TIMING_SCENE_INFOR_FLASH_ADR_SATRT, 0x2300);                          // 读为0场景信息
 251   1      
 252   1        clear_all_timing_scene_content(p_timing_content);
 253   1      }
 254          // 删除定时单个信息内容
 255          void timing_scene_infor_delete(timing_content_t *p_timing_content, time_scene_set_t *p_time_scene)
 256          {
 257   1        // USER_PRINTF("flash delet index is %bd\n", p_time_scene->index);
 258   1        T5L_Flash(0xA5, 0Xe000, TIMING_SCENE_INFOR_FLASH_ADR_SATRT + (p_time_scene->index) * SINGLE_TIMING_SCENC_
             -INFOR_T_SIZE, SINGLE_TIMING_SCENC_INFOR_T_SIZE); // 写0FLASH清除
 259   1        T5L_Flash(0x5A, 0X6180 + (p_time_scene->index) * 80, TIMING_SCENE_INFOR_FLASH_ADR_SATRT, 0x50);                   
             -                                          // 读为0场景信息
 260   1        clear_single_timing_scene_content(p_timing_content);
 261   1      }
 262          // 继电器模块设置定时场景
 263          void timing_module_relay_scene_set(module_t *p, time_module_scene_set_t *p_time_module_scene)
 264          {
 265   1        //  unsigned short scene_led_enable = 0,scene_led_sta = 0;
 266   1        //  unsigned short led_hr_index_start = 0;
 267   1        unsigned char temp_tab[32] = {0};
 268   1        if ((SINGLE_RELAY_MODULE == p->type) || (SINGLE_TIME_RELAY_MODULE == p->type))
 269   1        {
 270   2          p_time_module_scene->led_hr_index_start = 337;
 271   2        }
 272   1        else if ((DOUBLE_RELAY_MODULE == p->type) || (DOUBLE_TIME_RELAY_MODULE == p->type))
 273   1        {
 274   2          p_time_module_scene->led_hr_index_start = 400;
 275   2        }
 276   1        else
 277   1        {
 278   2          return;
 279   2        }
 280   1      
 281   1        p_time_module_scene->type = p->type;
 282   1        p_time_module_scene->adr = p->adr;
 283   1        p_time_module_scene->channel_nb = p->channel_nb;
 284   1        p_time_module_scene->module_index = p->index;
 285   1      
 286   1        switch (p_time_module_scene->channel_nb)
 287   1        {
 288   2        case 4:
C51 COMPILER V9.60.0.0   TIME_SCENE                                                        11/02/2023 16:36:11 PAGE 6   

 289   2          read_dgusii_vp(0x109a, (unsigned char *)temp_tab, 16);
 290   2          p_time_module_scene->led_enable = temp_tab[1] | temp_tab[3] << 1 | temp_tab[5] << 2 | temp_tab[7] << 3;
 291   2          // USER_PRINTF("-->led_enable is -->0x%x\n", p_time_module_scene->led_enable);
 292   2          read_dgusii_vp(0x10aa, (unsigned char *)temp_tab, 16);
 293   2          p_time_module_scene->led_sta = temp_tab[1] | temp_tab[3] << 1 | temp_tab[5] << 2 | temp_tab[7] << 3;
 294   2          break;
 295   2        case 6:
 296   2          read_dgusii_vp(0x109a, (unsigned char *)temp_tab, 16);
 297   2          p_time_module_scene->led_enable = temp_tab[1] | temp_tab[3] << 1 | temp_tab[5] << 2 | temp_tab[7] << 3 |
             - temp_tab[9] << 4 | temp_tab[11] << 5;
 298   2          // USER_PRINTF("-->led_enable is -->0x%x\n", p_time_module_scene->led_enable);
 299   2          read_dgusii_vp(0x10aa, (unsigned char *)temp_tab, 16);
 300   2          p_time_module_scene->led_sta = temp_tab[1] | temp_tab[3] << 1 | temp_tab[5] << 2 | temp_tab[7] << 3 | te
             -mp_tab[9] << 4 | temp_tab[11] << 5;
 301   2          break;
 302   2        case 8:
 303   2          read_dgusii_vp(0x109a, (unsigned char *)temp_tab, 16);
 304   2          p_time_module_scene->led_enable = temp_tab[1] | temp_tab[3] << 1 | temp_tab[5] << 2 | temp_tab[7] << 3 |
             - temp_tab[9] << 4 | temp_tab[11] << 5 | temp_tab[13] << 6 | temp_tab[15] << 7;
 305   2          // USER_PRINTF("-->led_enable is -->0x%x\n", p_time_module_scene->led_enable);
 306   2          read_dgusii_vp(0x10aa, (unsigned char *)temp_tab, 16);
 307   2          p_time_module_scene->led_sta = temp_tab[1] | temp_tab[3] << 1 | temp_tab[5] << 2 | temp_tab[7] << 3 | te
             -mp_tab[9] << 4 | temp_tab[11] << 5 | temp_tab[13] << 6 | temp_tab[15] << 7;
 308   2          break;
 309   2        case 10:
 310   2          read_dgusii_vp(0x109a, (unsigned char *)temp_tab, 16);
 311   2          p_time_module_scene->led_enable = temp_tab[1] | temp_tab[3] << 1 | temp_tab[5] << 2 | temp_tab[7] << 3 |
             - temp_tab[9] << 4 | temp_tab[11] << 5 | temp_tab[13] << 6 | temp_tab[15] << 7 |
 312   2                                            temp_tab[17] << 8 | temp_tab[19] << 9;
 313   2          // USER_PRINTF("-->led_enable is -->0x%x\n", p_time_module_scene->led_enable);
 314   2          read_dgusii_vp(0x10aa, (unsigned char *)temp_tab, 16);
 315   2          p_time_module_scene->led_sta = temp_tab[1] | temp_tab[3] << 1 | temp_tab[5] << 2 | temp_tab[7] << 3 | te
             -mp_tab[9] << 4 | temp_tab[11] << 5 | temp_tab[13] << 6 | temp_tab[15] << 7 |
 316   2                                         temp_tab[17] << 8 | temp_tab[19] << 9;
 317   2        case 12:
 318   2          read_dgusii_vp(0x109a, (unsigned char *)temp_tab, 16);
 319   2          p_time_module_scene->led_enable = temp_tab[1] | temp_tab[3] << 1 | temp_tab[5] << 2 | temp_tab[7] << 3 |
             - temp_tab[9] << 4 | temp_tab[11] << 5 | temp_tab[13] << 6 | temp_tab[15] << 7 |
 320   2                                            temp_tab[17] << 8 | temp_tab[19] << 9 | temp_tab[21] << 10 | temp_tab[23] << 11;
 321   2          // USER_PRINTF("-->led_enable is -->0x%x\n", p_time_module_scene->led_enable);
 322   2          read_dgusii_vp(0x10aa, (unsigned char *)temp_tab, 16);
 323   2          p_time_module_scene->led_sta = temp_tab[1] | temp_tab[3] << 1 | temp_tab[5] << 2 | temp_tab[7] << 3 | te
             -mp_tab[9] << 4 | temp_tab[11] << 5 | temp_tab[13] << 6 | temp_tab[15] << 7 |
 324   2                                         temp_tab[17] << 8 | temp_tab[19] << 9 | temp_tab[21] << 10 | temp_tab[23] << 11;
 325   2          break;
 326   2        case 14:
 327   2          read_dgusii_vp(0x109a, (unsigned char *)temp_tab, 16);
 328   2          p_time_module_scene->led_enable = temp_tab[1] | temp_tab[3] << 1 | temp_tab[5] << 2 | temp_tab[7] << 3 |
             - temp_tab[9] << 4 | temp_tab[11] << 5 | temp_tab[13] << 6 | temp_tab[15] << 7 |
 329   2                                            temp_tab[17] << 8 | temp_tab[19] << 9 | temp_tab[21] << 10 | temp_tab[23] << 11 | temp_
             -tab[25] << 12 | temp_tab[27] << 13;
 330   2          // USER_PRINTF("-->led_enable is -->0x%x\n", p_time_module_scene->led_enable);
 331   2          read_dgusii_vp(0x10aa, (unsigned char *)temp_tab, 16);
 332   2          p_time_module_scene->led_sta = temp_tab[1] | temp_tab[3] << 1 | temp_tab[5] << 2 | temp_tab[7] << 3 | te
             -mp_tab[9] << 4 | temp_tab[11] << 5 | temp_tab[13] << 6 | temp_tab[15] << 7 |
 333   2                                         temp_tab[17] << 8 | temp_tab[19] << 9 | temp_tab[21] << 10 | temp_tab[23] << 11 | temp_t
             -ab[25] << 12 | temp_tab[27] << 13;
 334   2        case 16:
 335   2          read_dgusii_vp(0x109a, (unsigned char *)temp_tab, 16);
 336   2          p_time_module_scene->led_enable = temp_tab[1] | temp_tab[3] << 1 | temp_tab[5] << 2 | temp_tab[7] << 3 |
             - temp_tab[9] << 4 | temp_tab[11] << 5 | temp_tab[13] << 6 | temp_tab[15] << 7 |
 337   2                                            temp_tab[17] << 8 | temp_tab[19] << 9 | temp_tab[21] << 10 | temp_tab[23] << 11 | temp_
C51 COMPILER V9.60.0.0   TIME_SCENE                                                        11/02/2023 16:36:11 PAGE 7   

             -tab[25] << 12 | temp_tab[27] << 13 | temp_tab[29] << 14 | temp_tab[31] << 15;
 338   2          // USER_PRINTF("-->led_enable is -->0x%x\n", p_time_module_scene->led_enable);
 339   2          read_dgusii_vp(0x10aa, (unsigned char *)temp_tab, 16);
 340   2          p_time_module_scene->led_sta = temp_tab[1] | temp_tab[3] << 1 | temp_tab[5] << 2 | temp_tab[7] << 3 | te
             -mp_tab[9] << 4 | temp_tab[11] << 5 | temp_tab[13] << 6 | temp_tab[15] << 7 |
 341   2                                         temp_tab[17] << 8 | temp_tab[19] << 9 | temp_tab[21] << 10 | temp_tab[23] << 11 | temp_t
             -ab[25] << 12 | temp_tab[27] << 13 | temp_tab[29] << 14 | temp_tab[31] << 15;
 342   2          break;
 343   2        }
 344   1      
 345   1        // USER_PRINTF("-->led_sta is -->0x%x\n", p_time_module_scene->led_sta);
 346   1        USER_PRINTF("-->module_relay_scene_set\n");
 347   1      }
 348          
 349          // 设置场景调光模块信息
 350          void timing_module_dim_scene_set(module_t *p, time_module_scene_set_t *p_time_module_scene)
 351          {
 352   1        unsigned short scene_dim_enable = 0;
 353   1        unsigned short scene_dim_enable_adr = 0, scene_dim_gear_adr = 0;
 354   1        unsigned char temp_tab[8] = {0}, dim_tab[4] = {0};
 355   1        if ((VOL_DIM_MODULE == p->type))
 356   1        {
 357   2          scene_dim_enable_adr = 0x10cd;
 358   2          scene_dim_gear_adr = 0x10d1;
 359   2        }
 360   1        else if ((SCR_DIM_MODULE == p->type))
 361   1        {
 362   2          scene_dim_enable_adr = 0x10d5;
 363   2          scene_dim_gear_adr = 0x10d9;
 364   2        }
 365   1        else
 366   1        {
 367   2          return;
 368   2        }
 369   1        p_time_module_scene->type = p->type;
 370   1        p_time_module_scene->adr = p->adr;
 371   1        p_time_module_scene->channel_nb = p->channel_nb;
 372   1        p_time_module_scene->module_index = p->index;
 373   1      
 374   1        read_dgusii_vp(scene_dim_enable_adr, (unsigned char *)temp_tab, 4);
 375   1        p_time_module_scene->diming_enable = scene_dim_enable = temp_tab[1] | temp_tab[3] << 1 | temp_tab[5] << 2
             - | temp_tab[7] << 3;
 376   1        // USER_PRINTF("-->diming_enable is--->%x\n", scene_dim_enable);
 377   1        read_dgusii_vp(scene_dim_gear_adr, (unsigned char *)temp_tab, 4);
 378   1        p_time_module_scene->dimming_duty[0] = dim_tab[0] = temp_tab[1];
 379   1        p_time_module_scene->dimming_duty[1] = dim_tab[1] = temp_tab[3];
 380   1        p_time_module_scene->dimming_duty[2] = dim_tab[2] = temp_tab[5];
 381   1        p_time_module_scene->dimming_duty[3] = dim_tab[3] = temp_tab[7];
 382   1        // USER_PRINTF("-->dimming_duty is");
 383   1        // printf_tab(4, dim_tab);
 384   1      }
 385          // 继电器模块定时发送场景
 386          void timing_module_relay_scene_send(time_module_scene_set_t *p_time_module_scene)
 387          {
 388   1        if ((SINGLE_RELAY_MODULE == p_time_module_scene->type) || (SINGLE_TIME_RELAY_MODULE == p_time_module_scen
             -e->type) || (DOUBLE_RELAY_MODULE == p_time_module_scene->type) || (DOUBLE_TIME_RELAY_MODULE == p_time_module_scene->type
             -))
 389   1        {
 390   2          set_master_send_hr(master_send_hr, 31, p_time_module_scene->led_enable);
 391   2          set_master_send_hr(master_send_hr, 32, p_time_module_scene->led_sta);
 392   2          set_master_send_hr(master_send_hr, 33, ENTERPRISE);
 393   2          pack_data_send(&user_modbus, p_time_module_scene->adr, MD_FR_MHR, 31, 3);
C51 COMPILER V9.60.0.0   TIME_SCENE                                                        11/02/2023 16:36:11 PAGE 8   

 394   2        }
 395   1        else
 396   1        {
 397   2          return;
 398   2        }
 399   1      }
 400          // 调光模块定时发送场景
 401          void timing_module_dim_scene_send(time_module_scene_set_t *p_time_module_scene)
 402          {
 403   1        if ((VOL_DIM_MODULE == p_time_module_scene->type) || (SCR_DIM_MODULE == p_time_module_scene->type))
 404   1        {
 405   2          set_master_send_hr(master_send_hr, 22, p_time_module_scene->diming_enable);
 406   2          set_master_send_hr(master_send_hr, 23, p_time_module_scene->dimming_duty[0]);
 407   2          set_master_send_hr(master_send_hr, 24, p_time_module_scene->dimming_duty[1]);
 408   2          set_master_send_hr(master_send_hr, 25, p_time_module_scene->dimming_duty[2]);
 409   2          set_master_send_hr(master_send_hr, 26, p_time_module_scene->dimming_duty[3]);
 410   2          pack_data_send(&user_modbus, p_time_module_scene->adr, MD_FR_MHR, 22, 6);
 411   2        }
 412   1        else
 413   1        {
 414   2          return;
 415   2        }
 416   1      }
 417          // 显示继电器模块界面
 418          void display_relay_timing_scene_interface(module_t *p)
 419          {
 420   1        write_dgus(0x2011, p->adr);
 421   1        write_dgus(0x2012, p->channel_nb);
 422   1        write_dgusii_vp(0x2013, (unsigned char *)&p->module_name, 8);
 423   1        write_dgusii_vp(0x3f0a, (unsigned char *)&p->channel_name, 8 * 16);
 424   1        // USER_PRINTF("display module index is %bd\n", p->index);
 425   1        switch (p->channel_nb)
 426   1        {
 427   2        case 4:
 428   2          time_scene_var.page_bak = 47;
 429   2      
 430   2          break;
 431   2        case 6:
 432   2          time_scene_var.page_bak = 74;
 433   2      
 434   2          break;
 435   2        case 8:
 436   2          time_scene_var.page_bak = 48;
 437   2      
 438   2          break;
 439   2        case 10:
 440   2          time_scene_var.page_bak = 72;
 441   2      
 442   2          break;
 443   2        case 12:
 444   2          time_scene_var.page_bak = 49;
 445   2      
 446   2          break;
 447   2        case 14:
 448   2          time_scene_var.page_bak = 73;
 449   2      
 450   2        case 16:
 451   2          time_scene_var.page_bak = 50;
 452   2      
 453   2          break;
 454   2        default:
 455   2          break;
C51 COMPILER V9.60.0.0   TIME_SCENE                                                        11/02/2023 16:36:11 PAGE 9   

 456   2        }
 457   1        pic_set(time_scene_var.page_bak);
 458   1      }
 459          // 显示调光模块界面
 460          void display_dim_timing_scene_interface(module_t *p)
 461          {
 462   1        write_dgus(0x2011, p->adr);
 463   1        write_dgus(0x2012, p->channel_nb);
 464   1        write_dgusii_vp(0x2013, (unsigned char *)&p->module_name, 8);
 465   1        write_dgusii_vp(0x3f0a, (unsigned char *)&p->channel_name, 8 * 16);
 466   1        // USER_PRINTF("display module index is %bd\n", p->index);
 467   1        switch (p->type)
 468   1        {
 469   2        case VOL_DIM_MODULE:
 470   2          pic_set(TIMING_SCENE_DIM_PAGE);
 471   2          time_scene_var.page_bak = TIMING_SCENE_DIM_PAGE;
 472   2          break;
 473   2        case SCR_DIM_MODULE:
 474   2          pic_set(TIMING_SCENE_SCE_PAGE);
 475   2          time_scene_var.page_bak = TIMING_SCENE_SCE_PAGE;
 476   2          break;
 477   2        default:
 478   2          break;
 479   2        }
 480   1      }
 481          // 显示具体定时场景执行信息
 482          void display_timing_scene_infor(timing_content_t *p_timing_content)
 483          {
 484   1        char mod_infom_tab[181] = {0};
 485   1        unsigned char module_name_1[17] = {0};
 486   1        unsigned char led_on_tb[49] = {0};
 487   1        unsigned char led_off_tb[49] = {0};
 488   1        unsigned short on_sta = 0, off_sta = 0;
 489   1        unsigned char i = 0, j = 0, k = 0, l = 0, m = 0;
 490   1        unsigned char dim_duty_tb[40] = {0};
 491   1        unsigned char dim_duty_str[10] = {0};
 492   1        unsigned char str_len_cal = 0;
 493   1        unsigned char str_adr = 0;
 494   1        unsigned short str_count = 0;
 495   1        char channel[48] = "01,02,03,04,05,06,07,08,09,10,11,12,13,14,15,16,";
 496   1        char week_tb[35] = "周一,周二,周三\xFD,周四,周五,周六,周日,"; // 具体方法：遇到无法显示字符时在其后加\xFD
 497   1        char temp_week_tb[36] = {0};
 498   1        module_t module_read = {0};
 499   1        unsigned char sce_name[16] = "";
 500   1        char scene_name1[20] = {""};
 501   1      
 502   1        //  p_timing_content->time_scene_set.index = index;
 503   1        //  printf("%s\n",week_tb);
 504   1        if (MODULE_TIME == p_timing_content->time_scene_set.time_scene_exectue_type)
 505   1        {
 506   2          if ((p_timing_content->time_scene_set.time_module_scene_set.type < 2) || (4 == p_timing_content->time_sc
             -ene_set.time_module_scene_set.type) || (5 == p_timing_content->time_scene_set.time_module_scene_set.type))
 507   2          {
 508   3            on_sta = p_timing_content->time_scene_set.time_module_scene_set.led_enable & (p_timing_content->time_sc
             -ene_set.time_module_scene_set.led_sta);
 509   3            // USER_PRINTF("-->on_sta is 0x%x\n", on_sta);
 510   3            off_sta = p_timing_content->time_scene_set.time_module_scene_set.led_enable & (~p_timing_content->time_
             -scene_set.time_module_scene_set.led_sta);
 511   3            // USER_PRINTF("-->off_sta is 0x%x\n", off_sta);
 512   3            for (i = 0; i < 16; i++)
 513   3            {
 514   4              if (GET_BIT(on_sta, i))
C51 COMPILER V9.60.0.0   TIME_SCENE                                                        11/02/2023 16:36:11 PAGE 10  

 515   4              {
 516   5                strncpy(led_on_tb + j * 3, &channel[i * 3], 3);
 517   5                j++;
 518   5              }
 519   4            }
 520   3            for (i = 0; i < 16; i++)
 521   3            {
 522   4              if (GET_BIT(off_sta, i))
 523   4              {
 524   5                strncpy(led_off_tb + k * 3, &channel[i * 3], 3);
 525   5                k++;
 526   5              }
 527   4            }
 528   3            // USER_PRINTF("-->led_on_tb is %s\n", led_on_tb);
 529   3            // USER_PRINTF("-->led_off_tb is %s\n", led_off_tb);
 530   3            //    strncpy(module_name_1,&module_name_tab[p_scenc_infor->type],8);
 531   3          }
 532   2          else
 533   2          {
 534   3            for (i = 0; i < 4; i++)
 535   3            {
 536   4              if (GET_BIT(p_timing_content->time_scene_set.time_module_scene_set.diming_enable, i))
 537   4              {
 538   5      
 539   5                sprintf(dim_duty_str, "%d%%;", p_timing_content->time_scene_set.time_module_scene_set.type == 2 ? p_t
             -iming_content->time_scene_set.time_module_scene_set.dimming_duty[i] * 10 : p_timing_content->time_scene_set.time_module_
             -scene_set.dimming_duty[i]);
 540   5      
 541   5                str_len_cal = strlen(dim_duty_str);
 542   5                // USER_PRINTF("-->dim_duty_str str_len_cal is %bd\n", str_len_cal);
 543   5                strncpy(dim_duty_tb + str_adr, &channel[i * 3], 3);
 544   5                str_adr += 3;
 545   5                // USER_PRINTF("-->dim_duty_str is %s\n", dim_duty_str);
 546   5                strncpy(dim_duty_tb + str_adr, &dim_duty_str, str_len_cal);
 547   5                str_adr += str_len_cal;
 548   5                l++;
 549   5              }
 550   4            }
 551   3            // USER_PRINTF("-->dim_duty_infor is %s\n", dim_duty_tb);
 552   3            //    strncpy(module_name_1,&module_name_tab[p_scenc_infor->type],10);
 553   3          }
 554   2        }
 555   1        else if (ALL_ON_OFF_TIME == p_timing_content->time_scene_set.time_scene_exectue_type)
 556   1        {
 557   2        }
 558   1        else if (SCENE_TIME == p_timing_content->time_scene_set.time_scene_exectue_type)
 559   1        {
 560   2        }
 561   1        else
 562   1        {
 563   2        }
 564   1        for (i = 0; i < 7; i++)
 565   1        {
 566   2          if ((p_timing_content->time_scene_set.week_enable >> i) & 0x01)
 567   2          {
 568   3            //      USER_PRINTF("week%bd enable\n",i+1);
 569   3            strncpy(temp_week_tb + m * 5, &week_tb[5 * i], 5);
 570   3            //      USER_PRINTF("week_tb is %s\n",week_tb[i]);
 571   3            m++;
 572   3          }
 573   2        }
 574   1        // USER_PRINTF("-->temp_week_tb is %s\n", temp_week_tb);
C51 COMPILER V9.60.0.0   TIME_SCENE                                                        11/02/2023 16:36:11 PAGE 11  

 575   1        // USER_PRINTF("-->display_scene_infor p_scenc_infor->module_index is %bd\n", p_timing_content->time_scen
             -e_set.time_module_scene_set.module_index);
 576   1        norflash_read((p_timing_content->time_scene_set.time_module_scene_set.module_index) * 140, (unsigned char
             - *)&module_read, 140);
 577   1      
 578   1        strncpy(module_name_1, &module_read.module_name[0], 16);
 579   1        strrpl(module_name_1, " ", "");
 580   1      
 581   1        if (0 == p_timing_content->time_scene_set.date_enable)
 582   1        {
 583   2          if ((on_sta) && (off_sta))
 584   2          {
 585   3            sprintf(mod_infom_tab, "地址:%bd;%bd路;%s开;%s关,执行时间:%s%bd:%02bd;模块:%s", p_timing_content->time_
             -scene_set.time_module_scene_set.adr, p_timing_content->time_scene_set.time_module_scene_set.channel_nb, led_on_tb, led_o
             -ff_tb, temp_week_tb, p_timing_content->exectue_time.hour, p_timing_content->exectue_time.min, module_name_1);
 586   3          }
 587   2          else if ((on_sta) && (0 == off_sta))
 588   2          {
 589   3            sprintf(mod_infom_tab, "地址:%bd;%bd路;%s开,执行时间:%s%bd:%02bd;模块:%s", p_timing_content->time_scene
             -_set.time_module_scene_set.adr, p_timing_content->time_scene_set.time_module_scene_set.channel_nb, led_on_tb, temp_week_
             -tb, p_timing_content->exectue_time.hour, p_timing_content->exectue_time.min, module_name_1);
 590   3          }
 591   2          else if ((0 == on_sta) && (off_sta))
 592   2          {
 593   3            sprintf(mod_infom_tab, "地址:%bd;%bd路;%s关,执行时间:%s%bd:%02bd;模块:%s", p_timing_content->time_scene
             -_set.time_module_scene_set.adr, p_timing_content->time_scene_set.time_module_scene_set.channel_nb, led_off_tb, temp_week
             -_tb, p_timing_content->exectue_time.hour, p_timing_content->exectue_time.min, module_name_1);
 594   3          }
 595   2          else if (p_timing_content->time_scene_set.time_module_scene_set.diming_enable)
 596   2          {
 597   3            sprintf(mod_infom_tab, "地址:%bd;%bd路;%s,执行时间:%s%bd:%02bd;模块:%s", p_timing_content->time_scene_s
             -et.time_module_scene_set.adr, p_timing_content->time_scene_set.time_module_scene_set.channel_nb, dim_duty_tb, temp_week_
             -tb, p_timing_content->exectue_time.hour, p_timing_content->exectue_time.min, module_name_1);
 598   3          }
 599   2          else if (ALL_ON_OFF_TIME == p_timing_content->time_scene_set.time_scene_exectue_type)
 600   2          {
 601   3            if (ALL_ON == p_timing_content->time_scene_set.all_on_off_sta)
 602   3            {
 603   4              sprintf(mod_infom_tab, "执行时间:%s%bd:%02bd;动作:全开", temp_week_tb, p_timing_content->exectue_time.
             -hour, p_timing_content->exectue_time.min);
 604   4            }
 605   3            else if (ALL_OFF == p_timing_content->time_scene_set.all_on_off_sta)
 606   3            {
 607   4              sprintf(mod_infom_tab, "执行时间:%s%bd:%02bd;动作:全关", temp_week_tb, p_timing_content->exectue_time.
             -hour, p_timing_content->exectue_time.min);
 608   4            }
 609   3            else
 610   3            {
 611   4              sprintf(mod_infom_tab, "执行时间:%s%bd:%02bd;无动作", temp_week_tb, p_timing_content->exectue_time.hou
             -r, p_timing_content->exectue_time.min);
 612   4            }
 613   3          }
 614   2          else if (SCENE_TIME == p_timing_content->time_scene_set.time_scene_exectue_type)
 615   2          {
 616   3            if (0 == p_timing_content->time_scene_set.scene_name_index)
 617   3            {
 618   4              sprintf(mod_infom_tab, "执行时间:%s%bd:%02bd;无执行场景", temp_week_tb, p_timing_content->exectue_time
             -.hour, p_timing_content->exectue_time.min);
 619   4            }
 620   3            else
 621   3            {
 622   4              read_dgusii_vp(0x3320 + (p_timing_content->time_scene_set.scene_name_index - 1) * 8, (unsigned char *)
C51 COMPILER V9.60.0.0   TIME_SCENE                                                        11/02/2023 16:36:11 PAGE 12  

             -sce_name, 8);
 623   4              // USER_PRINTF("-->scene_name is %s\n", sce_name);
 624   4              str_count = sprintf(mod_infom_tab, "执行时间:%s%bd:%02bd;执行场景:%s", temp_week_tb, p_timing_content-
             ->exectue_time.hour, p_timing_content->exectue_time.min, sce_name);
 625   4              //        USER_PRINTF("-->mod_infom_tab is %s\n",sce_name);
 626   4              //        USER_PRINTF("-->str_count is %d\n",str_count);
 627   4              //        sprintf(mod_infom_tab+str_count,"%s;执行场景:",sce_name);
 628   4            }
 629   3          }
 630   2      
 631   2          else
 632   2          {
 633   3            sprintf(mod_infom_tab, "地址:%bd;%bd路;未配置场景,执行时间:%s%bd:%02bd;%s", p_timing_content->time_scen
             -e_set.time_module_scene_set.adr, p_timing_content->time_scene_set.time_module_scene_set.channel_nb, temp_week_tb, p_timi
             -ng_content->exectue_time.hour, p_timing_content->exectue_time.min, module_name_1);
 634   3          }
 635   2        }
 636   1        else
 637   1        {
 638   2          if ((on_sta) && (off_sta))
 639   2          {
 640   3            sprintf(mod_infom_tab, "地址:%bd;%bd路;%s开;%s关;时间:%d-%bd-%bd~%d-%bd-%bd,%s%bd:%02bd;模块:%s", p_tim
             -ing_content->time_scene_set.time_module_scene_set.adr, p_timing_content->time_scene_set.time_module_scene_set.channel_nb
             -, led_on_tb, led_off_tb, p_timing_content->start_date.year, p_timing_content->start_date.month, p_timing_content->start_
             -date.day, p_timing_content->end_date.year, p_timing_content->end_date.month, p_timing_content->end_date.day, temp_week_t
             -b, p_timing_content->exectue_time.hour, p_timing_content->exectue_time.min, module_name_1);
 641   3          }
 642   2          else if ((on_sta) && (0 == off_sta))
 643   2          {
 644   3            sprintf(mod_infom_tab, "地址:%bd;%bd路;%s开;时间:%d-%bd-%bd~%d-%bd-%bd,%s%bd:%02bd;模块:%s", p_timing_c
             -ontent->time_scene_set.time_module_scene_set.adr, p_timing_content->time_scene_set.time_module_scene_set.channel_nb, led
             -_on_tb, p_timing_content->start_date.year, p_timing_content->start_date.month, p_timing_content->start_date.day, p_timin
             -g_content->end_date.year, p_timing_content->end_date.month, p_timing_content->end_date.day, temp_week_tb, p_timing_conte
             -nt->exectue_time.hour, p_timing_content->exectue_time.min, module_name_1);
 645   3          }
 646   2          else if ((0 == on_sta) && (off_sta))
 647   2          {
 648   3            sprintf(mod_infom_tab, "地址:%bd;%bd路;%s关;时间:%d-%bd-%bd~%d-%bd-%bd,%s%bd:%02bd;模块:%s", p_timing_c
             -ontent->time_scene_set.time_module_scene_set.adr, p_timing_content->time_scene_set.time_module_scene_set.channel_nb, led
             -_off_tb, p_timing_content->start_date.year, p_timing_content->start_date.month, p_timing_content->start_date.day, p_timi
             -ng_content->end_date.year, p_timing_content->end_date.month, p_timing_content->end_date.day, temp_week_tb, p_timing_cont
             -ent->exectue_time.hour, p_timing_content->exectue_time.min, module_name_1);
 649   3          }
 650   2          else if (p_timing_content->time_scene_set.time_module_scene_set.diming_enable)
 651   2          {
 652   3            sprintf(mod_infom_tab, "地址:%bd;%bd路;%s;时间:%d-%bd-%bd~%d-%bd-%bd,%s%bd:%02bd;模块:%s", p_timing_con
             -tent->time_scene_set.time_module_scene_set.adr, p_timing_content->time_scene_set.time_module_scene_set.channel_nb, dim_d
             -uty_tb, p_timing_content->start_date.year, p_timing_content->start_date.month, p_timing_content->start_date.day, p_timin
             -g_content->end_date.year, p_timing_content->end_date.month, p_timing_content->end_date.day, temp_week_tb, p_timing_conte
             -nt->exectue_time.hour, p_timing_content->exectue_time.min, module_name_1);
 653   3          }
 654   2          else if (ALL_ON_OFF_TIME == p_timing_content->time_scene_set.time_scene_exectue_type)
 655   2          {
 656   3            if (ALL_ON == p_timing_content->time_scene_set.all_on_off_sta)
 657   3            {
 658   4              sprintf(mod_infom_tab, "执行时间:%s%bd:%02bd;动作:全开", temp_week_tb, p_timing_content->exectue_time.
             -hour, p_timing_content->exectue_time.min);
 659   4            }
 660   3            else if (ALL_OFF == p_timing_content->time_scene_set.all_on_off_sta)
 661   3            {
 662   4              sprintf(mod_infom_tab, "执行时间:%s%bd:%02bd;动作:全关", temp_week_tb, p_timing_content->exectue_time.
             -hour, p_timing_content->exectue_time.min);
C51 COMPILER V9.60.0.0   TIME_SCENE                                                        11/02/2023 16:36:11 PAGE 13  

 663   4            }
 664   3            else
 665   3            {
 666   4              sprintf(mod_infom_tab, "执行时间:%s%bd:%02bd;无动作", temp_week_tb, p_timing_content->exectue_time.hou
             -r, p_timing_content->exectue_time.min);
 667   4            }
 668   3          }
 669   2          else if (SCENE_TIME == p_timing_content->time_scene_set.time_scene_exectue_type)
 670   2          {
 671   3            if (0 == p_timing_content->time_scene_set.scene_name_index)
 672   3            {
 673   4              sprintf(mod_infom_tab, "执行时间:%s%bd:%02bd;无执行场景", temp_week_tb, p_timing_content->exectue_time
             -.hour, p_timing_content->exectue_time.min);
 674   4            }
 675   3            else
 676   3            {
 677   4              sprintf(mod_infom_tab, "执行时间:%s%bd:%02bd;执行场景:%bd\n", temp_week_tb, p_timing_content->exectue_
             -time.hour, p_timing_content->exectue_time.min, p_timing_content->time_scene_set.scene_name_index);
 678   4            }
 679   3          }
 680   2          else
 681   2          {
 682   3            sprintf(mod_infom_tab, "地址:%bd;%bd路;未配置场景;时间:%d-%bd-%bd~%d-%bd-%bd,%s%bd:%02bd;%s;",  p_timin
             -g_content->time_scene_set.time_module_scene_set.adr, p_timing_content->time_scene_set.time_module_scene_set.channel_nb, 
             -p_timing_content->start_date.year, p_timing_content->start_date.month, p_timing_content->start_date.day, p_timing_conten
             -t->end_date.year, p_timing_content->end_date.month, p_timing_content->end_date.day, temp_week_tb, p_timing_content->exec
             -tue_time.hour, p_timing_content->exectue_time.min,module_name_1);
 683   3          }                            
 684   2        }
 685   1        // USER_PRINTF("-->timing_message is %s\n", mod_infom_tab);
 686   1        //  USER_PRINTF("-->module->index %bd\n",p_scenc_infor->index);
 687   1        write_dgusii_vp(0x6180 + (p_timing_content->time_scene_set.index) * 80, (unsigned char *)mod_infom_tab, 8
             -0);
 688   1        // USER_PRINTF("-->current_time_scene_index is %bd\n", p_timing_content->time_scene_set.index);
 689   1      }
 690          // 选择模块进行场景设置
 691          void module_timing_scene_select(module_t *p, unsigned char key)
 692          {
 693   1      
 694   1        norflash_read((key - 1) * 140, (unsigned char *)p, 140);
 695   1        //  USER_PRINTF("-->batch_set_parameters_flag after read module flash is %bd\n",g_var_module.batch_set_par
             -ameters_flag);
 696   1        if (0 == p->data_sta)
 697   1        {
 698   2          return;
 699   2        }
 700   1        switch (p->type)
 701   1        {
 702   2        case SINGLE_RELAY_MODULE:
 703   2        case SINGLE_TIME_RELAY_MODULE:
 704   2        case DOUBLE_RELAY_MODULE:
 705   2        case DOUBLE_TIME_RELAY_MODULE:
 706   2      
 707   2          display_relay_timing_scene_interface(p);
 708   2          USER_PRINTF("display_relay_timing_scene_interface\n");
 709   2          //        relay_read(p);
 710   2          break;
 711   2        case VOL_DIM_MODULE:
 712   2        case SCR_DIM_MODULE:
 713   2          //        clear_touch_sta();
 714   2          display_dim_timing_scene_interface(p);
 715   2          USER_PRINTF("display_dim_timing_scene_interface\n");
C51 COMPILER V9.60.0.0   TIME_SCENE                                                        11/02/2023 16:36:11 PAGE 14  

 716   2          //        dim_read(p);
 717   2          break;
 718   2          break;
 719   2        default:
 720   2      
 721   2          break;
 722   2        }
 723   1      }
 724          // 选择需要设置定时的模块
 725          void module_timing_scene_select_ctrl(module_t *p)
 726          {
 727   1        unsigned short key_nb = 0;
 728   1        get_key_value(0x10cb, &key_nb);
 729   1        if (key_nb)
 730   1        {
 731   2          module_timing_scene_select(p, key_nb);
 732   2          clear_key_value(0x10cb, &key_nb);
 733   2        }
 734   1      }
 735          // 定时场景添加
 736          void timing_scene_add(time_scene_set_t *p_time_scene)
 737          {
 738   1        unsigned char index = 0;
 739   1        index = get_blank_timing_scene_infor_index();
 740   1        if(OVERFLOW_SIZE == index)
 741   1        {
 742   2          USER_PRINTF("-->waring! too many timing scene \n");
 743   2          pop_menu_key_ctrl(OVERFLOW_WARING_CODE);
 744   2          return;
 745   2        } 
 746   1        pic_set(TIMING_SCENE_ADD_PAGE);
 747   1        p_time_scene->index = index;
 748   1        // USER_PRINTF("-->temp_get_blank_scene_index is %bd\n", p_time_scene->index);
 749   1      }
 750          // 定时场景删除
 751          void timing_scene_delete(timing_content_t *p_timing_content, time_scene_set_t *p_time_scene)
 752          {
 753   1        unsigned short key_nb = 0;
 754   1        get_key_value(0x1089, &key_nb);
 755   1        if ((1 == key_nb))
 756   1        {
 757   2          clear_key_value(0x1089, &key_nb);
 758   2          p_time_scene->index = get_timing_scene_name_select_sequence_number() - 1;
 759   2          // USER_PRINTF("-->temp_get_select_sequence_number_scene_index is %bd\n", p_time_scene->index);
 760   2          timing_scene_infor_delete(p_timing_content + p_time_scene->index, p_time_scene);
 761   2          USER_PRINTF("-->timing scene delect success!\n");
 762   2        }
 763   1      }
 764          // 定时场景清空
 765          void timing_scene_clear(timing_content_t *p_timing_content)
 766          {
 767   1        unsigned short key_nb = 0;
 768   1        get_key_value(0x1088, &key_nb);
 769   1        if ((1 == key_nb))
 770   1        {
 771   2          timing_scene_infor_clear(p_timing_content);
 772   2          clear_key_value(0x1088, &key_nb);
 773   2          USER_PRINTF("-->timing scene clear success!\n");
 774   2        }
 775   1      }
 776          void copy_to_temp_timing_content(timing_content_t *p_timing_content)
 777          {
C51 COMPILER V9.60.0.0   TIME_SCENE                                                        11/02/2023 16:36:11 PAGE 15  

 778   1        memcpy(&temp_timing_content, p_timing_content, sizeof(timing_content_t));
 779   1      }
 780          void display_all_on_off_interface(timing_content_t *p_timing_content)
 781          {
 782   1        pic_set(46);
 783   1        if (1 == p_timing_content->time_scene_set.all_on_off_sta)
 784   1        {
 785   2          write_dgus(0x1098, 1);
 786   2          write_dgus(0x1099, 0);
 787   2        }
 788   1        else if (2 == p_timing_content->time_scene_set.all_on_off_sta)
 789   1        {
 790   2          write_dgus(0x1098, 0);
 791   2          write_dgus(0x1099, 1);
 792   2        }
 793   1        else
 794   1        {
 795   2          write_dgus(0x1098, 0);
 796   2          write_dgus(0x1099, 0);
 797   2        }
 798   1      }
 799          
 800          void display_scene_time_interface(timing_content_t *p_timing_content)
 801          {
 802   1        unsigned char scene_name[16] = {0};
 803   1        pic_set(45);
 804   1        read_dgusii_vp(0x3320 + (p_timing_content->time_scene_set.scene_name_index - 1) * 8, (unsigned char *)sce
             -ne_name, 8);
 805   1        write_dgusii_vp(0x2009, scene_name, 8);
 806   1      }
 807          // 定时信息修改
 808          void timing_scene_modtify(timing_content_t *p_timing_content, time_scene_set_t *p_time_scene)
 809          {
 810   1        if (0 == get_timing_scene_name_select_sequence_number())
 811   1          return;
 812   1        p_time_scene->index = get_timing_scene_name_select_sequence_number() - 1;
 813   1        if (BLANK == (p_timing_content + p_time_scene->index)->time_scene_set.data_sta)
 814   1          return;
 815   1        USER_PRINTF("-->temp_get_select_sequence_number_scene_index is %bd\n", p_time_scene->index);
 816   1      
 817   1        USER_PRINTF("-->time_scene_exectue_type is %bd\n", (p_timing_content + p_time_scene->index)->time_scene_s
             -et.time_scene_exectue_type);
 818   1        copy_to_temp_timing_content(p_timing_content + p_time_scene->index);
 819   1        set_timing_set_infor(&(p_timing_content + p_time_scene->index)->start_date, &(p_timing_content + p_time_s
             -cene->index)->end_date, &(p_timing_content + p_time_scene->index)->exectue_time, &(p_timing_content + p_time_scene->inde
             -x)->time_scene_set);
 820   1      
 821   1        switch ((p_timing_content + p_time_scene->index)->time_scene_set.time_scene_exectue_type)
 822   1        {
 823   2        case MODULE_TIME:
 824   2          USER_PRINTF("-->time_module_scene_set.module_index is %bd\n", (p_timing_content + p_time_scene->index)->
             -time_scene_set.time_module_scene_set.module_index);
 825   2          module_timing_scene_select(&timing_module, (p_timing_content + p_time_scene->index)->time_scene_set.time
             -_module_scene_set.module_index + 1);
 826   2          //      set_timing_set_infor(&(p_timing_content+p_time_scene->index)->start_date,&(p_timing_content+p_time
             -_scene->index)->end_date,&(p_timing_content+p_time_scene->index)->exectue_time,&(p_timing_content+p_time_scene->index)->
             -time_scene_set);
 827   2          dis_module_scene_infor(&(p_timing_content + p_time_scene->index)->time_scene_set.time_module_scene_set);
 828   2          time_scene_var.module_select_sta = 1;
 829   2          time_scene_var.all_light_select_sta = 0;
 830   2          time_scene_var.scene_select_sta = 0;
 831   2          break;
C51 COMPILER V9.60.0.0   TIME_SCENE                                                        11/02/2023 16:36:11 PAGE 16  

 832   2        case ALL_ON_OFF_TIME:
 833   2          USER_PRINTF("-->all on off\n");
 834   2          display_all_on_off_interface(p_timing_content + p_time_scene->index);
 835   2          time_scene_var.module_select_sta = 0;
 836   2          time_scene_var.all_light_select_sta = 1;
 837   2          time_scene_var.scene_select_sta = 0;
 838   2          break;
 839   2        case SCENE_TIME:
 840   2          USER_PRINTF("-->scene time\n");
 841   2          display_scene_time_interface(p_timing_content + p_time_scene->index);
 842   2          time_scene_var.module_select_sta = 0;
 843   2          time_scene_var.all_light_select_sta = 0;
 844   2          time_scene_var.scene_select_sta = 1;
 845   2          break;
 846   2        default:
 847   2          break;
 848   2        }
 849   1        write_dgus(0x1092, time_scene_var.module_select_sta);
 850   1        write_dgus(0x1093, time_scene_var.all_light_select_sta);
 851   1        write_dgus(0x1094, time_scene_var.scene_select_sta);
 852   1      }
 853          // 定时场景编辑
 854          void timing_scene_edit(timing_content_t *p_timing_content, time_scene_set_t *p_time_scene)
 855          {
 856   1        unsigned short key_nb = 0;
 857   1        timing_scene_clear(p_timing_content);
 858   1        timing_scene_delete(p_timing_content, p_time_scene);
 859   1        get_key_value(0x1087, &key_nb);
 860   1        if ((key_nb))
 861   1        {
 862   2          switch (key_nb)
 863   2          {
 864   3          case ADD:
 865   3            timing_scene_add(p_time_scene);
 866   3      
 867   3            break;
 868   3          case MODIFY:
 869   3            timing_scene_modtify(p_timing_content, p_time_scene);
 870   3            break;
 871   3          default:
 872   3      
 873   3            break;
 874   3          }
 875   2          clear_key_value(0x1087, &key_nb);
 876   2        }
 877   1      }
 878          // 定时模块场景设定
 879          void timing_module_scene_set(module_t *p_module, timing_content_t *p_timing_content)
 880          {
 881   1        //  unsigned char temp_tab[32] = {0};
 882   1        //  read_dgusii_vp(0x2013,(unsigned char *)temp_tab,16);
 883   1        //  if(0 == strcmp(temp_tab, "未选择模块"))
 884   1        //  {
 885   1        //    USER_PRINTF("-->don't select module ,please select one module\n");
 886   1        //    return;
 887   1        //  }
 888   1      
 889   1        timing_module_relay_scene_set(p_module, &p_timing_content->time_scene_set.time_module_scene_set);
 890   1        timing_module_dim_scene_set(p_module, &p_timing_content->time_scene_set.time_module_scene_set);
 891   1        p_timing_content->time_scene_set.data_sta = 1;
 892   1        USER_PRINTF("--> select a module ok\n");
 893   1      }
C51 COMPILER V9.60.0.0   TIME_SCENE                                                        11/02/2023 16:36:11 PAGE 17  

 894          void scene_infor_module_confim_key(module_t *p_module, timing_content_t *p_timing_content, time_scene_set_
             -t *p_time_scene_set)
 895          {
 896   1        p_timing_content->time_scene_set.index = p_time_scene_set->index;
 897   1        p_timing_content->time_scene_set.time_scene_exectue_type = p_time_scene_set->time_scene_exectue_type;
 898   1        get_timing_set_infor(&p_timing_content->start_date, &p_timing_content->end_date, &p_timing_content->exect
             -ue_time, &p_timing_content->time_scene_set);
 899   1      
 900   1        timing_module_scene_set(p_module, p_timing_content);
 901   1        display_timing_scene_infor(p_timing_content);
 902   1        timing_scene_infor_save_flash(p_timing_content);
 903   1        printf_temp_timing_content(p_timing_content);
 904   1        //  printf_timing_content(10);
 905   1        clear_timing_scene_var();
 906   1        // p_time_scene_set->index
 907   1        USER_PRINTF("p_time_scene_set->index is %bd\n",p_time_scene_set->index);
 908   1        if (p_time_scene_set->index >= 5)
 909   1        {
 910   2          // USER_PRINTF("pic_page is %bd\n",pic_page);
 911   2          pic_page = TIMING_SCENE_MANGE_SECOND_PAGE + p_time_scene_set->index / 5 - 1;
 912   2          USER_PRINTF("pic_page is %bd\n",pic_page);
 913   2          pic_set(pic_page);
 914   2          
 915   2        }
 916   1        else
 917   1        {
 918   2          USER_PRINTF("p_time_scene_set->index is %bd\n",p_time_scene_set->index);
 919   2          pic_page = TIMING_SCENE_MANGE_FIRST_PAGE;
 920   2          USER_PRINTF("pic_page is %bd\n",pic_page);
 921   2          pic_set(pic_page);
 922   2        } 
 923   1        
 924   1      }
 925          void scene_infor_cancle_key(void)
 926          {
 927   1        clear_timing_scene_var();
 928   1        pic_set(pic_page);
 929   1      }
 930          void timing_specified_scene_set(time_scene_set_t *p_time_scene)
 931          {
 932   1        //  norflash_read(SCENE_NAME_FLASH_ADR_SATRT+p_time_scene->index*NAME_SCENE_T_SIZE+2,(unsigned char *)p_ti
             -me_scene->scene_name_index,1);//读flash
 933   1        if (0 == temp_timing_content.time_scene_set.scene_name_index)
 934   1        {
 935   2          USER_PRINTF("-->don't select scene ,please select one scene\n");
 936   2          return;
 937   2        }
 938   1        p_time_scene->data_sta = 1;
 939   1        p_time_scene->scene_name_index = temp_timing_content.time_scene_set.scene_name_index;
 940   1        USER_PRINTF("-->select scene index is %bd\n", p_time_scene->scene_name_index);
 941   1      }
 942          void specified_scene_confim_key(time_scene_set_t *p_time_scene, timing_content_t *p_timing_content, time_s
             -cene_set_t *p_time_scene_set)
 943          {
 944   1        p_timing_content->time_scene_set.index = p_time_scene_set->index;
 945   1        p_timing_content->time_scene_set.time_scene_exectue_type = p_time_scene_set->time_scene_exectue_type;
 946   1        get_timing_set_infor(&p_timing_content->start_date, &p_timing_content->end_date, &p_timing_content->exect
             -ue_time, &p_timing_content->time_scene_set);
 947   1      
 948   1        timing_specified_scene_set(p_time_scene);
 949   1        display_timing_scene_infor(p_timing_content);
 950   1        clear_timing_scene_var();
C51 COMPILER V9.60.0.0   TIME_SCENE                                                        11/02/2023 16:36:11 PAGE 18  

 951   1        timing_scene_infor_save_flash(p_timing_content);
 952   1      }
 953          
 954          // 0x1098-0x1099
 955          void timing_all_on_off_scene_set(time_scene_set_t *p_time_scene)
 956          {
 957   1        unsigned char on_sta = 0, off_sta = 0;
 958   1        on_sta = read_dgus(0x1098);
 959   1        off_sta = read_dgus(0x1099);
 960   1        if ((0 == on_sta) && (0 == off_sta))
 961   1        {
 962   2          p_time_scene->all_on_off_sta = 0;
 963   2          p_time_scene->data_sta = 0;
 964   2        }
 965   1        else if ((1 == on_sta))
 966   1        {
 967   2          p_time_scene->all_on_off_sta = 1;
 968   2          p_time_scene->data_sta = 1;
 969   2        }
 970   1        else if ((1 == off_sta))
 971   1        {
 972   2          p_time_scene->all_on_off_sta = 2;
 973   2          p_time_scene->data_sta = 1;
 974   2        }
 975   1      }
 976          void all_on_off_scene_confim_key(time_scene_set_t *p_time_scene, timing_content_t *p_timing_content, time_
             -scene_set_t *p_time_scene_set)
 977          {
 978   1        p_timing_content->time_scene_set.index = p_time_scene_set->index;
 979   1        p_timing_content->time_scene_set.time_scene_exectue_type = p_time_scene_set->time_scene_exectue_type;
 980   1        get_timing_set_infor(&p_timing_content->start_date, &p_timing_content->end_date, &p_timing_content->exect
             -ue_time, &p_timing_content->time_scene_set);
 981   1      
 982   1        timing_all_on_off_scene_set(p_time_scene);
 983   1        display_timing_scene_infor(p_timing_content);
 984   1        timing_scene_infor_save_flash(p_timing_content);
 985   1        clear_timing_scene_var();
 986   1      }
 987          void timing_scene_infor_ctrl(module_t *p_module, timing_content_t *p_timing_content, time_scene_set_t *p_t
             -ime_scene_set)
 988          {
 989   1        unsigned short key_nb = 0;
 990   1        get_key_value(0x10CC, &key_nb);
 991   1        if ((key_nb))
 992   1        {
 993   2          switch (key_nb)
 994   2          {
 995   3          case 1: // 模块确定
 996   3            scene_infor_module_confim_key(p_module, p_timing_content, p_time_scene_set);
 997   3      
 998   3            break;
 999   3          case 2:
1000   3            scene_infor_cancle_key();
1001   3            break;
1002   3          case 3: // 所有灯光确定
1003   3            all_on_off_scene_confim_key(&p_timing_content->time_scene_set, p_timing_content, p_time_scene_set);
1004   3      
1005   3            //        scene_infor_confim_key();
1006   3            break;
1007   3          case 4: // 指定场景确定
1008   3            specified_scene_confim_key(&p_timing_content->time_scene_set, p_timing_content, p_time_scene_set);
1009   3      
C51 COMPILER V9.60.0.0   TIME_SCENE                                                        11/02/2023 16:36:11 PAGE 19  

1010   3            break;
1011   3          case 5:
1012   3            scene_infor_cancle_key();
1013   3            break;
1014   3          default:
1015   3            break;
1016   3          }
1017   2          clear_key_value(0x10CC, &key_nb);
1018   2        }
1019   1      }
1020          // 定时模块选择控制
1021          void operand_ctrl(module_t *p_module, timing_content_t *p_timing_content)
1022          {
1023   1        unsigned short key_nb = 0;
1024   1      
1025   1        get_key_value(0x1095, &key_nb);
1026   1        if ((key_nb))
1027   1        {
1028   2          switch (key_nb)
1029   2          {
1030   3          case 1:
1031   3            write_dgus(0x1092, time_scene_var.module_select_sta ^= 1);
1032   3            write_dgus(0x1093, 0);
1033   3            write_dgus(0x1094, 0);
1034   3            time_scene_var.all_light_select_sta = 0;
1035   3            time_scene_var.scene_select_sta = 0;
1036   3      
1037   3            if (0 == p_module->data_sta)
1038   3            {
1039   4              pic_set(71);
1040   4            }
1041   3            else
1042   3            {
1043   4              pic_set(time_scene_var.page_bak);
1044   4            }
1045   3            if (0 == time_scene_var.module_select_sta)
1046   3            {
1047   4              pic_set(70);
1048   4              p_timing_content->time_scene_set.time_scene_exectue_type = EMPTY_TIME;
1049   4            }
1050   3            else
1051   3            {
1052   4              p_timing_content->time_scene_set.time_scene_exectue_type = MODULE_TIME;
1053   4            }
1054   3            break;
1055   3          case 2:
1056   3            write_dgus(0x1092, 0);
1057   3            write_dgus(0x1093, time_scene_var.all_light_select_sta ^= 1);
1058   3            write_dgus(0x1094, 0);
1059   3            time_scene_var.module_select_sta = 0;
1060   3            time_scene_var.scene_select_sta = 0;
1061   3      
1062   3            if (0 == time_scene_var.all_light_select_sta)
1063   3            {
1064   4              pic_set(70);
1065   4              p_timing_content->time_scene_set.time_scene_exectue_type = EMPTY_TIME;
1066   4            }
1067   3            else
1068   3            {
1069   4              pic_set(46);
1070   4              p_timing_content->time_scene_set.time_scene_exectue_type = ALL_ON_OFF_TIME;
1071   4            }
C51 COMPILER V9.60.0.0   TIME_SCENE                                                        11/02/2023 16:36:11 PAGE 20  

1072   3      
1073   3            break;
1074   3          case 3:
1075   3            write_dgus(0x1092, 0);
1076   3            write_dgus(0x1093, 0);
1077   3            write_dgus(0x1094, time_scene_var.scene_select_sta ^= 1);
1078   3      
1079   3            time_scene_var.module_select_sta = 0;
1080   3            time_scene_var.all_light_select_sta = 0;
1081   3            if (0 == time_scene_var.scene_select_sta)
1082   3            {
1083   4              pic_set(70);
1084   4              p_timing_content->time_scene_set.time_scene_exectue_type = EMPTY_TIME;
1085   4            }
1086   3            else
1087   3            {
1088   4              pic_set(45);
1089   4              p_timing_content->time_scene_set.time_scene_exectue_type = SCENE_TIME;
1090   4            }
1091   3            break;
1092   3          }
1093   2          clear_key_value(0x1095, &key_nb);
1094   2        }
1095   1      }
1096          // 定时场景选择控制
1097          void timing_scene_select_ctrl(time_scene_set_t *p_time_scene_set)
1098          {
1099   1        unsigned short key_nb = 0;
1100   1        unsigned char scene_name[16] = {0};
1101   1        get_key_value(0x1096, &key_nb);
1102   1        if ((key_nb))
1103   1        {
1104   2          read_dgusii_vp(0x3320 + (key_nb - 1) * 8, (unsigned char *)scene_name, 8);
1105   2          write_dgusii_vp(0x2009, (unsigned char *)scene_name, 8);
1106   2          clear_key_value(0x1096, &key_nb);
1107   2          if ((0 != strcmp(scene_name, "未启用")) && (0 != strcmp(scene_name, "未选择场景")))
1108   2          {
1109   3            p_time_scene_set->scene_name_index = key_nb;
1110   3            USER_PRINTF("-->timing select scene index is %bd\n", p_time_scene_set->scene_name_index);
1111   3          }
1112   2          else
1113   2          {
1114   3            p_time_scene_set->scene_name_index = 0;
1115   3            USER_PRINTF("-->don't select scene ,please select one scene\n");
1116   3          }
1117   2          pic_set(45);
1118   2        }
1119   1      }
1120          // 定时全开全关选择控制
1121          void timing_all_on_off_ctrl(void)
1122          {
1123   1        unsigned short key_nb = 0;
1124   1      
1125   1        get_key_value(0x1097, &key_nb);
1126   1        if ((key_nb))
1127   1        {
1128   2          switch (key_nb)
1129   2          {
1130   3          case 1:
1131   3            write_dgus(0x1098, time_scene_var.all_light_on_sta ^= 1);
1132   3            write_dgus(0x1099, 0);
1133   3            time_scene_var.all_light_off_sta = 0;
C51 COMPILER V9.60.0.0   TIME_SCENE                                                        11/02/2023 16:36:11 PAGE 21  

1134   3            break;
1135   3          case 2:
1136   3            write_dgus(0x1099, time_scene_var.all_light_off_sta ^= 1);
1137   3            write_dgus(0x1098, 0);
1138   3            time_scene_var.all_light_on_sta = 0;
1139   3            break;
1140   3          }
1141   2          clear_key_value(0x1097, &key_nb);
1142   2        }
1143   1      }
1144          // 模块定时发送场景
1145          void module_timing_send(time_module_scene_set_t *p)
1146          {
1147   1        if ((DOUBLE_RELAY_MODULE == p->type) || (DOUBLE_TIME_RELAY_MODULE == p->type))
1148   1        {
1149   2          set_master_send_hr(master_send_hr, 31, p->led_enable);
1150   2        }
1151   1        else
1152   1        {
1153   2          set_master_send_hr(master_send_hr, 31, p->led_enable << 4 | 0x08);
1154   2        }
1155   1        USER_PRINTF("module_timing_send led enable is %d\n", p->led_enable);
1156   1        set_master_send_hr(master_send_hr, 32, p->led_sta);
1157   1        USER_PRINTF("module_timing_send led sta is %d\n", p->led_sta);
1158   1        set_master_send_hr(master_send_hr, 33, ENTERPRISE);
1159   1        pack_data_send(&user_modbus, p->adr, MD_FR_MHR, 31, 3);
1160   1      }
1161          // 场景设定定时发送
1162          void scene_timing_send(time_scene_set_t *p)
1163          {
1164   1        set_master_send_hr(master_send_hr, 7, p->scene_name_index);
1165   1        set_master_send_hr(master_send_hr, 8, 1);
1166   1        pack_data_send(&user_modbus, 0, MD_FR_MHR, 7, 2);
1167   1      }
1168          // 定时发送全开全关
1169          void all_on_off_timing_send(time_scene_set_t *p)
1170          {
1171   1        if (1 == p->all_on_off_sta)
1172   1        {
1173   2          set_master_send_hr(master_send_hr, 31, 0xffff);
1174   2          set_master_send_hr(master_send_hr, 32, 0xffff);
1175   2          set_master_send_hr(master_send_hr, 33, (2 << 14) | ENTERPRISE);
1176   2        }
1177   1        else if (2 == p->all_on_off_sta)
1178   1        {
1179   2          set_master_send_hr(master_send_hr, 31, 0xffff);
1180   2          set_master_send_hr(master_send_hr, 32, 0x0000);
1181   2          set_master_send_hr(master_send_hr, 33, (2 << 14) | ENTERPRISE);
1182   2        }
1183   1        pack_data_send(&user_modbus, 0, MD_FR_MHR, 31, 3);
1184   1      }
1185          
1186          void timing_auto_detect(void)
1187          {
1188   1        unsigned char i = 0;
1189   1        unsigned char sys_time[8] = 0;
1190   1        static unsigned char sec_bak = 0;
1191   1        date_t temp_date = {0};
1192   1        time_t temp_time = {0};
1193   1        unsigned char week = 0;
1194   1        read_sys_time(sys_time);
1195   1        temp_date.year = sys_time[0];
C51 COMPILER V9.60.0.0   TIME_SCENE                                                        11/02/2023 16:36:11 PAGE 22  

1196   1        temp_date.month = sys_time[1];
1197   1        temp_date.day = sys_time[2];
1198   1        week = sys_time[3] > 0 ? (sys_time[3] - 1) : 6;
1199   1        temp_time.hour = sys_time[4];
1200   1        temp_time.min = sys_time[5];
1201   1        temp_time.sec = sys_time[6];
1202   1        //  printf_tab(8,sys_time);
1203   1        if (sec_bak != temp_time.sec)
1204   1        {
1205   2          sec_bak = temp_time.sec;
1206   2          for (i = 0; i < TIMING_SCENE_NUB_SIGNLE; i++)
1207   2          {
1208   3            if (BLANK == timing_content[i].time_scene_set.data_sta)
1209   3              continue;
1210   3            if (0 == timing_content[i].time_scene_set.date_enable)
1211   3            {
1212   4              //      USER_PRINTF("--->week is %bd \n",week);
1213   4              if (1 == GET_BIT(timing_content[i].time_scene_set.week_enable, week))
1214   4              {
1215   5                //        USER_PRINTF("--->%bd week enable\n",i);
1216   5                if ((temp_time.hour == timing_content[i].exectue_time.hour) && (temp_time.min == timing_content[i].ex
             -ectue_time.min) && (0 == temp_time.sec) && (0 == GET_BIT(time_scene_var.scene_send_sta[i / 8], i)))
1217   5                {
1218   6                  USER_PRINTF("--->it is time to send uart data\n");
1219   6                  SET_BIT(time_scene_var.scene_send_sta[i / 8], i);
1220   6                }
1221   5              }
1222   4            }
1223   3            else
1224   3            {
1225   4              if ((timing_content[i].start_date.year <= temp_date.year) && (timing_content[i].start_date.month <= te
             -mp_date.month) && (timing_content[i].start_date.day <= temp_date.day) && (timing_content[i].end_date.year >= temp_date.y
             -ear) && (timing_content[i].end_date.month >= temp_date.month) && (timing_content[i].end_date.day >= temp_date.day))
1226   4              {
1227   5                if (1 == GET_BIT(timing_content[i].time_scene_set.week_enable, week))
1228   5                {
1229   6                  if ((temp_time.hour == timing_content[i].exectue_time.hour) && (temp_time.min == timing_content[i].e
             -xectue_time.min) && (0 == temp_time.sec) && (0 == GET_BIT(time_scene_var.scene_send_sta[i / 8], i)))
1230   6                  {
1231   7                    SET_BIT(time_scene_var.scene_send_sta[i / 8], i);
1232   7                  }
1233   6                }
1234   5              }
1235   4            }
1236   3          }
1237   2        }
1238   1      }
1239          void timed_auto_send(void)
1240          {
1241   1        static unsigned char i = 0;
1242   1        if (GET_BIT(time_scene_var.scene_send_sta[i / 8], i))
1243   1        {
1244   2      
1245   2          if ((0 == time_scene_var.send_delay_time))
1246   2          {
1247   3            if ((0 == time_scene_var.cyc_send_time) && (mbh_getState() == MBH_STATE_IDLE))
1248   3            {
1249   4      
1250   4              time_scene_var.cyc_send_time = 100;
1251   4              CLEAR_BIT(time_scene_var.scene_send_sta[i / 8], i);
1252   4      
1253   4              switch (timing_content[i].time_scene_set.time_scene_exectue_type)
C51 COMPILER V9.60.0.0   TIME_SCENE                                                        11/02/2023 16:36:11 PAGE 23  

1254   4              {
1255   5              case MODULE_TIME:
1256   5                USER_PRINTF("time_scene_exectue_type is MODULE_TIME\n");
1257   5                module_timing_send(&timing_content[i].time_scene_set.time_module_scene_set);
1258   5                break;
1259   5              case ALL_ON_OFF_TIME:
1260   5                USER_PRINTF("time_scene_exectue_type is ALL_ON_OFF_TIME\n");
1261   5                all_on_off_timing_send(&timing_content[i].time_scene_set);
1262   5      
1263   5                break;
1264   5              case SCENE_TIME:
1265   5                USER_PRINTF("time_scene_exectue_type is SCENE_TIME\n");
1266   5                scene_timing_send(&timing_content[i].time_scene_set);
1267   5                break;
1268   5              default:
1269   5                break;
1270   5              }
1271   4              i++;
1272   4            }
1273   3          }
1274   2        }
1275   1        else
1276   1        {
1277   2          i++;
1278   2          //    time_scene_var.cyc_send_time = 100;
1279   2        }
1280   1        if (i > TIMING_SCENE_NUB_SIGNLE)
1281   1        {
1282   2          i = 0;
1283   2          //    memset(time_scene_var.scene_send_sta,0,16);
1284   2          //    memset(time_scene_var.scene_send_sta);
1285   2        }
1286   1      }
1287          void set_the_right_number_of_days(unsigned short year_adr, unsigned short month_adr,unsigned short day_adr
             -)
1288          {
1289   1        unsigned char day = 0;
1290   1        unsigned char month = 0;
1291   1        unsigned short year = 0;
1292   1        year = read_dgus(year_adr);
1293   1        sys_delay_about_ms(1);
1294   1        month = read_dgus(month_adr);
1295   1        
1296   1        day = get_days_in_month(year,month);
1297   1        // sys_delay_about_ms(2);
1298   1        // USER_PRINTF("the year is %d\n",year);
1299   1        // USER_PRINTF("the month is %bd\n",month);
1300   1        // USER_PRINTF("the day is %bd\n",day);
1301   1        if(read_dgus(day_adr)>day)
1302   1        {
1303   2          sys_delay_about_ms(2);
1304   2          write_dgus(day_adr,day);
1305   2        }
1306   1      
1307   1      }
1308          void right_number_of_days_ctrl(void)
1309          {
1310   1        set_the_right_number_of_days(TIMING_SCENE_START_YEAR,TIMING_SCENE_START_MONTH,TIMING_SCENE_START_DAY);
1311   1        set_the_right_number_of_days(TIMING_SCENE_END_YEAR,TIMING_SCENE_END_MONTH,TIMING_SCENE_END_DAY);  
1312   1      
1313   1      }
1314          void timing_scene_run(void)
C51 COMPILER V9.60.0.0   TIME_SCENE                                                        11/02/2023 16:36:11 PAGE 24  

1315          {
1316   1        module_timing_scene_select_ctrl(&timing_module);
1317   1        operand_ctrl(&timing_module, &temp_timing_content);
1318   1        timing_scene_infor_ctrl(&timing_module, (timing_content + temp_timing_content.time_scene_set.index), &tem
             -p_timing_content.time_scene_set);
1319   1        timing_all_on_off_ctrl();
1320   1        timing_scene_select_ctrl(&temp_timing_content.time_scene_set);
1321   1        timing_scene_edit(&timing_content, &temp_timing_content.time_scene_set);
1322   1      
1323   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  10438    ----
   CONSTANT SIZE    =   2754    ----
   XDATA SIZE       =   4937    1132
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
